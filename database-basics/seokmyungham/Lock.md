# 락

`락`은 대표적인 병행 제어 기법으로, 병행 수행하면서도 직렬 가능성을 보장하기 위한 기법이다.  

기본 원리는 한 트랜잭션이 먼저 접근한 데이터에 대한 연산을 끝내기 전까지는 다른 트랜잭션이 그 데이터에 접근하지 못하도록 `상호 배제`함

## 기본 로킹 규약의 효율성을 높이기 위한 방법

트랜잭션들이 같은 데이터에 동시에 `read` 연산을 실행하는 것을 허용한다.  
lock 연산을 두 가지 종류로 구분하여 사용

- `공유 락` (공용 락)
  - 트랜잭션이 데이터에 대해 `공유 락` 연산을 실행하면, 해당 데이터에 read 연산을 실행할 수 있지만 write 연산은 실행할 수 없다.
  - 그리고 해당 데이터에 다른 트랜잭션도 `공유 락` 연산을 동시에 실행할 수 있다.
- `배타 락` (전용 락)
  - 트랜잭션이 데이터에 `전용 락` 연산을 실행하면 해당 데이터에 read 연산과 write 연산을 모두 실행할 수 있다.
  - 다른 트랜잭션은 해당 데이터에 어떠한 락 연산도 실행할 수 없다. (독점권)
 
- 기본 로킹 규약으로 직렬 가능성이 보장되지 않는 스케쥴
  - 트랜잭션 T1이 데이터 X에 너무 빨리 unlock 연산을 실행하면 트랜잭션 T2가 일관성 없는 데이터에 접근할 수 있다.

![image](https://github.com/seokmyungham/DB-Study/assets/97608735/0d667324-5ab3-4259-9268-ba405f50632b)


## 2단계 로킹 규약(2PLP; 2 Phase Locking Protocol)

기본 로킹 규약의 문제를 해결하고 트랜잭션의 직렬 가능성을 보장하기 위해 `락`과 `언락` 연산의 수행 시점에 대한 새로운 규약을 추가한 것  
  
트랜잭션이 `락`과 `언락` 연산을 확장 단계와 축소 단계로 나누어 실행한다  
- 트랜잭션이 처음 수행되면 확장 단계로 들어가 `락` 연산만 실행 가능
- `언락` 연산을 실행하면 축소 단계로 들어가 `언락` 연산만 실행 가능
- 따라서 첫 번째 `언락` 연산 실행 전에 필요한 모든 `락` 연산을 실행해야 함

![image](https://github.com/seokmyungham/DB-Study/assets/97608735/fd5f42f1-690d-4f58-b14c-cf6097c55056)


## 트랜잭션 고립 수준

### 트랜잭션 동시 실행 문제

- 오손 읽기(Dirty Read)
  - read 작업을 하는 T1이 write 작업을 하는 T2가 작업한 중간 데이터를 읽어서 발생하는 문제
  - 작업중인 T2가 작업을 중간에 롤백할 경우 T1은 무효가 된 데이터를 읽게 되고 잘못된 결과를 도출 

- 반복불가능 읽기(Non Repeatable Read)
  - T1이 데이터를 read하고 T2가 데이터를 `write(갱신)`하고 T1가 다시 한 번 데이터를 read할 때 생기는 문제
  - T1가 read를 다시 한 번 반복할 경우 이전의 결과와 다른 결과가 나오는 현상
 
- 유령데이터 읽기(Phantom read)
  - T1가 데이터를 read하고 T2가 데이터를 `write(삽입)`하고 T1가 다시 한 번 데이터를 read할 때 생기는 문제
  - T1가 read를 다시 한 번 반복할 경우 이전에 없던 유령 데이터가 나타나는 현상
 
### 트랜잭션 고립 수준 명령어(transaction isolation level instruction)

|고립수준/문제|오손 읽기|반복불가능 읽기|유령데이터 읽기|
|---|---|---|---|
|READ UNCOMMITTED|가능|가능|가능|
|READ COMMITTED|불가능|가능|가능|
|REPEATABLE READ|불가능|불가능|가능|
|SERIALIZABLE|불가능|불가능|불가능|

### READ UNCOMMITTED (Level = 0) (MongoDB)

고립 수준이 가장 낮은 명령어로, 자신의 데이터에 아무런 공유락을 걸지 않음

### READ COMMITTED (Level = 1) (Oracle DB, PostgreSQL)

`Dirty Read`를 피하기 위해 자신의 데이터를 읽는 동안 공유락을 걸지만 트랜잭션이 끝나기 전에라도 해지 가능함
- Select: 공유락을 걸고 끝나면 바로 해지
- Update: 배타락 설정

### REPEATABLE READ (Level = 2) (MySQL)

자신의 데이터에 설정된 공유락과 배타락을 트랜잭션이 종료할 떄까지 유지하여 다른 트랜잭션이 자신의 데이터를 `갱신할 수 없도록` 함
- Select: 공유락을 걸고 트랜잭션을 끝까지 유지
- Update: 배타락 설정

### SERIALIZABLE

고립 수준이 가장 높은 명령어로, 실행 중인 트랜잭션은 다른 트랜잭션으로부터 완벽하게 분리
- Select: 공유락을 걸고 트랜잭션을 끝까지 유지
- Update: 배타락 설정
- 인덱스에 공유락을 설정하여 다른 트랜잭션의 INSERT문 금지
