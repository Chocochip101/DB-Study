# 트랜잭션

`트랜잭션`은 데이터베이스에서 하나의 논리적인 작업 단위를 나타낸다.  
장애 발생 시 복구 작업이나 병행 제어 작업을 위한 중요한 단위로 사용된다.  
데이터베이스의 일관성과 무결성을 보장하고, 데이터베이스 시스템의 안정성을 유지하는데 중요한 역할을 한다.

## 트랜잭션의 특성

### 원자성(Atomicity)

트랜잭션의 연산들이 모두 정상적으로 실행되거나 하나도 실행되지 않아야 하는 all-or-nothing을 의미한다.  
> Transaction 1  
> update account set money = money - 5000 where num = loki  
> update account set money = money + 5000 where num = chocochip 
- 만약 트랜잭션 수행 도중 장애가 발생하면?
  - 지금까지 실행한 연산 처리를 모두 취소하고, 데이터베이스를 트랜잭션 작업 전 상태로 되돌려여한다.
 
원자성의 보장을 위해 장애 발생 시 회복 기능이 필요

### 일관성(consistency)

트랜잭션이 성공적으로 수행된 후에도 데이터베이스가 일관된 상태를 유지해야 함을 의미한다.

### 격리성(isolation)

수행 중인 트랜잭션이 완료될 때까지 다른 트랜잭션들이 중간 연산 결과에 접근할 수 없음을 의미한다.  
  
격리성의 보장을 위해서는 여러 트랜잭션이 동시에 수행되더라도 마치 순서대로 하나씩 수행되는 것 처럼 정확하고
일관된 결과를 얻을 수 있도록 제어하는 기능이 필요

### 지속성(durability)

트랜잭션이 성공적으로 완료된 후 데이터베이스에 반영한 수행 결과는 영구적이어야 함을 의미한다.  

지속성의 보장을 위해서는 장애 발생 시 회복 기능이 필요  

#

## 트랜잭션의 주요 연산

![image](https://github.com/seokmyungham/DB-Study/assets/97608735/52bf99f9-f813-4385-a5ea-7ae38cf0e2cc)

### Commit 연산

트랜잭션의 수행이 성공적으로 완료되었음을 선언하는 연산  
`commit` 연산이 실행되면 트랜잭션의 수행 결과가 데이터베이스에 반영되고 일관된 상태를 지속적으로 유지하게 됨

### Rollback 연산

트랜잭션의 수행이 실패했음을 선언하는 연산  
`rollback` 연산이 실행되면 트랜잭션이 지금까지 실행한 연산의 결과가 취소되고 데이터베이스가 트랜잭션 수행 전의 일관된 상태로 되돌아감

#

## 장애와 회복

### 트랜잭션 장애(failure)

트랜잭션 수행 중 오류가 발생하여 정상적으로 수행을 계속할 수 없는 상태  
- 트랜잭션의 논리적 오류, 잘못된 데이터 입력, 시스템 자원의 과다 사용 요구, 처리 대상 데이터의 부재 등..

### 회복(recovery)

장애가 발생했을 때 데이터베이스를 장애가 발생하기 전의 일관된 상태로 복구시키는 것을 의미  
트랜잭션의 특성을 보장하고, 데이터베이스를 일관된 상태로 유지하기 위해 필수적인 기능이다.  

회복을 위해 데이터베이스 복사본을 만드는 방법
- 덤프
  - 데이터베이스 전체를 다른 저장 장치에 주기적으로 복사하는 방법
- 로그
  - 데이터베이스에서 변경 연산이 실행될 때마다 데이터를 변경하기 이전 값과 변경한 이후의 값을 별도의 파일에 기록하는 방법
 
회복을 위한 기본 연산
- `redo`
  - 로그를 이용해 복사본이 만들어진 이후에 실행된 모든 변경 연산을 재실행하여 장애가 발생하기 직전의 데이터베이스 상태로 복구
- `undo`(transaction rollback)
  - 로그를 이용해 지금까지 실행된 모든 변경 연산을 취소하여 데이터베이스를 원래 상태로 복구
 
### 로그 회복 기법

- 즉시 갱신 회복 기법
  - 트랜잭션 수행 중에 데이터 변경 연산의 결과를 데이터베이스에 즉시 반영
  - 장애 발생에 대비하기 위해 내용을 로그 파일에 기록
    - 트랜잭션이 완료되기 전에 장애가 발생한 경우 -> `undo` 연산 실행
    - 트랜잭션이 완료된 후에 장애가 발생한 경우 -> `redo` 연산 실행
- 지연 갱신 회복 기법
  - 트랜잭션 수행 중에 데이터 변경 연산의 결과를 로그에만 기록핻고, 트랜잭션이 부분 완료된 후에 로그를 이용해 한번에 반영
    - 트랜잭션 수행 중에 장애가 발생할 경우 별다른 회복 조치를 하지 않고 로그 기록을 버림
    - 트랜잭션 완료된 후에 장애가 발생한 경우 `undo` 연산은 필요없고 `redo` 연산만 사용
   
### 검사 시점 회복 기법

![image](https://github.com/seokmyungham/DB-Study/assets/97608735/8a49e010-2965-47d1-8df9-9ed765d0c0a8)

#

## 병행 제어

`병행 수행`은 여러 사용자가 데이터베이스를 동시 공유할 수 있도록 여러 개의 트랜잭션을 동시에 수행하는 것을 의미한다.  
여러 트랜잭션이 차례로 번갈아 수행됨  

### 병행 수행 시 발생할 수 있는 문제

- 갱신 분실
  - 두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신할 때 발생함
- 모순성
  - 하나의 트랜잭션이 여러 개 데이터 변경 연산을 실행할 때 일관성 없는 상태의 데이터베이스에서 데이터를 가져와 연산함으로 모순된 결과가 발생
- 연쇄 복귀
  - 트랜잭션이 완료되기 전 장애가 발생하여 롤백을 수행하면, 이 트랜잭션이 변경한 데이터를 가져간 다른 트랜잭션에도 롤백을 연쇄적으로 실행해야 한다.

#

## 트랜잭션 스케쥴

### 직렬 스케쥴 (serial schedule)

`인터리빙` 방식을 이용하지 않고 각 트랜잭션 별로 연산들을 순차적으로 실행시키는 것

- 다른 트랜잭션의 방해를 받지 않기 때문에 독립적으로 수행됨, 항상 모순이 없는 정확한 결과
- 각 트랜잭션을 독립적으로 수행하기 때문에 병행 수행으로 볼 수 없음

### 비직렬 스케쥴 (nonserial schedule)

`인터리빙` 방식을 이용하여 트랜잭션을 병행 수행하는 것  

- 트랜잭션이 번갈아 실행 되기때문에, 비직렬 스케쥴에 따라 갱신 분실, 모순성, 연쇄 복귀 등의 문제가 발생할 수 있음

### 직렬 가능 스케쥴 (serializable schedule)

`직렬 스케쥴`에 따라 수행한 것과 같이 정확한 결과를 생성하는 `비직렬 스케쥴`  
`비직렬 스케쥴` 중에서 수행 결과가 동일한 `직렬 스케쥴`이 있는 것  
