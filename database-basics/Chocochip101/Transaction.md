
# 트랜잭션
트랜잭션은 DBMS에서 데이터를 다루는 논리적인 작업의 단위이다. 보통 단일 SQL 문을 사용하여 다루기도 하지만 여러 개의 SQL 문을 순차적으로 수행하여 다루기도 한다. 데이터베이스에서 트랜잭션을 정의하는 이유는 다음과 같다. 

- 데이터베이스에서 데이터를 다룰 때 장애가 일어나는 경우가 있다. 트랜잭션은 장애 발생 시 데이터를 복구하는 작업의 단위가 된다. 
- 데이터베이스에서 여러 작업이 동시에 같은 데이터를 다룰 때가 있다. 트랜잭션은 이 작업을 서로 분리하는 단위가 된다.

트랜잭션 수행 과정을 정리하면 아래와 같다. 트랜잭션은 `시작 - 수행 - 부분완료 - 완료`의 과정을 거치게 된다. 부분완료는 트랜잭션의 종료를 사용자나 다른 트랜잭션에게 알리는 단계이다. 부분완료된 트랜잭션은 DBMS가 다른 트랜잭션의 작업 처리 상황을 고려하여 변경 내용을 하드디스크에 기록한다. 기록이 끝나면 완료를 하고, 그 후에는 다른 트랜잭션이 데이터를 자유롭게 사용할 수 있다.

![](https://velog.velcdn.com/images/chocochip/post/e547d0ed-1cb9-48c1-a4d8-861ed2641da0/image.png)


## 트랜잭션 성질

- 원자성: 트랜잭션에 포함된 작업은 전부 수행되거나 아니면 수행되지 않아야 한다.
- 일관성: 트랜잭션을 수행하기 전이나 후나 데이터베이스는 항상 일관된 상태를 유지해야 한다.
- 고립성: 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하는 일이 없어야 한다.
- 지속성: 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다.

### 원자성
원자성이란 일부만 수행되는 일이 없도록 전부 수행하거나 아예 수행하지 않아야 한다. SQL에서는 트랜잭션의 시작과 끝을 표시하기 위해 START TRANSACTION ... COMMIT 문을 사용한다. 트랜잭션 중간에 작업이 잘못되면 회복 알고리즘을 이용하여 변경한 내용을 취소한다(자의적으로 트랜잭션을 취소하는 명령어 ROLLBACK을 사용하기도 한다). COMMIT과 ROLLBACK 명령어는 트랜잭션 제어 명령어라고 한다.
             
|표준 명령어|문법|설명|
|---|---|---|
|START TRANSACTION|SET TRANSACTION|트랜잭션 시작|
|COMMIT|COMMIT|트랜잭션 종료|
|ROLLBACK|ROLLBACK {TO `<savepoint>`}|트랜잭션을 전체 혹은 `<savepoint>`까지 무효화시킨다|
|SAVE|SAVEPOINT `<indentifier>`|`<savepoint>`를 만든다|

트랜잭션의 길이가 길면 트랜잭션의 중간 지점에 수정 내용을 반영하는 포인트를 만드는데, 이를 SAVEPOINT라고 한다. 트랜잭션이 잘못되어 처음부터 다시 실행해야 하는 경우 트랜잭션의 처음이 아니라 SAVEPOINT까지 되돌아가면 트랜잭션 전체가 ROLLBACK되는 것을 막을 수 있다. SAVEPOINT는 트랜잭션 내에서 여러 개를 만들 수 있다.


### 일관성
트랜잭션은 데이터베이스의 일관성을 유지해야 한다. 여기서 일관성이란 테이블이 생성될 때 CREATE 문과 ALTER 문의 무결성 제약조건을 통해 명시된다. 다만 수행 중 일시적으로 일관성을 유지하지 못하는 상태가 있을 수도 있다.

![](https://velog.velcdn.com/images/chocochip/post/52e26004-6f13-4ebf-a192-55121b0ac3d6/image.jpg)


### 고립성
데이터베이스는 공유가 목적이기 때문에 여러 트랜잭션이 동시에 수행된다. 이때 각 트랜잭션은 다른 트랜잭션의 방해를 받지 않고 독립적으로 작업을 수행한다. 이렇게 여러 트랜잭션이 동시에 수행될 때 상호 간섭이나 데이터 충돌이 일어나지 않는 형상을 고립성이라고 한다.

같은 시간대에 여러 트랜잭션이 같은 데이터를 읽고 쓸 경우, 변경 중인 데이터를 다은 트랜잭션이 사용하면 데이터의 일관성이 훼손될 수 있다. 따라서 동시에 수행되는 트랜잭션이 같은 데이터를 가지고 충돌하지 않도록 제어하는 작업이 필요하다. 이 작업을 동시성 제어라고 한다.

![](https://velog.velcdn.com/images/chocochip/post/84c5bc5c-49bf-49e9-8fe0-8529e0411f53/image.jpg)


### 지속성
트랜잭션이 정상적으로 완료 혹은 부분완료한 데이터는 반드시 데이터베이스에 기록되어야 한다. 이러한 성질을 트랜잭션의 지속성이라고 한다. DBMS 복구 시스템은 트랜잭션이 작업한 내용을 수시로 로그 데이터베이스에 기록했다가 문제가 발생하면 로그 파일을 이용하여 복구 작업을 수행한다. 즉 시스템이 멈추어도 트랜잭션 수행으로 변경된 내용은 디스크에 기록된다.

트랜잭션 상태도는 아래와 같다. 트랜잭션은 수행을 완료하면 부분완료 혹은 실패 상태 중 하나가 된다. DBMS는 부분완료 상태에서는 작업한 내용을 데이터베이스에 반영하고, 실패 상태에서는 작업한 내용을 취소한다.

![](https://velog.velcdn.com/images/chocochip/post/f444899a-d1e0-41ff-9c07-939aa0280054/image.png)

- 부분완료: 트랜잭션 수행을 완료되었지만 변경 내용이 데이터베이스에 기록되었는지 확실하지 않은 상태이다. 이 상태에서는 DBMS가 최종적으로 변경 내용을 데이터베이스에 기록해야 완료 상태가 된다. 만약 시스템 내부의 문제 혹은 시스템 다운 등으로 DBMS가 변경 내용을 데이터베이스에 기록하지 못하면 실패 상태가 된다.
- 실패: 트랜잭션 중간에 중단했거나 부분완료 상태에서 변경 내용을 DB에 저장하지 못한 상태를 말한다. 실패 상태에서 DBMS는 트랜잭션이 수행한 작업을 모두 원상복구 시킨다.

## 트랜잭션과 DBMS
DBMS는 트랜잭션이 ACID를 유지할 수 있도록 지원한다. 먼저 원자성을 유지하기 위해 회복(복구) 관리자 프로그램을 작동시킨다. 회복 관리자 프로그램은 데이터베이스가 변경한 내용을 로그로 기록하고 있다가 트랜잭션에 문제가 생겼을 때 원래 상태로 되돌린다.

DBMS는 일관성을 유지하기 위해 무결성 제약조건을 활용한다. 트랜잭션 수행 시 데이터에 변경이 가해지면 미리 정의해 둔 무결성 제약조건을 검사하여 일관성이 깨지는 것을 막는다. 그런데 두 개의 트랜잭션이 동시에 수행될 때 트랜잭션 간에 간섭으로 일관성이 깨지는 현상은 무결성 제약조건을 검사하는 것으로 해결할 수 없다. 동시에 같은 데이터를 접근하는 트랜잭션들이 질서 있게 접근하여 데이터베이스의 일관성을 유지하도록 하기 위해서는 동시성 제어 알고리즘을 작동시켜야 한다.

DBMS는 고립성을 유지하기 위해 일관성을 유지하는 것과 마찬가지로 **동시성 제어 알고리즘**을 작동시킨다. 두 개의 트랜잭션이 동시에 수행될 때 간섭에 의하여 데이터 값이 손상되면 고립성이 깨진다. 이 경우 동시성 제어 알고리즘을 작동시켜 여러 트랜잭션이 동시에 같은 데이터를 접근할 때 마치 한 트랜잭션씩 순서대로 접근하는 것처럼 제어한다. DBMS는 지속성을 유지하기 위해 회복 관리자 프로그램을 이용한다. 회복 관리자 프로그램은 데이터베이스가 변경한 내용을 로그로 기록하고 있다가 트랜잭션에 문제가 있을 때 원래 상태로 되돌린다.

트랜잭션의 4가지 성질과 각 성질을 유지시키는 위한 DBMS의 기능을 그림으로 나타내면 다음과 같다.

![](https://velog.velcdn.com/images/chocochip/post/358b6fd5-159f-4c8d-8f7c-bc54b7b38618/image.png)


# 동시성 제어
한 개의 트랜잭션이 끝나고 다음 트랜잭션을 수행시키면 데이터베이스의 일관성에 문제가 없다. 그러나 데이터베이스는 공유를 목적으로 하기 때문에 가능한 많은 트랜잭션을 동시에 수행시켜야 한다. 동시에 수행되는 트랜잭션은 다른 트랜잭션이 같은 데이터를 공유하고 있다는 사실을 모를 수 있기 때문에 일관성이 훼손될 수 있다. **트랜잭션이 동시에 수행될 때, 일관성을 해치지 않고 트랜잭션의 데이터 접근을 제어하는 DBMS의 기능을 동시성 제어라고 한다.**

두 개의 트랜잭션이 한 개의 데이터에 동시 접근할 때 발생할 수 있는 상황이다.

|상황|트랜잭션 1|트랜잭션 2|발생 문제|동시 접근|
|---|---|---|---|---|
|`상황 1`|read|read|없음|허용|
|`상황 2`|read|write|Dirty read, Unrepeatable read, Phantom read|허용 또는 불가 선택|
|`상황 3`|write|write|Lost Update|허용 불가(Lock 이용)|

`상황 1`은 두 트랜잭션이 각각 읽기만하기에 동시 진행에 아무 문제가 없다. `상황 2`는 두 트랜잭션 중 하나가 쓰기 작업을 하는 경우로 트랜잭션 격리 수준으로 동시 접근을 허용 또는 불가하게 할 수 있다. `상황 3`은 모두 쓰기 작업으로 **Lost Update** 문제가 발생할 수 있다. 

## Lost Update
Lost Update 문제는 두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신할 때 발생한다. Lost Update 문제는 데이터베이스에서 절대 발생하면 안되는 현상이다.

## 트랜잭션 격리 수준

# MySQL의 격리 수준
트랜잭션의 격리 수준이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다. 격리 수준은 크게 `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE`로 나뉜다. 4개의 격리 수준에서 순서대로 뒤로 갈수록 각 트랜잭션 간의 데이터 격리 정도가 높아지며, 동시 처리 성능도 떨어진다. 

|격리 수준|DIRTY READ|NON-REPEATABLE READ|PHANTOM READ|
|---|---|---|---|
|`READ UNCOMMITTED`|발생|발생|발생|
|`READ COMMITTED`|없음|발생|발생|
|`REPEATABLE READ`|없음|없음|발생(InnoDB는 없음)|
|`SERIALIZABLE`|없음|없음|없음|

InnoDB의 독특한 특성 때문에 `REPEATABLE READ` 격리 수준에서 `PHANTOM READ`가 발생하지 않는다.

## READ UNCOMMITTED
`READ UNCOMMITTED` 격리 수준에서는 COMMIT과 ROLLBACK에 상관 없이 다른 트랜잭션에게 보여진다.

![](https://velog.velcdn.com/images/chocochip/post/2c2c24c6-8ac4-481d-b704-a136f57b6cfa/image.jpeg)

1. 사용자 A가 `emp_no`가 500000이고 `first_name`이 "Lara"인 새로운 직원을 INSERT한다.
2. 사용자 B는 커밋하기 전에 `emp_no=500000`
인 사원 검색에 성공한다.
3. 사용자 A의 트랜잭션에 문제가 발생하여 롤백된다.
4. 사용자 B는 "Lara"가 정상적인 사원이라고 생각하고 처리한다.


### Dirty Read
1. 사용자 A는 `emp_no=500000`이고 `first_name`이 "Lara"인 새로운 사원을 INSERT한다. 
2. 사용자 B가 변경된 내용을 커밋하기도 전에 `emp_no=500000`인 사원을 검색한다.
3. 사용자 B는 사용자 A가 INSERT한 사원의 정보를 커밋되지 않은 상태에서도 조회한다. 
4. 사용자 A의 문제로 인해 INSERT된 내용을 롤백되었다.
5. 여전히 사용자 B는 "Lara"가 정상적인 사원이라고 생각하고 계속 처리한다.

이처럼 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상을 더티 리드(Dirty read)라 하고, 더티 리드가 허용되는 격리 수준이 `READ UNCOMMITTED`다. 더티 리드 현상은 데이터가 나타났다가 사라졌다 하는 현상을 초래하므로 정합성에 문제가 많은 격리 수준이다.

## READ COMMITTED
`READ COMMITTED`는 오라클 DBMS에서 기본으로 사용되는 격리 수준이며, 온라인 서비스에서 가 장 많이 선택되는 격리 수준이다. 이 레벨에서는 위에서 언급한 더티 리드(Dirty read) 같은 현상은 발생하지 않는다. 어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에 서 조회할 수 있기 때문이다.

![](https://velog.velcdn.com/images/chocochip/post/62512578-55fd-4b2c-a990-270bfe7f537f/image.jpeg)

1. 사용자 A는 `emp_no=500000`인 사원의 `first_name`을 "Lara"에서 "Toto"로 변경했다.
2. 새로운 값인 "Toto"는 employees 테이블에 즉시 기록되고 이전 값인 "Lara"는 언두 영역으로 백업된다. 
3. 사용자 A가 커밋을 수행하기 전에 사용자 B가 `emp_no=500000`인 사원을 SELECT하면 조회된 결과의 `first_name` 칼럼의 값은 "Toto"가 아니라 "Lara"로 조회된다. 

여기서 사용자 B의 SELECT 퀴리 결과는 employees 테이블이 아니라 언두 영역에 백업된 레코드에서 가져온 것이다. `READ COMMITTED` 격리 수준에서는 어떤 트랜잭선에서 변경한 내용이 커밋되기 전까지는 다른 트랜잭선에서 그러한 변경 내역을 조회할 수 없기 때문이다. 최종적으로 사용자 A가 변경된 내용을 커밋하면 그때부터는 다른 트랜잭션에서도 백업된 언두 레코드("Lara")가 아니라 새롭게 변경된 "Toto"라는 값을 참조할 수 있게 된다. 

### NON-REPEATABLE READ
`READ COMMITTED` 격리 수준에서도 "NON-REPEATABLE READ"(repeatable READ"가 불가능하다)라는 부정합의 문제가 있다.

![](https://velog.velcdn.com/images/chocochip/post/01201fdc-7509-480b-9b81-d6f1ee7eabec/image.jpeg)

1. 사용자 B가 BEGIN 명령으로 트랜잭션을 시작한다.
2. `first_name`이 "Toto"인 사용자를 검색했는데, 일치하는 결과가 없다.
3. 사용자 A가 사원 번호가 500000인 사원의 이름을 "Toto"로 변경하고 커밋을 실행한다.
4. 사용자 B가 똑같은 SELECT 쿼리로 다시 조회하면 이번에는 결과가 1건이 조회된다. 

이는 별다른 문제가 없어 보이지만, 사실 사용자 B가 하나의 트랜잭션 내에서 똑같 은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 한다는 `REPEATABLE READ` 정합성에 어긋나는 것이다. 

이러한 부정합 현상은 일반적인 웹 프로그램에서는 크게 문제되지 않을 수 있지만 하나의 트랜잭션에서 동일 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 될 수도 있다. 예를 들어, 다른 트랜잭션에서 입금과 출금 처리가 계속 진행될 때 다른 트랜잭션에서 오늘 입금된 금액의 총합을 조회한다고 가정해보자. 그런데 "REPEATABLE READ"가 보장되지 않기 때문에 총합을 계산하는 SELECT 쿼리는 실행될 때마다 다른 결과를 가져올 것이다. 중요한 것은 사용 중인 트랜잭션의 격리 수준에 의해 실행하는 SQL 문장이 어떤 결과를 가져오게 되는지를 정확히 예측할 수 있어야 한다는 것이다. 그리고 당연히 이를 위해서는 각 트랜잭션의 격리 수준이 어떻게 작동하는지 알아야 한다. 

### 트랜잭션 외부,내부에서의 SELECT
가끔 사용자 중에서 트랜잭션 내에서 실행되는 SELECT 문장과 트랜잭션 없이 실행되는 SELECT 문장의 차이를 혼동하는 경우가 있다. `READ COMMITTED` 격리 수준에서는 트랜잭션 내에서 실행되는 SELECT 문장과 트랜잭션 외부에서 실행되는 SELECT 문장의 차이가 별로 없다. 

하지만 `REPEATABLE READ` 격리 수준에서는 기본적으로 SELECT 쿼리 문장도 트랜잭션 범위 내에서만 작동한다. 즉, START TRANSACTION(또는 BEGIN) 명령으로 트랜잭션을 시작한 상태에서 온종일 동일한 쿼리를 반복해서 실행해 봐도 동일한 결과만 보게 된다(아무리 다른 트랜잭션에서 그 데이터를 변경하고 COMMIT을 실행한다고 하더라도 말이다). 별로 중요하지 않은 차이처럼 보이지만 이런 문제로 데이터의 정합성이 깨지고 그로 인해 애플리케이션에 버그가 발생하면 찾아내기가 쉽지 않다. 

## REPEATABLE READ
`REPEATABLE READ`는 MySQL의 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준이다. 바이너리 로그를 가진 MySQL 서버에서는 최소 `REPEATABLE READ` 격리 수준 이상을 사용해야 한다. 이 격리 수준에서는 `READ COMMITTED` 격리 수준에서 발생하는 "NON-REPEATABLE READ" 부정합이 발생하지 않는다. InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 언두(Undo) 공간에 백업해두고 실제 레코드 값을 변경한다.  `REPEATABLE READ`는 이 MVCC를 위 해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장한다. 사실 `READ COMMITTED`도 MVCC를 이용해 COMMIT되기 전의 데이터를 보여준다. `REPEATABLE READ`와 `READ COMMITTED`의 차이는 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가야 하느냐에 있다. 

### 트랜잭션 번호(tid)
모든 InnoDB의 트랜잭션은 고유한 **트랜잭션 번호**(순차적으로 증가하는 값)를 가지며, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함돼 있다. 그리고 언두 영역의 백업된 데이터는 InnoDB 스토리지 엔진이 불필요하다고 판단하는 시점에 **주기적으로 삭제**한다. `REPEATABLE READ` 격리 수준에서는 MVCC를 보장하기 위해 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번 호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할 수가 없다. 그렇다고 가장 오래된 트랜잭션 번호 이전의 트랜잭션에 의해 변경된 모든 언두 데이터가 필요한 것은 아니다. 더 정확하게는 특정 트랜잭션 번호의 구간 내에서 백업된 언두 데이터가 보존돼야 한다. 

![](https://velog.velcdn.com/images/chocochip/post/baa894af-9ec6-464d-9de3-894bd63073a7/image.jpeg)


1. employees 테이블은 번호가 6인 트랜잭션에 의해 INSERT됐다고 가정한다.
2. 사용자 A의 트랜잭션 번호는 12였으며 사용자 B의 트랜잭션의 번호는 10이었다.
3. 사용자 A는 사원의 이름을 "Toto"로 변경하고 커밋을 수행했다. 
4. A 트랜잭션이 변경을 수행하고 커밋을 했지만, 사용자 B가 `emp_no=500000`인 사원을 A 트랜잭션의 변경 전후 각각 한 번씩 SELECT 했는데 결과는 항상 "Lara"라는 값을 가져온다. 

사용자 B가 BEGIN 명령으로 트랜잭션을 시작하면서 10 번이라는 트랜잭션 번호를 부여받았는데, 그때부터 사용자 B의 10번 트랜잭션 안에서 실행되는 모든 SELECT 쿼리는 트랜잭션 번호가 10(자신의 트랜잭션 번호)보다 작은 트랜잭션 번호에서 변경한 것만 보게 된다. 언두 영역에 백업된 데이터가 하나만 있는 것으로 표현했지만 사실 하나의 레코드에 대해 백업이 하나 이상 얼마든지 존재할 수 있다. 한 사용자가 BEGIN으로 트랜잭션을 시작하고 장시간 트랜잭션을 종료하지 않으면 언두 영역이 백업된 데이터로 무한정 커질 수도 있다. 이렇게 언두에 백업 레코드가 많아지면 MySQL 서버의 처리 성능이 떨어질 수 있다. 

### Phantom Read
REPEATABLE READ 격리 수준에서도 다음과 같은 부정합이 발생할 수 있다.


![](https://velog.velcdn.com/images/chocochip/post/7a2f9d4b-cb40-450f-8a4e-65fe37076c4a/image.jpeg)

1. 사용자 B는 BEGIN 명령으로 트랜잭션을 시작한 후 SELECT를 수행한다. 
2. 사용자 B가 실행하는 두 번의 SELECT FOR UPDATE 쿼리 결과는 서로 다르다. 
3. SELECT ... FOR UPDATE 쿼리는 SELECT하는 레코드에 쓰기 잠금을 걸어야 하는데, 언두 레코드에는 잠금을 걸 수 없다. 
4. SELECT ... FOR UPDATE나 SELECT LOCK IN SHARE MODE로 조회되는 레코드는 언두 영역의 변경 전 데이터를 가져오는 것이 아니라 현재 레코드의 값을 가져오게 된다.

이렇게 다른 트랜 잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상을 PHANTOM READ(또는 PHANTOM ROW)라고 한다. 

## SERIALIZABLE
가장 단순한 격리 수준이면서 동시에 가장 엄격한 격리 수준이다. 그만큼 동시 처리 성능도 다른 트랜잭션 격리 수준보다 떨어진다. InnoDB 테이블에서 기본적으로 순수한 SELECT 작업(INSERT, SELECT, ... 또는 CREATE TABLE AS SELECT ... 가 아닌)은 아무런 레코드 잠금도 설정하지 않고 실행된다. InnoDB 매뉴얼에서 자주 나타나는 "Non-locking consistent read(잠금이 필요 없는 일관된 읽기)" 라는 말이 이를 의미하는 것이다. 하지만 트랜잭션의 격리 수준이 `SERIALIZABLE`로 설정되면 **읽기 작업도 공유 잠금(읽기 잠금)을 획득**해야만 하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다. 즉, 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없는 것이다.

## MySQL에서의 PHANTOM READ
`SERIALIZABLE` 격리 수준에서는 일반적인 DBMS에서 일어나는 "PHANTOM READ"라는 문제가 발생하지 않는다. 하지만 InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 REPEATABLE READ 격리 수준에서도 이미 "PHANTOM READ"가 발생하지 않기 때문에 굳이 SERIALIZABLE을 사용할 필요성은 없어 보인다. 엄밀하게는 "SELECT FOR UPDATE" 또는 "SELECT FOR SHARE" 쿼리의 경우 REPEATABLE READ 격리 수준에서 PHANTOM READ 현상이 발생할 수 있다. 하지만 레코드의 변경 이력(언두 레코드)에 잠금을 걸 수는 없기 때문에, 이러한 잠금을 동반한 SELECT 쿼리는 예외적인 상황으로 볼 수 있다. 