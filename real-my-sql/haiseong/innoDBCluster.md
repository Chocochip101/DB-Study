
# InnoDB 클러스터
- 복제를 한다고 해도 고가용성이 실현되는건 아님
    - 소스 서버에 장애가 발생했을 때 기존 소스 서버를 대체하는 새로운 소스 서버로 전환되지 않음
    - MySQL 서버가 자체적으로 페일오버를 처리하는 기능을 제공하지 않음
    - 레플리카 서버에 설정된 읽기 모드를 해제하고 스플릿 브레인을 방지하기 위해 장애가 발생한 소스 서버에서 데이터 변경을 못하게 해야함
    - 애플리케이션 서버는 새로운 소스 서버를 바라보도록 커넥션 설정을 변경해야함
- 자동화의 필요성
    - MySQL 서버 장애를 감지해 자동으로 페일오버를 처리하는 서드파티 솔루션 (MMM, MHA, Orchestrator 등)
    - 5.7.17 부터 빌트인 HA(High-Availability) 시스템인 InnoDB 클러스터 도입


## 17.1 InnoDB 클러스터 아키텍쳐
InnoDB 클러스터 : 고가용성 실현을 위한 여러 구성 요소들의 집합체

### 그룹복제
- 소스 서버의 데이터를 레플리카 서버로 동기화
- 복제에 참여하는 MySQL 서버들에 대한 자동화된 멤버십 관리 역할 담당
- InnoDB 클러스터에서 데이터가 저장되는 MySQL 서버들은 그룹 복제 형태로 복제가 구성
    - 두가지 역할중 하나로 동작
        - 프라이머리 : 읽기/쓰기가 모두 가능
            - 기존 소스 서버
            - 한대 이상이 존재 가능
        - 세컨더리 : 읽기만 가능
            - 기존 : 레플리카 서버
- 그룹 복제에서는 InnoDB 스토리지 엔진만 사용 가능하다.
- 최소 3대 이상으로 구성해야 한 대에 장애가 발생해도 복제 그룹이 정상적으로 동작함

### MySQL 라우터
- 애플리케이션 서버와 MySQL 서버 사이에서 동작하는 미들웨어 프로그램
- 애플리케이션이 실행한 쿼리를 적절한 MySQL 서버로 전달하는 프록시 역할을 한다.
- InnoDB 클러스터를 사용하는 환경에서 클라이언트는 MySQL 서버로 직접 접근해서 쿼리를 실행하지 않고 MySQL 라우터에 연결해서 쿼리를 실행
- MySQL 라우터는 InnoDB 클러스터로 구성된 MySQL 서버들에대한 메타데이터 정보를 지님
    - 이를 바탕으로 클라이언트로부터 실행된 쿼리를 클러스터 내 적절한 MySQL 서버로 전달한다.
    - 클라이언트는 현재 InnoDB 클러스터가 어떤 서버로 구성되어 있는지 알고 있을 필요가 없음
    - 커넥션 정보에는 MySQL 라우터 서버만 설정해두면 됨

### MySQL 셸
- 기존 MySQL 클라이언트보다 확장된 기능을 가진 새로운 클라이언트 프로그램
- 기본적인 SQL문 실행뿐만 아니라 자바스크립트, 파이썬 기반의 스크립트 작성 기능
- MySQL 서버에 대해 클러스터 구성드으이 어드민 작업을 할 수 있게 하는 API 제공
- 손쉽게 InnoDB클러스터를 생성하고 관리할 수 있도록 API 제공
    - InnoDB 클러스터의 상태를 확인하거나 MySQL 서버의 설정을 변경하는 것과 같은 여러가지 기능을 제공함
- MySQL 셸에서 InnoDB 클러스턱와 관련된 작업들을 진행할때는 MySQL 서버에 직접 연결해야함
- 단순히 쿼리를 실행하는 경우에는 MySQL 라우터로 연결해서 처리할 수도 있다.

![image](src/img/이노디비%20클러스터%20아키텍쳐.jpeg)

- InnoDB 클러스터에서는 MySQL 서버에 장애가 발생하면 그룹 복제가 이를 먼저 자동으로 감지함
- 해당 MySQL 서버를 복제 그룹에서 제외시킴
- MySQL 라우터는 이러한 복제 토폴로지 변경을 인지하고 자신이 가진 메타 데이터를 갱신
    - 클라이언트로부터 실행된 쿼리가 현재 복제 크룹에서 정상적으로 동작하는 MySQL 서버로만 전송

## 17.2 그룹 복재(Group Replication)
- 기존 MySQL 복제 프레임워크 기반으로 구현
    - 내부적으로 Row 포맷의 바이너리 로그, 릴레이 로그, GTID를 사용
- 기존 복제의 경우 일반적으로 소스-레플리카 형태로 단방향으로반 복제
- 그룹 복제에서는 복제에 참여하는 MySQL 서버들이 하나의 복제 그룹으로 묶인 클러스터 형태를 가짐
    - 그룹 내 서버들은 서로 통신하면서 양방향으로도 복제를 처리
    - 하나의 복제 그룹 내에서 쓰기클 서리하는 서버가 여러 대 손재 할수있는것이다.
        - 프라이머리 : 쓰기를 처리하는 서버
        - 세컨더리 : 읽기 선용으로 동작하는 서버
        - 그룹 멤버 : 그룹 복제에 참여하는 MySQL 서버들
- 그룹 복제는 반동기 방식이라 할 수 있지만 기존 반동기 방식과 동일하지 않다.
    - 한 서버에서 트랜젝션이 커밋될 준비가 되면 트랜잭션 정보를 그룹의 다른 멤버들에 전송
    - 과반수 이상의 멤버로부터 웅답을 전달받으면 그때 해당 트랜잭션을 인증(Certify)하고 커밋 처리를 완료
    - 과반수 이상의 멤버로부터 옹답을 받지 못하면 해당 트랜잭션은 그룹에 적용되지 않음
        - 트랜잭션이 최초 발생한 서버에서 커밋올 처리할 때 그룹의 다른 멤버들이 해당 트랜잭션을 실제로 적용했는지까지 확인하지 않음
    - 그룹 복제에서는 그룹 내 멤버들의 응답에 따라 전체 복제 그룹에서 해당 트랜잭션의 적용 여부가 결정
        - 기존 복제의 반동기 방식의 트랜잭션은 소스 서버에서 일방적으로 적용됨
            - 소스 서버가 레플리카 서버로부터 옹답을 못 받았다고 해서 트랜잭션 이 소스 서버에서 적용되지 않는 것은 아니므로
        - 합의(Consensus) : 그룹 복제에서 이처럼 트랜잭션 커밋올 처리할 때 그룹의 다른 멤버들에 대한 응답을 확인하는 과정
            - 이는 그룹 멤버들로부터 이 트랜잭션을 복제 그룹에 적용하는 것에 대한 동의를 구함.
            - 데이터를 변경하는 트랜잭션에 대해 서만 이 같은 합의 과정이 필요
            - 데이터를 읽기만 히는 트랜잭션에 대해서는 그룹 멤버 간의 합의 과정이 필요치 않음
- 그룹 복제에서 자동화된 기능
    - 그룹 멤버 관리
    - 그룹 단위의 정렬된 트랜잭션 적용 및 트랜잭션 충돌 감지
    - 자동 페일오버
    - 지동 분산 복구

### 그룹 복제 아키텍처
- 그룹 복제는 별도 플러그인으로 구현
    - 그룹 복제를 사용하기 위해서는 MySQL 서버에 그룹 복제 플러그인이 설치돼 있어야 한다.
    - MySQL 서버들은 그룹 복제 플러그인을 통해 서로 간에 지속적으로 통신하며 복제 동기화를 처리
    - 그룹 복제 플러그인은 group_replication_applier라는 복제 채널을 생성.
        - 이 채널을 통해 그룹에서 실행된 모든 트랜잭션을 전달받아 적용
    - MySQL 서버가 그룹에 새로 가입한 경우
        - 그룹 복제 분산 복구 작업 : 이미 그룹에 참여하고 있는 다른 MySQL서버들과 같이 그룹의 최신 데이터를 가지도록 하는 작업
        - 추가로 group_replication_recovery라는 복제 채널을 생성해서 분산 복구 작업을 진행
- 플러그인 API 집합 : 플러그인의 최상위 계층, 그룹 복제 플러그인이 MySQL 서버와 상호작용하기 위해 구현된 인터페이스인
    - API를 통해 MySQL 서버에서 그룹 복제 플러그인으로 혹은 그 반대 방향으로 요청이 전달
        - MySQL 서버 -> 그룹 복제 플러그인 : MySQL 서버의 시작 또는 복구, 트랜잭션 커밋 둥의 이벤트
        - 그룹 복제 폴러그인 -> MySQL 서버 : 처리 중인 트랜잭션에 대한 커밋 또는 중단, 릴레이 로그 기록을 위한 요청
- 복제 플러그인 계층 : 그룹 복제의 기능들이 실질적으로 구현돼 있는 계층
    - 여러 가지 모듈들로 나눠짐
    - API를 통해 들어온 요청들은 각각 적절한 모듈로 전달
        - 다른 MySQL 서버에서 실행된 원격 트랜잭션들이 처리
        - 트랜잭션들에 대한 충돌 감지 및 그룹 내 전파 동이 수행
        - 그룹 복제의 분산 복구 작업도 이 계층에서 처리된다.
- 그룹 통신 시스템 API와 그룹 통신 엔진
    - 그룹 통신 시스템 API를 통해 그룹 통신 엔진( = extended COMmunication = XCom)과 상호작용
        - 그룹 복제에 참여 중인 다른 MySQL 서버들과의 통신 처리를 담당
        - 그룹 복제의 핵심 구성 요소
    - 그룹 통신 엔진은 그룹 복제를 설정할 때 지정된 별도의 포트(일반적으로 33061)를 통해 통신을 수행
    - 트랜잭션이 그룹 복제 멤버들에 동일한 순서로 전달될 수 있도록 보장
    - 그룹 복제 토폴로지의 변경과 그룹 멤버의 장애동을 감지
    - 트랜잭션 적용을 위한 그룹 멤버 간의 합의 처리 담당
        - 분산 시스템에서 합의 처리를 위해 대표적으로 Paxos와 Raft 알고리즘 사용
            - 데이터 변경이 발생하는 서버가 여러 대 존재 : Paxos 
                - 그룹 복제에서는 그룹 멤버들이 모두 쓰기를 처리하므로 Paxos 계열의 Mencius 알고리즘을 기반
            - 데이터 변경이 한 대 : Raft
- 그룹의 과반수에 해당하는 서버가 정상적으로 동작하고 있어야함
    - 복제를 처리할 때 그룹 멤버들 간에 합의 절차가 수행되므로 
    - 하나의 서버에 장애가 발생하더라도 그룹 복제가 전반적으로 문제없이 처리되려면 적어도 세 대의 서버가 그룹에 존재해야함.
    - n = 2f + 1
        - 허용 가능한 장애 서버 수(f)
        - 전체 서버 수(n)

### 그룹 복제 모드
- group_replication_single_primary_mode 시스템 변수
    - 불리언 타입 (디폴트 : ON)
    - 그룹 복제에 참여하는 모든 서버들이 동일한 모드 값으로 설정되어야함
    - 8.0.13 이전에는 중단 후 그룹의 모든 맴버들에서 변경 가능했음
    - 8.0.13 이후에는 실행중에도 변경 가능 (UDF로 쉽게 변경 가능)
#### 싱글 프라이머리 모드 (ON)
- 그룹 내에서 쓰기를 처리할 수 있는 프라이머리 서버가 한 대만 존재
- 그룹 복제 구축을 진행한 MySQL 서버가 프라이머리로 지정 
- 다른 서버들은 그룹에 참여하는 시점에 자동으로 super_read_only 시스템 변수가 ON으로 설정되어 읽기 전용 모드로 동작
- 그룹 내 프라이머리 서버가 변경될 수 있는 경우
    - 자발적으로 혹은 예기치않게 현재 프라이머리 서버가 그룹을 탈퇴하는 경우
        - 우선순위에 따라 지정된다.
            1. 가장 낮은 MySQL 버전을 실행중인 서버
            2. 각 멤버의 가중치 값 (group_replication_member_wigeht 시스템 변수)
            3. UUID 값의 사전식 순서
    - group_replication_set_as_primary() UDF를 사용해 그룹의 특정 멤버를 새로운 프라이머리로 지정한 경우 (8.0.13 이상의 버전 이상)
- performance_schema의 replication_group_members 테이볼에서 MEMBER_ROLE 칼럼값을 통해 어떤 서버가 프라이머리인지 알 수 있음
- group_replication_switch_to_multi_primary_mode() UDP를 통해 멀티 프라이머리 모드로 전환되 는 경우
    - 그룹에서 사용 중인 가장 낮은 MySQL 버전보다 높은 MySQL 버전을 사용 중인 멤버들은 읽기 전용 모드로 설정 
    - 가장 낮은 버전을 사용하는 것으로 확인되는 멤버들은 읽기-쓰기 모드로 설정

#### 멀티 프라 이머리 모드 (OFF)
- 그룹 복제에서 그룹 멤버들이 전부 프라이머리로 동작
    - 클라이언트는 그룹의 어떤 MySQL 서버로든 쓰기와 읽기 요청을 보낼 수 있음
- 모든 맴버에서의 쓰기가 그룹의 다른 멤버들로 전파되어 다시 처리됨
- 그룹 멤버 간의 MySQL 버전 호환성이 중요
- 모든 멤버가 동일한 MySQL 버전으로 실행되는 것이 좋음
    - 그룹 복제에 참여할 때 버전 호환성을 확인하는 기능이 구현돼 있음
    - 정의한 호환 가농 기준에 따라 그룹 참여 가능 여부와 읽기 전용 모드 유지 여부를 결정
    - 새로운 멤버가 그룹에 존재하는 가장 낮은 MySQL 버전보다
        - 낮은 경우 : 참여 불가능
        - 동일한 경우 : 정상적으로 참여
        - 높은경우 : 읽기 전용 모드 유지
- 그룹에서 한 멤버가 탈퇴하면 현재 그룹 내에서 가장 낮은 MySQL 버전을 사용하는 멤버를 자동으로 읽기-쓰기 모드로 전환


### 그룹 멤버 관리(Group Membership)
- 그룹 복제에서는 현재 어떤 서버들이 그룹에 참여하고 있는지 그룹 멤버들에 대한 목록과 상태 정보를
내부적으로 관리
- 사용자는 performance_schema의 replication_group_members테이블을 통해 그룹 멤버 목록을 확인
    - UUID 값, MySQL 버전, 각 그룹 멤버들의 역할을 확인할 수 있음
    - 상태도 확인 가능
        - ONLINE : 정상적으로 동작
        - RECOVERING : 그룹 복제에 참여하기 위해 기존 그룹 멤버로부터 데이터를 전달받는 복구 작업중
        - OFFLINE : MySQL 서버에 그룹 복제 플러그인이 로딩돼 있으나 아직 그룹 복제에 참여하지 않음
        - ERROR : 그룹 복제에 속해 있으나 현재 정상적으로 복제가 동작하지 않음
        - UNREACHABLE : 통신 불가능
- 그룹에 멤버 가입/탈퇴시 이를 감지해서 해당 테이블 데이터를 자동으로 갱신한다.
- 그룹 복제가 관리하는 멤버 목록과 상태 정보를 '뷰(View)'라고도 함
    - 그룹 멤버가 변경될 때마다 새로운 뷰 ID 값이 생성 -> 뷰 ID 는 각각의 변경된 뷰를 고유하게 식별
    - View ID = [Prefix value]:[Sequence value]
        - Prefix value : 접두사 부분으로 그룹 복제가 초기화 생성 (타임스탬프를 기반)
            - 생성된 그룹이 유지되는 동안, 즉 그룹에 적어도 하 나의 멤버가 존재하는 동안은 값이 변경되지 않음
        - Sequence value : 단조 증가하는 정수값
    - 그룹에 새로운 멤버가 추가되어 뷰가 변경되는 경우에만 기록
    - performance_schema의 replication_group_member_status 로 VIEW_ID 확인

### 그룹 복제에서의 트랜잭션 처리

#### 합의(Consensus)
- 그룹 내 일관된 트랜잭션 적용을 위해 그룹 멤버들에게 트랜잭션 적용을 제안하고 승낙을 받는 과정
    - 그룹 멤버 간의 통신 결과를 바탕으로 처리된다.
- 클라이언트가 한 그룹 멤버에서 트랜잭션을 실행하고 커밋 요청을 보내면 트랜잭션 데이터를 그룹의 다른 멤버들로 전파함
    - 그룹 통신 엔진(XCom)을 통해 전파
    - 트랜잭션 데이터에 다음이 포함된
        - 트랜잭션에서 변경한 데이터에 대한 WriteSet
        - 트랜잭션이 커밋될 당시의 gtid_executed 스냅숏 정보
        - 트랜잭션의 이벤트 로그 데이터
    - 전파 대상 멤버는 현재 그룹 내에서 정상적인 상태로 동작 중인 멤버들임
- Paxos 기반의 프로토콜을 바탕으로 그룹 멤버들 간의 합의를 수행
    - 과반수 이상에 해당히는 멤버들로부터 응답 메시지(ACK)를 전달받으면 해당 멤버는 그 다음 프로세스를 진행
    - 만약 과반수 이상의 멤버들로부터 응답을 받지 못한 경우 그룹 복제에서 트랜잭션은 적용되지 않으며 클라이언트에는 에러가 반환

#### 인증(Certification)
- 다수의 그룹 멤버들에서 실행된 트랜잭션들은 합의 단계를 거친 후 글로벌하게 정렬
    - 각 멤버들에 서 모두 동일한 순서로 인증
- 트랜잭션 WriteSet 데이터와 로컬에서 내부적으로 관리하고 있는 WriteSet 히스토리 데아터를 바탕으로 트랜잭션 충돌 여부 확인
    - 트랜잭션 충돌은 멀티 프라이머리 모드에서만 발생
    - 해당 트랜잭션이 이미 인증 단계를 거친 선행 트랜잭션과 동시점에 동일한 데이터를 변경한 것인지 를 검사
    - 트랜잭션 충돌이 감지된 트랜잭션은 롤백
- 트랜잭션 충돌이 지주 발생할 수 있는 환경에서는 싱글 프라이머리 모드가 더 나음

![image](src/img/그룹복제에서의%20트랜잭션%20처리%20과정.png)

#### 트랜잭션 일관성 수준
- 그룹 복제에서 각 멤버들은 모두 동일한 트랜잭션을 적용함
- 하지만 실제 적용 시점까지 완전히 일치하는 것은 아님
    - 한 멤버에서 쓰기를 수행한 후 바로 다른 멤버에서 해당 데이터를 읽었을 때 최신 변경 사항이 반영되지 않았을 수 있음
    - 프라이머리 장애로 인해 페일오버가 발생하는 경우 새로 선출된 프라이머리가 아직 이전 프라이머리에서 발생했던 트랜잭션들을 적용하고 있는 상황에서 클라이언트가 새로운 프라이머리로 연결해서 트랜잭션을 실행하는 경우 해당 트랜잭션에서는 오래된 데이터를 읽거나 쓸 수 있음 
- 일반적으로 그룹 복제가 정상적으로 잘 동작하고 있는 상태에서는 멤버 간 데이터 동기회는 빠르게 처리되므로 이 같은 상황은 거의 발생하지 않음. 
    - 하지만 동기화가 잘 처리되고 있다고 하더라도 일시적으로 짧은 순간에 발생할 수는 있음
- 8.0.14 버전부터 그룹 복제에서 트랜잭션의 일관성 수준을 설정할 수 있는 기능이 도입
    - 사용자가 필요에 따라 원하는 수준의 일관성을 선택해서 사용
    - group_replication_consistency 시스템 변수를 통해 그룹 복제에서의 트랜잭션 일관성 수준을 설정 (글로벌 또는 세션 모두 가능)
    - 설정된 일관성 수준은 읽기 전용 트랜잭션과 읽기­ 쓰기 트랜잭션에 다른 영향을 미치며, 경우에 따라 다른 멤버에서 실행 중인 트랜잭션에도 영BEFORE_ON_PRIMARY_FAILOVER향을 줄 수 있음

**EVENTUAL**
- 기본설정값
- 즉, 이름 그대로 최종적으로는 그룹 멤버들이 일관된 데이터를 가지게됨
- 읽기 전용 및 읽기-쓰기 트랜잭션이 별도의 제약 없이 바로 실행 가능
- 트랜잭션이 직접 실행된 멤버가 아닌 다른 그룹 멤버들에서는 일시적으로 변경 직전 상태의 데아터가 읽혀질 수 있음
- 프라이머리 페일오버가 발생한 경우 새로운 프라이머리가 이전 프라이머리의 트랜잭션을 모두 적용하기 전에 새로운 프라이머리에서 트랜잭션이 실행 가능해서 읽기 트랜잭션의 경우 오래된 데이터를 읽을 수 있음
- 읽기-쓰기 트 랜잭션의 경우 커밋 시 이전 프라이머리의 트랜잭션과의 충돌로 인해 롤백될 수 있음

![](src/img/EVENTUAL일관성%20수준에서의%20트랜잭션%20처리.png)

**BEFORE_ON_PRIMARY_FAILOVER**
- 싱글 프라이머리 모드로 설정된 그룹 복제에서 프라이머리 페일오버가 발생해서 신규 프라이머리가 선출됐을 때만 트랜잭션에 영향을 미친다.
- 선출된 신규 프라이머리가 BEFORE_ON_PRIM_FAARIYLOVER 일관성 수준으로 설정돼 있고 아직 이전 프라이머리의 트랜잭션올 적용하고 있는 경우 새로운 프라이머리로 유입된 읽기 전용 및 읽기-쓰기 트랜잭션은 새로운 프라이머리에서 이전 프라이머리의 트랜잭션이 모두 적용될 때까지 처리되지 못하고 대기하게 된다. 
    - 갭이 큰 경우 트랜잭션들의 대기 시간이 길어져 클라이언트에서 옹답 지연을 겪을 수 있으므로 클라이언트 단에서는 이 같은 지연을 대비히는 코드가 구현돼 있는 것이 좋음 (timeout 설정)
- 신규 프라이머리로 유입된 읽기 전용 및 읽기-쓰기 트랜잭션들은 오래된 데이터가 아닌 최신 데이터를 바탕으로 동작
- 신규 프라이머리로 유입된 읽기一쓰기 트랜잭션은 적용 대기 중인 이전 프라이머리의 트랜잭션과의 충돌로 인한 롤백이 발생하지 않게 된다.
- 신규 프라이머리가 이전 프라이머리의 트랜잭션들을 적용하고 있을 때 새로 유입된 모든 읽기-쓰기 트랜잭션들은 처리가 지연되지만 읽기 전용 트랜잭션에서는 모든종류의 읽기 쿼리들이 전부 지연처리되는것은 아님
    - SHOW문, SET문, DO문, EMPTY문, USE문, performance_schem 및 sys 데이터베이스, information_schem 데이터베이스의 PROCESSLIST에 대한 SELECT 문 사용, 테이블 또는 사용자 정의 함수를 사용하지 않는 SELECT문, STOPGROUP_REPLICATION문, SHUTDOWN문, RESETPERSIST문
- 프리이머리 페일오버가 발생하지 않는 상황에서는 프라이 머리로 유입된 트랜잭션들에 아무런 영향을 미치지 않음

![](src/img/BEFORE_ON_PRIMARY_FAILOVER일관성%20수준에서의%20트랜잭션%20처리.png)

**BEFORE** (자신보다 앞선 트랜잭션들을 기다리고 자신이 실행)
- 읽기 전용 및 읽기-쓰기 트랜잭션은 그룹 멤버에서의 모든 선행 트랜잭션 완료될 때까지 대기 후 처리됨
- 읽기 전용 및 읽기-쓰기 트랜잭션은 항상 최신 데이터를 읽으며, 트랜잭션의 처리 시간은 선행 트랜잭션의 처리 시간에 영향을 받음
    - 선행 트랜잭션이 최종적으로 적용되기까지의 시간이 길면 길수록 그만큼 처리가 지연됨
- MySQL의 wait_timeout 시스템 변수에 설정된 시간까지 대기 
- 트랜잭션에서 반드시 최신 데이터를 읽어야 하며, DB에서 읽기 요청은 적고 쓰기 요청이 많은 경우에 사용히는 것이 좋음

![](src/img/BEFORE일관성%20수준에서의%20트랜잭션%20처리.png)

**AFTER** (자신보다 늦은 트랜잭션들을 대기하라고함)
- 트랜잭션이 적용되면 해당 시점에 그룹 멤버들이 모두 동기화된 데이터를 갖게 한다. 
- 읽기-쓰기 트랜잭션은 다른 모든 멤버들에서도 해당 트랜잭션이 커밋될 준비가 됐을 때까지 대기한 후 최종적으로 처리됨
- 읽기 전용 트랜잭션은 데이터 변경을 발생시 키지 않으므로 별도의 제약 없이 바로 처리됨
- AFTER일관성 수준은 다른 멤버에서 동시점에 실행되는 트랜잭션에 영향을 줌
    - 트랜잭션이 실행되는 동안 다른 멤버에서 새로운 트랜잭션이 실행되면 AFTER 일관성 수준의 트랜잭션이 완전히 커밋될 때까지 대기
- MySQL의 wait_timeout 시스템 변수에 설정된 시간까지 대기 
- DB에서 쓰기 요청보다 읽기 요청이 많고, 분산된 최신 읽기를 수행하고자 할 때 사용하는 것이 좋다.

![](src/img/AFTER일관성%20수준에서의%20트랜잭션%20처리.png)

**BEFORE_AND_AFTER**
- BEFORE와 AFTER가 결합된 형태
- 읽기-쓰기 트랜잭션은 모든 선행 트랜잭션이 적용될 때까지 기다린 후 실행
- 트랜잭션이 다른 모든 멤버들에서도 커밋이 준비되어 응답울 보내면 그때 최종적으로 커밋
- 최신 데이터를 읽을 수 있음.
- 읽기-쓰기 트랜잭션의 경우 커밋되면 이후 모든 후속 트랜잭션들은 그룹의 어떤 멤버에서든지 해당 트랜잭션의 변경 사항을 포함하는 최신 데이터를 읽게 된다. 
- 다른 멤버들에서 실행되는 트랜잭션들에 영향을 미친다.
- BEFORE_ON_PRIMARY_FAILOVER의 일관성 보장을 포함하며,
- wait_timeout 시스템 변수에 설정된 시간까지 대기

![](src/img/BEFORE_AND_AFTER일관성%20수준에서의%20트랜잭션%20처리.png)

#### 흐률 제어(Flow Control)
- 그룹 복제에서 일부 멤버가 다른 멤버들보다 하드웨어 스펙이 더 낮거나 혹은 네트워크 대역폭이 작은 경우, 또는 부하를 더 많이 받고 있는 경우
    - 해당 멤버는 다른 멤버들보다 트랜잭션 적용이 지연될 수 있음 
        - 이렇게 지연된 멤버에서 트랜잭션이 실행되면 해당 트랜잭션은 최신 데이터가 아닌 오래된 데이터를 읽을 수 있으며, 아직 적용되지 않은 트랜잭션과 충돌할 위험이 있음
    - 트랜잭션 일관성 수준을 조정해서 이 같은 문제를 방지 할 수는 있지만 근본적인 원인이 해결되는것은 아님

- 흐름 제어 (Flow Control) : 그룹 멤버 간의 트랜잭션 적용 불균형으로 인해 발생하는 문제를 방지하기 위해 그룹 멤버들의 쓰기 처리량을 조절하는 메커니즘
    - 흐름 제어를 통해 멤버 간 트랜잭션 갭을 적게 유지해서 멤버들 의 데이터가 최대한 동기화된 상태로 유지될 수 있게함
    - 변화에도 빠르게 적응해서 각 멤버들의 쓰기 처리량이 균동할 수 있게함
    - 필요 이상으로 처리량을 줄이지 않음으로써 서버의 자원이 불필요하게 유휴 상태에 놓여 있지 않게함
- group_replication_flow_control_mode : 멤버에서 흐름 제어 기능의 사용 여부 설정
    - QUOTA : 해당 변수의 기본값, 죽 흐름 제어의 기본 모드로 그룹에서 쓰기를 처리히는 멤버가 정해진 할당량만큼만 쓰기를 처리하도록 제어하는 방식
        1. 모든 그룹 멤버들의 쓰기 처리랑 및 처리 대기 중인 트랜잭션에 대한 통계를 수집해서 멤버의 처리량을 조절할 필요가 있는지 확인
        2. 처리랑 조절이 필요한 경우 수집된 통계 데이터를 바탕으로 멤버에게 할당할 쓰기 처리량을 계산한 후 멤버가 계산된 최대 쓰기 처리량을 넘어 쓰기를 처리하지 않도록 멤버의 쓰기 처리를 제한한다.
    - DISABLED : 흐름제어 동작 안함
- 흐름 제어는 그룹 전반에 걸쳐 동기화된 형태로 수행되는 것이 아니라 각 멤버에서 개별적으로 수행
    - 흐름 제어에서는 멤버에서 다음과 같은 통계 정보들을 수집하며, 이렇게 수집된 데이터들은 그룹의 다른 멤버들에게도 공유된다.
        - 인증(Certification)큐 크기 
        - 적용(Application)큐 크기 
        - 안증된 총 트랜잭션 수
        - 적용된 원격 트랜잭션 수
        - 로컬 트랜잭션 수
- 통계 정보 데이터는 group_replication_flow_cotnrol_period 시스템 변수에 지정된 시간(초 단위)마다 수집 및 공유됨
    - 기본적으로 흐름 제어는 매초마다 동작
    - 멤버 로컬에서 수집한 통계 정보와 다른 멤버들로부터 전달받은 통계 정보를 바탕으로 멤버에서 쓰기 처리량 조절이 필요한 상황인지를 판단하고 멤버에게 할당할 쓰기 처리량을 계산함
    - 관리의 편의를 위해 모든 맴버에서 동일하게 설정하는게 좋음
- 흐름 제어에서는 수집된 통계 정보 중 인중 큐 크기와 적용 큐 크기를 바탕으로 멤버의 처리량을 조절 할 것인지를 판단함
    - 로컬 멤버를 포함해서 그룹의 모든 멤버들에서 트랜잭션 처리 과정 중 트랜 잭션의 충돌을 감지히는 인중 단계와 실제로 트랜잭션을 반영하는 적용 단계에서 얼마나 많은 트랜잭션이 대기하고 있는지를 확인
    - 이때 흐름 제어가 비활성화돼 있는 멤버의 통계 정보는 무시 
    - 흐름 제어가 처리량 조 절을 시작하는 임겟값 설정
        - group_replication_flow_cotnrol_certifier_threshold : 인증 큐에서 대기 중인 트랜잭션 수가 해당 변수에 지정된 수를 초과하면 흐름 제어가 작동
        - group_replication_flow_cotnrol_applier_threshold : 어플라이어 큐에서 대기 중인 트랜잭션 수가 해당 변수에 지정된 수를 초과하면 흐름 제어가 작동
- 흐름 제어에서는 멤버의 쓰기 처리량을 조절할 필요가 있다고 판단되면, 통계 정보를 바탕으로 그룹에 서 트랜잭션 적용이 가장 뒤처진 멤버가 처리할 수 있는 수준으로 멤버의 쓰기 처리량을 계산함 (자세한 설정은 p582~)

#### 그룹 복제의 자동 장애 감지 및 대응
- 그룹 복제에서는 멤버 간에 주기적으로 통신 메시지를 주고받으며 서로의 상태를 확인함
    - 멤버로부터 5초 내로 메시지를 받지 못하면 해당 멤버에 문제가 생긴 것으로 의심하기 시작함
    - 그룹 복제에 서는 장애가 의심되는 멤버에 대해 과반수의 멤버가 동의하면 해당 멤버를 그룹에서 추방
    - group_replication_member_expel_timeout 시스템 변수 만큼 기다림 (5초내로 메시지를 못받으면 추방하는 이유)
        - 네트워크가 느린환경에서는 기본값 보다는 늘리는게 좋음
    - 멤버가 추방되고 나서 다른 그룹 멤버들과 통신을 재개할 수 있는 경우 해당 멤버는 자신이 그룹에서 추방됐음을 알게 됨
        - 멤버가 추방되면 그룹뷰가 변경되므로 (새로운 뷰 ID 값을 가짐)
        - 연결 되었을때 뷰 ID가 다른걸 보고 자신이 추방되었다는것을 알게됨
        - 자동으로 재가입 시도를 함
    - 그룹에서 추방된 멤버는 다른 그룹 멤버들과 다시 통신이 되지 않으면 자신이 추방됐음을 알지 못한다.
        - group_replication_unreachable_mjaority_timeout 을 설정해 스스로 추방되게 설정 가능
- 타의 혹은 자의로 그룹에서 탈퇴한 상태 에서 자동 재가입에 실패하거나 혹은 재가입을 이예 시도하지 않게 설정된 경우 멤버는 최종적으로 group_replication_exit_state_action 시스템 변수에 설정된 작업을 진행
    - READ_ONLY (읽기 전용으로 만듬)
    - OFFLINE_MODE (오프라인 모드로 전환)
    - ABORT_SERVER (MySQL 서버를 종료시킴)


#### 그룹 복제의 분산 복구
- 멤버가 그룹에 새로 가입하거나 혹은 탈퇴 후 다시 가입할 때 가입 이전에 적용된 트랜잭션들을 모두 적용해야 다른 그룹 멤버들이 가진 데이터와 동일한 데이터를 가져야 정상적인 상태로 참여할 수 있다.
- 분산 복구 : 그룹 복제에서는 누락된 트랜잭션들을 다른 그룹 멤버에서 가져와 적용히는 복구 프로세스
    - 기증자(Donor) 멤버 : 분산 복구에서 가입 멤버가 복구 작업을 위해 선택한 기존 그룹 멤버     
        - 그룹에서 온라인 상태로 존재하는 모든 멤버들은 기증자 멤버가 될 수 있음

**분산 복구 방식**
1. 가입 멤버에서 group_replication_applier 복제 채널의 릴레이 로그를 확인
    - 릴레이 로그에는 기록돼 있으나 아직 실제로 적용되지 않은 트랜잭션이 존재할 수 있기 때문
2. 그룹에 온라인 상태로 존재히는 다른 그룹 멤버에 연결 해서 분산 복구 작업을 마저 진행
    - 바이너리 로그 복제 방식
        - MySQL의 기본복제 방식인 비동기 복제를 기반으로 구현
        - 기중자로 선택된 다른 그룹 멤버와 group_replication_recovery리는 별도의 복제 채널로 연결되어 해당 멤버의 바이너리 로그에서 가입한 멤버에 적용되지 않은 트랜잭션들을 복제해서 가져와 가입한 멤버에 적용
        -  트랜잭션 갭이 크지 않거나 클론 플러그인이 설치돼 있지 않은 경우
    - 원격클론(RemoteCloning)방식
        - MySQL 8.0.17 버전에서 도입된 클론 플러그인(Clone Plugin)을 사용
        - 다른 그룹 멤버의 lnnoDB 스토리지 엔진에 저장된 모든 데이터와 메타데이터를 일 관된 스냅숏으로 가져와 가입 멤버를 재구축하는 방식
        - 그룹 멤버들과 가입 멤버 모두 클론 플러그인이 설치돼 있어야함
        - 가입한 멤버와 기존 그룹 멤버간의 트랜잭션 갭이 크거나 필요한 트랜잭션들 중 일부가 기존 그룹 멤버의 바이너리 로그파일에 더 이상 존재하지 않는 경우
        - 가입한 멤버의 기존 데이터는 모두 제거 클론 작업으로 연결된 기존 그룹 멤버의 스냅숏 데이터로 대체
        - 클론 작업 동안 그룹에서 적용된 트랜잭션을 가져오기 위해 바이너리 로그 복제 방식 으로 한번 더 복구 작업을 진행
    - 적합한 복구 방식을 자동으로 선택함
    
**분산 복구 프로세스**
1. 로컬복구
    - 가입 멤버가 이전에 그룹에 가입한 적이 있는 경우 릴레이 로그에 미처 적용하지 못한 트랜잭션이 존재할 수 있어 이 트랜잭션들을 먼저 적용한 후 본격적인 복구 작업을 진행
2. 글로벌복구
    - 가입 멤버는 그룹의 기존 멤버들에서 기증자 역할을 할 멤버를 선택해서 해당 멤버로부터 데이터 또는 누락된 트랜 잭션들을 가져와 자신에게 적용
    - 이 작업을 진행하는 동안 현재 그룹에서 처리되는 트랜잭션들을 내부적으로 캐싱
3. 캐시 트랜잭션 적용
    - 글로벌 복구 단계가 완료되면 캐싱해서 보관하고 있던 트랜잭션들을 적용해 최종적으로 그룹에 참여


- 새로운 멤버 가입 시 초기 단계
    - 새 멤버가 그룹에 가입하면 그룹 뷰가 변경됨
    - 뷰 변경 로그 이벤트(View Change LogEvent)가 생성
    - 이 이벤트는 모든 멤버의 바이너리 로그에 기록됨

- 분산 복구 프로세스
    1. 로컬 복구
        - 가입 멤버는 먼저 로컬 복구를 완료함
    2. 기증자 멤버 선정
        - 로컬 복구 후, ONLINE 상태의 멤버들 중 무작위로 기증자 멤버를 선정
    3. 복구 방식 선택
        - 원격 클론 방식 또는 바이너리 로그 복제 방식 중 선택

- 복구 작업 진행
    - 원격 클론 방식
        1. 가입 멤버는 기증자 멤버의 스냅샷 데이터를 전달받음
        2. 데이터 전송 완료 후 MySQL 서버 재시작
        3. 서버 재시작 시 동작:
        - `group_replication_start_on_boot=ON` 옵션 설정 시:
            - 그룹 복제 자동 시작
            - 바이너리 로그 복제 방식의 분산 복구 진행
        - 옵션이 OFF인 경우:
            - 사용자가 수동으로 `START GROUP_REPLICATION` 명령 실행 필요

    - 바이너리 로그 복제 방식
        1. 가입 멤버는 그룹 참여 시점까지만 복구 작업 진행
        2. 복구 작업 동안 그룹에서 처리된 트랜잭션들을 캐싱
        3. 복구 프로세스:
            - 기증자 멤버에서 누락된 트랜잭션들을 가져와 적용
            - 가입 멤버의 그룹 참여 시점(뷰 변경 로그 이벤트)에 도달하면 복제 중지
            - 이후 캐싱된 트랜잭션 적용으로 전환
- 가입 맴버가 동일한 데이터를 갖게되면 맴버는 그룹 뷰에서 상태가 ONLINE으로 변경됨

**분산 복구 설정 & 분산 복구 오류 처리**
- p593 참고

### 그룹 복제 요구사항
- InnoDB스토리지 엔진 사용
    - 데이터가 저장되는 테이블은 반드시 InnoDB스토리지 엔진을 사용해야함
    - 다른 스토리지 엔진을 사용할 경우 그룹 복제에서 에러가 발생할 수 있음
        - 사용자는 다음과 같이 MySQL 설정 파일에 disabled_storage_engines 시스템 변수를 설정해서 다른 스토리지 엔진의 사용을 방지할 수 있음
- 프라이머리키 사용
- 그룹에서 복제될 모든 테이블들은 프라이머리 카를 가지고 있어야 함
    - 만약 명시적인 프라이머리 키가 없는 경우 에는 NULL값을 허용하지 않는 유니크 키가 반드시 테이블에 존재해야 함 (테이블 내의 모든 데이터에 대해 고유한 식별자)
    - 이를 바탕으로 트랜잭션 간의 충돌을 감지
- 원활한 네트워크 통신 환경
- 바이너리 로그 활성화
- ROW형태의 바이너리 로그 포맷 사용
- 바이너리 로그 체크섬 설정
    - MySQL 8.0.20 버전까지는 binlog_checksum시스템 변수의 값을 'NONE'으로 설정 (지원 x)
    - MySQL 8.0.21 부터는 사용자가 원하는 값으로 설정
- log_slave_updates 활성화
- GTID 사용
- 고유한 server_id 값 사용
- 복제 메타데이터 저장소 설정
- 트랜잭션 WriteSet 설정 
- 테이블 스페이스 암호화 설정 (모든 서버 동일하게)
- lower_case_table_names 설정 (모든 서버 동일하게)
- 멀티 스레드 복제 설정 (p597)

### 그룹 복제 제약 사항
- 갭 락
   - 트랜잭션 실행 멤버에서만 유효
   - 그룹 복제의 트랜잭션 인증 단계에서 공유되지 않음
   - 멀티 프라이머리 모드에서는 READ-COMMITTED 트랜잭션 격리 수준 권장
- 테이블 락 (Table Lock)과 네임드 락 (Named Lock)
   - 그룹 단위로 락 정보가 공유되지 않음
   - 그룹 복제의 인증 단계에서 고려되지 않음
- 바이너리 로그 체크섬
   - MySQL 8.0.21 버전부터 사용 가능
- 트랜잭션 격리 수준
   - 멀티 프라이머리 모드에서 SERIALIZABLE 격리 수준 사용 불가
- 멀티 프라이머리 모드 제약
   - 동일 테이블에 대한 서로 다른 멤버에서의 동시 DDL 및 DML 실행 지원 안 함
   - 외래키, 특히 CASCADE 제약 조건이 있는 테이블 지원 안 함
   - 'group_replication_enforce_update_everywhere_checks' 시스템 변수 활성화 권장
- 싱글 프라이머리 모드
   - 'group_replication_enforce_update_everywhere_checks' 시스템 변수 반드시 비활성화
- SELECT ... FOR UPDATE
   - 멀티 프라이머리 모드에서 데드락 발생 가능성
- 복제 필터
   - 그룹 복제에서 사용 불가
   - 그룹 외부 일반 복제에 대해서만 필터링 설정 가능
- 멤버 수 제한
   - 최대 9대의 서버까지 구성 가능
   - 9대 초과 시 에러 발생

## 17.3 MySQL 셸

- MySQL 셸은 MySQL을 위한 고급 클라이언트 툴로, 기존 mysql 클라이언트보다 확장된 기능을 제공
- 다중 언어 지원
   - SQL, JavaScript, Python 모드 지원
   - 기본 모드: JavaScript
- API 제공
   - X DevAPI: X 프로토콜 사용, 관계형 및 문서 기반 데이터 처리
   - AdminAPI: MySQL 서버 설정 변경, InnoDB 클러스터 및 레플리카셋 구축
- p599 참조 


## 17.4 MySQL 라우터
- InnoDB 클러스터에서 프록시 역할을 수행
    - InnoDB 클러스터의 MySQL 구성 변경 자동 감지
    - 쿼리 부하 분산
    - 자동 페일오버
- 구성 변경의 유연성
   - 애플리케이션 서버는 라우터 정보만 알면 됨
   - MySQL 서버 구성 변경 시 애플리케이션 설정 수정 불필요
- 자동화된 관리
   - MySQL 서버 정보를 메모리에 캐시하고 주기적으로 갱신
   - 클러스터 구성 변경 자동 감지
- 부하 분산
   - 쿼리를 여러 MySQL 서버에 분산 처리
   - 라우팅 커넥션별로 부하 분산 방식 지정 가능
- 고가용성
   - MySQL 서버 장애 시 자동으로 다른 서버로 쿼리 재시도
   - 지정된 부하 분산 방식에 따라 재시도 서버 결정
- 투명한 장애 처리
   - 애플리케이션 서버는 장애 상황을 인식하지 않고 정상적으로 쿼리 실행 가능
- 작동방식
    1. 애플리케이션 서버는 MySQL 라우터에 연결
    2. MySQL 라우터는 InnoDB 클러스터 내 적절한 MySQL 서버로 쿼리 전달
    3. 쿼리 결과를 받아 애플리케이션 서버로 반환
