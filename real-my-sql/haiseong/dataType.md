
# 데이터 타입
- **저장되는 값의 성격에 맞는 최적의 타입을 선정**: 칼럼에 저장될 데이터의 특성에 따라 적합한 타입을 선택해야 함. 
- **가변 길이 칼럼의 최적 길이 지정**: 너무 긴 길이는 저장 공간을 낭비하고, 너무 짧은 길이는 스키마 변경 시 큰 부담을 줄 수 있으므로 적절한 길이 선정이 중요함.
- **조인 조건으로 사용되는 칼럼은 동일한 데이터 타입 사용**: 조인이나 WHERE 조건에서 인덱스를 효율적으로 사용하려면 칼럼의 데이터 타입뿐만 아니라 길이와 문자 집합, 콜레이션까지 동일해야 함.

---

## 문자열 (CHAR, VARCHAR)
### CHAR와 VARCHAR의 차이
- **CHAR**: 고정 길이. 실제 입력된 값의 크기와 관계없이 고정된 공간을 사용함.
- **VARCHAR**: 가변 길이. 저장되는 값의 크기에 따라 공간이 달라짐.
- 한 문자를 저장할때 문자 집합에 따라 1~4 바트를 사용함
- VARCHAR 타입의 길이가 255 바이트 이상이면 길이 저장을 위해 2바이트를 써야함

### 결정 기준
- **문자열의 길이가 대개 비슷한가?**
- **칼럼의 값이 자주 변경되는가?**

VARCHAR 칼럼은 값이 변경되었을 때 더 큰 값으로 업데이트되면 공간 이동이 발생할 수 있음. CHAR은 고정 길이이므로 값만 수정하면 됨.  
또한 **CHAR, VARCHAR**에 지정하는 길이는 바이트가 아닌 **문자의 개수**임.

---

## 문자집합 (캐릭터 셋)
CHAR, VARCHAR, TEXT 타입만 사용 가능

- latim : 알파벳, 숫자, 키보드 특수문자 (1바이트)
- euckr : 한국어 전용 (1~2바이트)
- utf8mb4 : 다국어, 4 바이트
- utf8 : 다국어, 1~3 바이트
 
기본 코렐레이션
- **character_set_system**: MySQL 서버가 식별자를 저장할 때 사용하는 문자집합 (utf8).
- **character-set-server**: MySQL 서버의 기본 문자집합.
- **character_set_database**: MySQL DB의 기본 문자집합.
- **character_set_client**: 클라이언트가 보낸 SQL 문장의 인코딩 방식.
- **character_set_connection**: 클라이언트로부터 전달받은 SQL 문장을 처리하는 문자집합.

---

## 콜레이션 (Collation)
콜레이션은 **문자열 비교 및 정렬 순서**를 정의함.

  - **ci**: 대소문자 구분 안 함.
  - **cs**: 대소문자 구분.
  - **bin**: 바이트 값을 기준으로 비교.
  - **ai**: 액센트 가진 문자 구분 안 함.
  - **as**: 액센트 가진 문자 구분.

MySQL에서 기본 콜레이션이 설정되지 않았다면, 기본적으로 **utf8mb4_0900_ai_ci**가 적용됨.

---

## 숫자 데이터 타입
### 값의 정확도에 따른 타입 분류
- **참값**: 소수점 이하 유무와 관계없이 정확한 값을 유지함 (예: **INTEGER, DECIMAL**).
- **근사값**: 부동 소수점 방식으로 저장되어 값이 완전히 일치하지 않음 (예: **FLOAT, DOUBLE**).

### 부동 소수점과 DECIMAL
부동 소수점은 값의 동등 비교가 불가능하고, 데이터 복제 시 차이가 발생할 수 있음. 금액처럼 **정확한 계산**이 필요한 경우 **DECIMAL** 타입을 사용하는 것이 좋지만, 저장 공간을 많이 차지함

### 정수 타입
- **TINYINT**: 1바이트
- **SMALLINT**: 2바이트
- **MEDIUMINT**: 3바이트
- **INTEGER**: 4바이트
- **BIGINT**: 8바이트

정수 타입은 **UNSIGNED**를 사용하여 양의 정수 범위를 두 배로 넓힐 수 있음.

- AUTHO_INCREMENT 옵션을 사용한 칼럼은 반드시 그 테이블에서 프라이머리 키나 유니크 키의 일부로 적용되어야 함 (또한 가장 선두에 위치해야함)

---

## 날짜와 시간 (DATETIME, TIMESTAMP)

날짜 시간 저장 공간
- YEAR : 1바이트
- DATE : 3바이트
- TIME : 3바이트 + (밀리초 단위 저장 공간)
- DATETIME : 5바이트 + (밀리초 단위 저장 공간)
- TIMESTAMP : 4바이트 + (밀리초 단위 저장 공간)

밀리초 저장 공간
- 밀리초 저장 x : 0바이트
- 1, 2 자리 : 1바이트
- 3, 4 자리 : 2바이트
- 5, 6 자리 : 3바이트

DATETIME vs TIMESTAMP
**DATETIME**: 타임존에 영향을 받지 않음.
    - JDBC 드라이버는 MySQL타임존에서 JVM의 타임존으로 자동으로 변환해서 출력함 (getTimestamp()로 값을 가져와서)
    - ORM을 사용할때는 내부에서 자동으로 페치하기 떄문에 테스트를 해보자.
**TIMESTAMP**: 타임존에 따라 자동으로 시간이 조정됨. (UTC를 기준으로 저장)

### 자동 업데이트
- **자동 타임스탬프**: 레코드가 **INSERT** 또는 **UPDATE** 될 때 자동으로 현재 시간으로 변경됨.

## ENUM
- 실제로 정수가 저장됨
    - 데이터가 많을때 효율적으로 저장
    - 실제로 데이터가 사용될때 버퍼풀로 적재시켜야 하므로 효율적으로 쿼리를 사용
- 칼럼에 저장되는 문자열 값이 추가되면 구조가 변경될 수 있다.


## SET
- BIT-OR 연산을 사용
- ('TENIS', 'SOCCER', 'GOLF') 라면
    - 'SOCCER' : 010
    - 'TENIS', 'GOLF' : 101
    - 이런식으로 저장되는듯?
- FIND_IN_SET() 으로 검사 가능
- 동등 비교를 수행하려면 저장된 순서대로 문자를 나열해야함
- FIND_IN_SET() 은 인덱스를 효율적으로 이용할 수 없다

## TEXT와 BLOB
- MySQL에서 대용량 데이터를 저장하려면 TEXT나 BLOB 타입을 사용해야 함. 
- 대부분 동일하게 작동.
    - TEXT는 문자열을 저장하는 대용량 칼럼으로 문자 집합이나 콜레이션을 가짐
    - BLOB은 이진 데이터 타입으로서 별도의 문자 집합이나 콜레이션이 없음
- 길이가 예측 불가능한 문자열이나 이진 데이터를 저장할 때: TEXT나 BLOB을 사용함.
    - MySQL에서는 레코드의 전체 크기가 64KB를 넘지 않는 한 VARCHAR나 VARBINARY 타입을 사용할 수 있음. (4000바이트를 넘는다고 반드시 TEXT나 BLOB으로 저장할 필요는 없음)
    - MySQL에서는 레코드 전체 크기가 일반적으로 64KB를 초과할 수 없음.
- max_sort_length : TEXT 타입을 정렬을 수행할때 읽는 크기, 뒤에 있는 길이는 정렬하지 않음 (빠르게 정렬하려면 이 값을 줄이기)
- max_allowed_packet : TEXT나 BLOB을 조작하는 SQL이 너무 길어지면 MySQL 서버로 전송되지 않을 수 있음. 이 변수를 늘려서 설정
- 칼럼이 너무 길어지면 pk 페이지에 저장하지 못하고 외부 페이지를 체인하여 저장한다.


### 가상 칼럼(파생 칼럼)
- AS 절로 계산식을 정의하고 마지막에 키워드를 붙임
- 스토어드 칼럼 : 칼럼 정의 뒤에 STORED 키워드를 붙임
    - 칼럼의 값이 물리적으로 디스크에 저장됨
    - 칼럼의 구조 변경은 다른 일반 테이블과 같이 필요 시 리빌드 방식으로 처리
    - INSERT와 UPDATE 시점에만 칼럼의 값이 계산됨
    - CPU 사용량을 높여서 디스크 부하를 낮춤
- 가상 칼럼(Generated Calumn) : 칼럼 정의 뒤에 VIRTUAL 키워드를 붙이거나 붙이지 않으면 기본으로 가상 칼럼임
    - 칼럼의 값이 디스크에 저장되지 않음
    - 칼럼의 구조 변경은 테이블 리빌드를 필요하지 않음
    - 칼럼의 값은 레코드가 읽히기 전 또는 BEFORE 트리거 실행 직후에 계산되어 만들어짐
    - 디스크 사용량을 높여서 CPU 사용량을 낮춤

