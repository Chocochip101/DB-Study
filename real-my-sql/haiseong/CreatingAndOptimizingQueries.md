
## 11.1 쿼리 작성과 연관된 시스템 변수

- SQL 모드 : 여러 종류가 있고 여러 개의 값이 동시에 설정될 수 있다.
- 영문 대소문자 구분 : 
  - DB나 테이블이 디스크에서 디렉터리나 파일로 매핑되어 OS에 따라 테이블명의 대소문자를 구분한다.(윈도우는 구분 안함, 유닉스계열은 구분)
  - lower_case_table_names 설정하면 대소문자 구별 안함
- 예약어 : 예약어로 사용되는 단어를 테이블명이나 컬럼명으로 사용하려면 역따옴표로 감싸야 한다.


## 11.2 매뉴얼의 SQL 문법 표기 읽는 법
- 대문자 : 키워드 (대소문자 구분 하지 않아도됨)
- 이탤릭체 : 사용자가 선택해서 작성하는 토큰
- 대괄호 : 선택적인 사항
- 파이프 : 단하나만 선택해서 쓸 수 있는 값
- 중괄호 : 괄호 내 아이템 중에서 반드시 하나를 사용해야 하는 경우
- ... : 여러개의 값이 올 수 있다.


## 11.3 연산자와 내장 함수
- 리터럴 표기 : 
  - 문자열 : MySQL은 쌍따옴표도 가능하지만 홑따옴표 추천
  - 숫자 : 따옴표 없이 입력, 사용하더라도 숫자타입의 칼럼이면 문자열값을 숫자 값으로 변경해줌
  - 날짜 : 문자열을 알아서 Date, DateTime 으로 바꿔줌
  - 불리언 : 사실 TINYINT, TRUE/FALSE, 1/0 으로 표현 가능
  - <=> : NULL-safe equal operator
    - NULL = NULL 은 false, NULL <=> NULL 은 true
    - NULL 을 하나의 값으로 취급하여 비교할 때 사용
  - 부정 : Not-Equal, <>, != 둘다 사용 가능
  - NOT : NOT, ! 둘다 사용 가능
  - AND, OR : &&, || 도 사용가능, 논리 연산자
  - 나누기, 나머지 : /, %, DIV, MOD 사용 가능
  - REGEXP : 정규표현식 사용 가능
  - LIKE : 패턴 매칭 연산자, %, _ 사용 가능
  - BETWEEN : 범위 연산자, NOT BETWEEN 도 사용 가능
  - IN : 여러 값 중 하나인지 확인
    - 상수가 사용된 경우 : 동등비교와 동일하게 처리되어 매우 빠르게 처리된다.
    - 서브쿼리가 사용된 경우 : 최적화가 매우 까다롭다.
    - NOT IN : 동동이 아닌 부정형 비교라 인덱스를 이용해 처리 범위를 줄이는 것이 불가능하다.

## 11.4 SELECT

### SELECT 절의 실행 순서

- FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY
  - 예외적인 경우도 있다.

### WHERE, GROUP BY, ORDER BY의 인덱스 사용

- 인덱스 사용의 기본 원칙
  - **원본값 사용**: `WHERE`, `ORDER BY`, `GROUP BY` 절에서 인덱스를 사용하려면 해당 컬럼 값을 변환하지 않고 그대로 사용해야 해야함

### HERE 절에서의 인덱스 사용
- **작업 범위 결정 조건:** `WHERE` 절에서 인덱스 사용은 주로 동등 비교(`=`)나 `IN` 조건을 사용한 컬럼이 인덱스의 순서와 일치할 때 가능
-  `WHERE` 절에 명시된 조건들의 순서는 인덱스 사용 여부에 큰 영향을 미치지 않음
-  동등 비교와 범위 비교 조건이 결합된 경우, 범위 조건 이후의 인덱스 컬럼은 인덱스를 사용하지 못할 수 있다.

### GROUP BY 절에서의 인덱스 사용
- **인덱스 순서 일치:** `GROUP BY` 절은 명시된 컬럼이 인덱스 컬럼의 순서와 일치할 때 인덱스를 사용할 수 있습니다. 순서가 일치하지 않거나 인덱스의 앞쪽 컬럼이 누락된 경우 인덱스를 사용할 수 없음
- **WHERE 절과 결합:** `WHERE` 절의 조건에서 동등 비교가 사용된 컬럼은 `GROUP BY` 절에 명시되지 않아도 인덱스를 이용한 그룹핑이 가능

### ORDER BY 절에서의 인덱스 사용
- **정렬 순서와 일치:** `ORDER BY` 절은 컬럼의 정렬 순서(오름차순, 내림차순)가 인덱스와 일치해야 인덱스를 사용할 수 있다. 
- `ORDER BY` 절에 명시된 컬럼들이 인덱스의 왼쪽부터 일치해야 하며, 순서가 일치하지 않거나 일부 컬럼이 누락된 경우 인덱스를 사용할 수 없다.

### WHERE 절의 비교 조건
- **타입 일치:** 문자열이나 숫자 컬럼을 비교할 때는 해당 컬럼의 타입에 맞는 상수 값을 사용하는 것이 중요
- 타입이 일치하지 않으면 MySQL이 타입 변환을 시도하며, 이로 인해 인덱스가 비활성화될 수 있다.

### Short-Circuit Evaluation
- **쿼리 최적화:** `WHERE` 절에 여러 조건이 있을 때, MySQL은 선행 조건이 거짓이면 후행 조건을 평가하지 않음. 이로 인해 조건의 순서에 따라 쿼리 성능이 달라질 수 있다.
- **예시:**
  ```sql
  SELECT COUNT(*) FROM salaries
  WHERE to_date < '1985-01-01'  -- 결과가 없으므로 이후 조건 평가 불필요
    AND CONVERT_TZ(from_date, '+00:00', '+09:00') > '1991-01-01';
  ```

### DISTINCT
- 특정 컬럼의 유니크한 값을 조회하기 위해 사용.

### LIMIT n
- 쿼리 결과의 지정된 순서를 가져오기 위해 사용하며 쿼리의 가장 마지막이 실행
- GROUP BY는 그루핑과 정렬의 특성을 모두 가지고 있어 인덱스가 없다면, LIMIT절이 있더라도 작업내용을 크게 줄여주지 못한다.

### COUNT()
- COUNT(*)을 사용하더라도 PK컬럼을 지정한 것과 동일한 성능을 낸다.
- MySQL8.0 버전부터 COUNT() 쿼리에 사용된 옵티마이저가 ORDER BY절을 무시하도록 개선되었다.
- COUNT(COLUMN1)의 경우 NULL을 제외하고 카운팅


### JOIN의 순서와 인덱스
- 인덱스 레인지 스캔은 인덱스 탑색과 인덱스를 스캔하는 과정으로 구분 할 수 있다.
- 형이 같은 컬럼비교에서 한쪽 테이블에만 인덱스가 있는 경우 인덱스 있는 테이블을 드리븐 테이블로 선택 할 확률이 높다.
- 비교 되는 컬럼 모두 인덱스가 없다면, 레코드 건수가 적은 테이블을 드라이빙 테이블로 선택하는 것이 훨씬 효율적이다.

### JOIN 컬럼의 데이터 타입
- 데이터 타입이 다른경우, 문자타입이 같더라도 콜레이션이 다른경우, 같은 INT타입이더라도 부호의 존재여부가 다른경우 형변환 작업으로 인덱스를 제대로 사용 할 수 없다.

### 지연된 조인
- 조인이 실행되기 전에 `GROUP BY`나 `ORDER BY`를 처리하는 방식
- 지연된 조인은 `LIMIT` 절과 사용시 큰 효과를 기대 할 수 있다.
- 지연된 조인은 조인의 개수를 줄이고 `GROUP BY` 나 `ORDER BY` 처리가 필요한 레코드 전체크기를 줄이는 역할도 한다.

### 래터럴 조인
- MySQL8.0 버전부터 래터럴 조인이 가능하며, 특정 그룹별로 서브쿼리를 실행해 그 결과와 조인하는 것이 가능하다.
- 래터럴 조인은 FROM절에서 사용된 서브쿼리에서 외부 쿼리의 FROM절에 정의된 테이블 컬럼을 참조 할 수 있다.
- LATERAL 키워드를 사용하지 않으면 에러가 발생하며, 레코드단위로 임시테이블이 생성되기에 필요한 경우에만 사용해야한다.

### 실행계획으로 인한 정렬 흐트러짐
- MySQL 8.0 버전부터 해시조인을 지원하며, 해시조인 시 인덱스여부에 상관없이 쿼리 결과의 레코드 정렬 순서가 달라진다.
보통 레코드가 반복적으로 순환되는 결과를 반환하며, 인덱스의 정렬을 믿고 order by절을 생략하는 일은 지양해야한다.

### GROUP BY
- WITH ROLLUP
  - 그룹별 소계 레코드를 추가해서 표시  

### ORDER BY
- 인덱스를 사용한 SELECT의 경우에는 인덱스에 정렬된 순서대로 레코드를 가져온다.
- SEELCT 쿼리가 임시테이블을 거쳐 처리되면, 조회되는 레코드의 순서를 예측하기 어렵다.
- 어떤 DBMS도 ORDER BY절이 없다면, 쿼리에 대해 어떠한 정렬도 보장하지 않는다.
- `ORDER BY` 절 사용 시 실행계획에서 Using filesort를 확인하는 경우가 있으며 이경우 sort-merge 작업이 발생한다.
- MySQL8.0 버전부터 오름차순과 내림차순을 혼용해 복합인덱스를 생성 할 수 있다.
- 함수를 사용한 연산값 기준으로 정렬하는 작업이 인덱스를 사용하도록 개선되었다.

### 서브쿼리
- SELECT절에 사용
  - 임시테이블을 만들거나 쿼리를 비효율적으로 실행하게 만들지 않기에 인덱스를 잘사용하는지 여부만 체크
  - SELECT절에 서브쿼리를 사용하면 항상 컬럼과 레코드가 하나인결과를 반환해야 한다. -> 스칼라

- FROM절에 사용된 서브쿼리
5.7버전부터 FROM절에 서브쿼리가 사용되면, 옵티마이저가 서브쿼리를 외부 쿼리로 병합하는 최적화를 수행하도록 개선되었다

- WHERE절에 사용
  - 동등및 크다 작다 비교에서 MySQL 5.5 버전부터 서브쿼리를 먼저 실행한 후 나머지 쿼리부분을 처리한다.
  - IN 비교에서는 세미조인을 수행하며 세미조인이랑 테이블의 레코드가 다른 테이블의 레코드를 이용한 표현식과 일치하는지 체크하는 형태를 말한다.
  - NOT IN 비교의 경우 NOT EXISTS, 구체화 두가지 방법으로 최적화를 수행하지만 성능향상에 크게 도움이 되지 않는다.
  - NOT IN절만 단독으로 사용된경우 테이블 풀스캔을 한다.

### 잠금을 사용하는 SELECT
- InnoDB 테이블은 SELECT작업에 잠금을 사용하지 않는다.
- 강제로 잠금이 필요한 경우 FOR SHARE와 FOR UPDATE 절을 이용 할 수 있다.
- FOR SHARE : SELECT된 레코드에 대해 읽기잠금을 설정하고, 다른 세션은 읽기는 가능하나 레코드변경을 제한한다.
- FOR UPDATE : 배타잠금을 획득하고, 레코드 변경 및 읽기가 가능하다.

### NOWAIT
- 다른 트랜잭션에 의해 잠겨진 상태라면 에러를 반환하며 쿼리는 즉시 종료된다.

### SKIP LOCKED
- 다른 트랜잭션에 의해 잠겨진 상태라면 잠겨지지 않은 레코드만 가져온다.

## 11.5 INSERT

### INSERT IGNORE
- PK,UK 컬럼의 값이 INSERT문의 레코드와 중복되는 경우, 모두 무시하고 다음 레코드를 처리한다.
- 중복레코드 말고도 타입이 일치하지 않는경우도 컬럼의 기본값으로 삽입한다.

### INSERT ...ON DUPLICATE KEY UPDATE
- ansi 표준 merge문과 비슷하다.
- 키 기준으로 존재하면 update, 없으면 insert 작업을 수행한다.

### LOAD DATA
- MySQL엔진과 Storage엔진 호출을 최소화 해 일반적인 INSERT문과 비교시 속도에서 빠름
- 단일스레드 / 단일트랜잭션으로 실행되어 트랜잭션이 길어진다면 다른 온라인 트랜잭션쿼리 성능에 영향을 줄 수 있다.
- 트랜잭션이 길어져 언두가 삭제되지 않고 언두처리 성능에 영향을 준다.

### 프라이머리 키 / Auto-Increment
- PK값으로 정렬하여 INSERT작업 시 정렬안하고 작업하는것과 큰 성능차이를 보인다.
- INSERT와 SELECT의 성능을 모두 고려하여 키를 지정하는게 베스트, 하지만 보통은 두가지 요소중 한개를 선택하게 된다.


## 11.6 UPDATE와 DELETE

### UPDATE ...ORDER BY ...LIMIT n
- `ORDER BY` 절과 `LIMIT` 절을 통해 특정 컬럼으로 정렬 후 상위 몇건만 UPDATE 작업을 수행 할 수 있다.

### JOIN UPDATE
- 두개 이상의 테이블을 조인해 조인된 결과 레코드를 변경 및 삭제하는 쿼리
- 읽기만 참조되는 테이블은 읽기 잠금, 칼럼이 변경되는 테이블은 쓰기잠금이 걸린다.
  - 데드락 발생 가능
