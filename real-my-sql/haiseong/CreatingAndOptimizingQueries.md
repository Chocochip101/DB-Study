
## 11.1 쿼리 작성과 연관된 시스템 변수

- SQL 모드 : 여러 종류가 있고 여러 개의 값이 동시에 설정될 수 있다.
- 영문 대소문자 구분 : 
  - DB나 테이블이 디스크에서 디렉터리나 파일로 매핑되어 OS에 따라 테이블명의 대소문자를 구분한다.(윈도우는 구분 안함, 유닉스계열은 구분)
  - lower_case_table_names 설정하면 대소문자 구별 안함
- 예약어 : 예약어로 사용되는 단어를 테이블명이나 컬럼명으로 사용하려면 역따옴표로 감싸야 한다.


## 11.2 매뉴얼의 SQL 문법 표기 읽는 법
- 대문자 : 키워드 (대소문자 구분 하지 않아도됨)
- 이탤릭체 : 사용자가 선택해서 작성하는 토큰
- 대괄호 : 선택적인 사항
- 파이프 : 단하나만 선택해서 쓸 수 있는 값
- 중괄호 : 괄호 내 아이템 중에서 반드시 하나를 사용해야 하는 경우
- ... : 여러개의 값이 올 수 있다.


## 11.3 연산자와 내장 함수
- 리터럴 표기 : 
  - 문자열 : MySQL은 쌍따옴표도 가능하지만 홑따옴표 추천
  - 숫자 : 따옴표 없이 입력, 사용하더라도 숫자타입의 칼럼이면 문자열값을 숫자 값으로 변경해줌
  - 날짜 : 문자열을 알아서 Date, DateTime 으로 바꿔줌
  - 불리언 : 사실 TINYINT, TRUE/FALSE, 1/0 으로 표현 가능
  - <=> : NULL-safe equal operator
    - NULL = NULL 은 false, NULL <=> NULL 은 true
    - NULL 을 하나의 값으로 취급하여 비교할 때 사용
  - 부정 : Not-Equal, <>, != 둘다 사용 가능
  - NOT : NOT, ! 둘다 사용 가능
  - AND, OR : &&, || 도 사용가능, 논리 연산자
  - 나누기, 나머지 : /, %, DIV, MOD 사용 가능
  - REGEXP : 정규표현식 사용 가능
  - LIKE : 패턴 매칭 연산자, %, _ 사용 가능
  - BETWEEN : 범위 연산자, NOT BETWEEN 도 사용 가능
  - IN : 여러 값 중 하나인지 확인
    - 상수가 사용된 경우 : 동등비교와 동일하게 처리되어 매우 빠르게 처리된다.
    - 서브쿼리가 사용된 경우 : 최적화가 매우 까다롭다.
    - NOT IN : 동동이 아닌 부정형 비교라 인덱스를 이용해 처리 범위를 줄이는 것이 불가능하다.

## 11.4 SELECT

### SELECT 절의 실행 순서

- FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY
  - 예외적인 경우도 있다.

### WHERE, GROUP BY, ORDER BY의 인덱스 사용

- 인덱스 사용의 기본 원칙
  - **원본값 사용**: `WHERE`, `ORDER BY`, `GROUP BY` 절에서 인덱스를 사용하려면 해당 컬럼 값을 변환하지 않고 그대로 사용해야 해야함

### HERE 절에서의 인덱스 사용
- **작업 범위 결정 조건:** `WHERE` 절에서 인덱스 사용은 주로 동등 비교(`=`)나 `IN` 조건을 사용한 컬럼이 인덱스의 순서와 일치할 때 가능
-  `WHERE` 절에 명시된 조건들의 순서는 인덱스 사용 여부에 큰 영향을 미치지 않음
-  동등 비교와 범위 비교 조건이 결합된 경우, 범위 조건 이후의 인덱스 컬럼은 인덱스를 사용하지 못할 수 있다.

### GROUP BY 절에서의 인덱스 사용
- **인덱스 순서 일치:** `GROUP BY` 절은 명시된 컬럼이 인덱스 컬럼의 순서와 일치할 때 인덱스를 사용할 수 있습니다. 순서가 일치하지 않거나 인덱스의 앞쪽 컬럼이 누락된 경우 인덱스를 사용할 수 없음
- **WHERE 절과 결합:** `WHERE` 절의 조건에서 동등 비교가 사용된 컬럼은 `GROUP BY` 절에 명시되지 않아도 인덱스를 이용한 그룹핑이 가능

### ORDER BY 절에서의 인덱스 사용
- **정렬 순서와 일치:** `ORDER BY` 절은 컬럼의 정렬 순서(오름차순, 내림차순)가 인덱스와 일치해야 인덱스를 사용할 수 있다. 
- `ORDER BY` 절에 명시된 컬럼들이 인덱스의 왼쪽부터 일치해야 하며, 순서가 일치하지 않거나 일부 컬럼이 누락된 경우 인덱스를 사용할 수 없다.

### WHERE 절의 비교 조건
- **타입 일치:** 문자열이나 숫자 컬럼을 비교할 때는 해당 컬럼의 타입에 맞는 상수 값을 사용하는 것이 중요
- 타입이 일치하지 않으면 MySQL이 타입 변환을 시도하며, 이로 인해 인덱스가 비활성화될 수 있다.

### Short-Circuit Evaluation
- **쿼리 최적화:** `WHERE` 절에 여러 조건이 있을 때, MySQL은 선행 조건이 거짓이면 후행 조건을 평가하지 않음. 이로 인해 조건의 순서에 따라 쿼리 성능이 달라질 수 있다.
- **예시:**
  ```sql
  SELECT COUNT(*) FROM salaries
  WHERE to_date < '1985-01-01'  -- 결과가 없으므로 이후 조건 평가 불필요
    AND CONVERT_TZ(from_date, '+00:00', '+09:00') > '1991-01-01';
  ```

### DISTINCT
- 특정 컬럼의 유니크한 값을 조회하기 위해 사용.

### LIMIT n
- 쿼리 결과의 지정된 순서를 가져오기 위해 사용하며 쿼리의 가장 마지막이 실행
- GROUP BY는 그루핑과 정렬의 특성을 모두 가지고 있어 인덱스가 없다면, LIMIT절이 있더라도 작업내용을 크게 줄여주지 못한다.

### COUNT()
- COUNT(*)을 사용하더라도 PK컬럼을 지정한 것과 동일한 성능을 낸다.
- MySQL8.0 버전부터 COUNT() 쿼리에 사용된 옵티마이저가 ORDER BY절을 무시하도록 개선되었다.
- COUNT(COLUMN1)의 경우 NULL을 제외하고 카운팅


### JOIN의 순서와 인덱스
- 인덱스 레인지 스캔은 인덱스 탑색과 인덱스를 스캔하는 과정으로 구분 할 수 있다.
- 형이 같은 컬럼비교에서 한쪽 테이블에만 인덱스가 있는 경우 인덱스 있는 테이블을 드리븐 테이블로 선택 할 확률이 높다.
- 비교 되는 컬럼 모두 인덱스가 없다면, 레코드 건수가 적은 테이블을 드라이빙 테이블로 선택하는 것이 훨씬 효율적이다.

### JOIN 컬럼의 데이터 타입
- 데이터 타입이 다른경우, 문자타입이 같더라도 콜레이션이 다른경우, 같은 INT타입이더라도 부호의 존재여부가 다른경우 형변환 작업으로 인덱스를 제대로 사용 할 수 없다.

### 지연된 조인
- 조인이 실행되기 전에 `GROUP BY`나 `ORDER BY`를 처리하는 방식
- 지연된 조인은 `LIMIT` 절과 사용시 큰 효과를 기대 할 수 있다.
- 지연된 조인은 조인의 개수를 줄이고 `GROUP BY` 나 `ORDER BY` 처리가 필요한 레코드 전체크기를 줄이는 역할도 한다.

### 래터럴 조인
- MySQL8.0 버전부터 래터럴 조인이 가능하며, 특정 그룹별로 서브쿼리를 실행해 그 결과와 조인하는 것이 가능하다.
- 래터럴 조인은 FROM절에서 사용된 서브쿼리에서 외부 쿼리의 FROM절에 정의된 테이블 컬럼을 참조 할 수 있다.
- LATERAL 키워드를 사용하지 않으면 에러가 발생하며, 레코드단위로 임시테이블이 생성되기에 필요한 경우에만 사용해야한다.

### 실행계획으로 인한 정렬 흐트러짐
- MySQL 8.0 버전부터 해시조인을 지원하며, 해시조인 시 인덱스여부에 상관없이 쿼리 결과의 레코드 정렬 순서가 달라진다.
보통 레코드가 반복적으로 순환되는 결과를 반환하며, 인덱스의 정렬을 믿고 order by절을 생략하는 일은 지양해야한다.

### GROUP BY
- WITH ROLLUP
  - 그룹별 소계 레코드를 추가해서 표시  

### ORDER BY
- 인덱스를 사용한 SELECT의 경우에는 인덱스에 정렬된 순서대로 레코드를 가져온다.
- SEELCT 쿼리가 임시테이블을 거쳐 처리되면, 조회되는 레코드의 순서를 예측하기 어렵다.
- 어떤 DBMS도 ORDER BY절이 없다면, 쿼리에 대해 어떠한 정렬도 보장하지 않는다.
- `ORDER BY` 절 사용 시 실행계획에서 Using filesort를 확인하는 경우가 있으며 이경우 sort-merge 작업이 발생한다.
- MySQL8.0 버전부터 오름차순과 내림차순을 혼용해 복합인덱스를 생성 할 수 있다.
- 함수를 사용한 연산값 기준으로 정렬하는 작업이 인덱스를 사용하도록 개선되었다.

### 서브쿼리
- SELECT절에 사용
  - 임시테이블을 만들거나 쿼리를 비효율적으로 실행하게 만들지 않기에 인덱스를 잘사용하는지 여부만 체크
  - SELECT절에 서브쿼리를 사용하면 항상 컬럼과 레코드가 하나인결과를 반환해야 한다. -> 스칼라

- FROM절에 사용된 서브쿼리
5.7버전부터 FROM절에 서브쿼리가 사용되면, 옵티마이저가 서브쿼리를 외부 쿼리로 병합하는 최적화를 수행하도록 개선되었다

- WHERE절에 사용
  - 동등및 크다 작다 비교에서 MySQL 5.5 버전부터 서브쿼리를 먼저 실행한 후 나머지 쿼리부분을 처리한다.
  - IN 비교에서는 세미조인을 수행하며 세미조인이랑 테이블의 레코드가 다른 테이블의 레코드를 이용한 표현식과 일치하는지 체크하는 형태를 말한다.
  - NOT IN 비교의 경우 NOT EXISTS, 구체화 두가지 방법으로 최적화를 수행하지만 성능향상에 크게 도움이 되지 않는다.
  - NOT IN절만 단독으로 사용된경우 테이블 풀스캔을 한다.

### 잠금을 사용하는 SELECT
- InnoDB 테이블은 SELECT작업에 잠금을 사용하지 않는다.
- 강제로 잠금이 필요한 경우 FOR SHARE와 FOR UPDATE 절을 이용 할 수 있다.
- FOR SHARE : SELECT된 레코드에 대해 읽기잠금을 설정하고, 다른 세션은 읽기는 가능하나 레코드변경을 제한한다.
- FOR UPDATE : 배타잠금을 획득하고, 레코드 변경 및 읽기가 가능하다.

### NOWAIT
- 다른 트랜잭션에 의해 잠겨진 상태라면 에러를 반환하며 쿼리는 즉시 종료된다.

### SKIP LOCKED
- 다른 트랜잭션에 의해 잠겨진 상태라면 잠겨지지 않은 레코드만 가져온다.

## 11.5 INSERT

### INSERT IGNORE
- PK,UK 컬럼의 값이 INSERT문의 레코드와 중복되는 경우, 모두 무시하고 다음 레코드를 처리한다.
- 중복레코드 말고도 타입이 일치하지 않는경우도 컬럼의 기본값으로 삽입한다.

### INSERT ...ON DUPLICATE KEY UPDATE
- ansi 표준 merge문과 비슷하다.
- 키 기준으로 존재하면 update, 없으면 insert 작업을 수행한다.

### LOAD DATA
- MySQL엔진과 Storage엔진 호출을 최소화 해 일반적인 INSERT문과 비교시 속도에서 빠름
- 단일스레드 / 단일트랜잭션으로 실행되어 트랜잭션이 길어진다면 다른 온라인 트랜잭션쿼리 성능에 영향을 줄 수 있다.
- 트랜잭션이 길어져 언두가 삭제되지 않고 언두처리 성능에 영향을 준다.

### 프라이머리 키 / Auto-Increment
- PK값으로 정렬하여 INSERT작업 시 정렬안하고 작업하는것과 큰 성능차이를 보인다.
- INSERT와 SELECT의 성능을 모두 고려하여 키를 지정하는게 베스트, 하지만 보통은 두가지 요소중 한개를 선택하게 된다.


## 11.6 UPDATE와 DELETE

### UPDATE ...ORDER BY ...LIMIT n
- `ORDER BY` 절과 `LIMIT` 절을 통해 특정 컬럼으로 정렬 후 상위 몇건만 UPDATE 작업을 수행 할 수 있다.

### JOIN UPDATE
- 두개 이상의 테이블을 조인해 조인된 결과 레코드를 변경 및 삭제하는 쿼리
- 읽기만 참조되는 테이블은 읽기 잠금, 칼럼이 변경되는 테이블은 쓰기잠금이 걸린다.
  - 데드락 발생 가능


## 11.7 온라인 DDL
- Online DDL을 사용하는 이유는 스키마 변경을 실행하는 중에도 INSERT나 UPDATE와 같은 DML이 실행될 수 있도록 하기 위해서 사용

### Online DDL 알고리즘
- INSTANT
  - 테이블의 데이터는 변경하지 않고, 메타데이터만 변경함.
  - 아주 짧은시간 동안만 락이잡혀, 쿼리에 크게 영향주지 않는다.
- INPLACE
  - 임시테이블로 데이터를 복사하지 않고, 스키마 변경을 실행한다.
  - 내부적으로 리빌드를 수행 할 수 있으며, 많은시간이 소요될수도 있지만 작업중 읽기와 쓰기 모두 가능하다.
- COPY
  - 변경된 스키마가 반영된 임시테이블을 생성하고 데이터를 복사 한 후 RENAME해 스키마 변경한다.
  - 작업중 읽기작업만 가능하다.


### 온라인 DDL의 실패 케이스
- INPLACE 알고리즘을 사용하는 경우 리빌드로 많은 시간이 걸릴 수 있음
- 많은 DML, 온라인 변경 로그의 공간부족으로 실패 할 수 있다.

### 테이블 구조 조회
- SHOW CREATE TABLE : 컬럼목록과 키정보, 콜레이션정보와 같은 전체적인 구조를 제공
- DESC문장은 컬럼정보와 같은 대략정인 정보를 표형태로 제공

### 테이블 구조 변경
- ALTER TABLE : 테이블 자체의 속성 변경, 인덱스의 추가 삭제, 컬럼 추가
- 동일한 스토리지 엔진으로 교체하는 알고리즘으로 변경하는 쿼리를 날리면 테이블 데이터를 리빌드 하는 목적으로 사용 가능

### 테이블 명 변경
- RENAME TABLE 명령을 사용하며 메타정보만 변경하기에 아주 짧은시간의 락만 잡힌다.
- 여러테이블의 RENAME명령을 하나의 문장으로 묶어 실행 할 수 있다.

### 테이블상태 조회
- SHOW TABLE STATUS를 통해 엔진, 레코드수, 콜레이션 등을 확인 가능 (하지만 대략적인 값임)

### 테이블 삭제
- DROP TABLE 으로 테이블 삭제
- 용량이 매우 큰 테이블을 삭제하는 작업은 부하가 있을 수 있음

### 칼럼 추가
- 대부분은 INPLACE 알고리즘
- 마지막 칼럼으로 추가하는 경우에는 INSTANT

### 칼럼 삭제
- 칼럼을 삭제하는 경우 무조건 INPLACE만 가능

### 칼럼 이름/타입 변경
- 이름만 변경 : INPLACE 이지만 리빌드가 필요없어 INSTANCE처럼 빠르게 가능
- 타입 변경 (INT -> VARCHAR) : COPY
- 타입의 길이 변경 (VARCHAR(16) -> VARCHAR(30)) : 리빌드가 필요할 수 있음
  - 255까지는 길이 저장용 바이트가 1필요 (255이하에서 늘리는 것은 리빌드 필요 x)
  - 255 이상의 길이 추가는 리빌드 필요
- 타입의 길이 변경 (VARCHAR(30) -> VARCHAR(16)) : COPY

### 인덱스 추가
- INPLACE 로 처리
- 전문탐색, 공간검색 인덱스는 SHARED 잠금이 필요

### 인덱스 조회
- SHOW INDEXES 명령 사용

### 인덱스 변경
- MySQL 5.7 부터 INPLACE를 이용해서 인덱스 이름을 변경 가능해짐

### 인덱스 가시성 변경
- 인덱스 삭제는 부담되는 작업이다. (응용 프로그램을 서비스를 멈추고 인덱스를 다시 시작해야 할 수 있음)
- 가시성을 제한하는 기능이 추가 
  - INVISIBLE : 사용안함 
  - VISIBLE : 사용
  - 인덱스를 생성/삭제 하지 않고 INVISIBLE/VISIBLE 옵션을 이용해 인덱스를 사용할지 말지 변경 가능하다.

### 인덱스 삭제
- ALTER TABLE ... DROP INDEX ... 명령으로 삭제
- 세컨더리 인덱스 삭제 : INPLACE 알고리즘 사용
- 프라이머리키 인덱스 삭제 : 모든 세컨더리 인덱스의 리프노드에 프라이머리키값을 삭제해야 하므로 테이블을 재구축 해야함 (COPY)
