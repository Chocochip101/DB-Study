# 트랜잭션과 잠금

**트랜잭션** : 작업의 완전성을 보장해주는 것

- 논리적인 작업 셋을 모두 완벽하게 처리하거나
- 또는 처리하지 못할 경우 원 상태로 북구해서 Partial update(작업의 일부만 적용되는 현상)가 발생하지 않게 하는 기능
- 데이터의 정합성을 보장하기 위한 기능

**잠금** : 여러 커넥션에서 동시에 동일한 자원(레코드 or 테이블)을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 기능

- 동시성을 제어하기 위한 기능이다.

**격리수준** : 한 트랜잭션 내 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 레벨

## 트랜잭션

주의사항 : 최소의 코드에만 적용하는게 좋다.

## MySQL 엔진의 잠금

### 글로벌 락

- `FLUSH TABLES WITH READ LOCK` 명령으로 휙득한다.
- 잠금 가운데 범위가 가장 크다. MySQL 서버 전체에 영향을 미친다.
- 다른 세션에서 `SELECT`를 제외한 DDL, DML 문장이 대기상태로 남는다.
- 주의사항
    - `FLUSH TABLES WITH READ LOCK` 명령과 동시에 서버에 존재하는 모든테이블을 닫고 잠금을 건다.
    - `FLUSH TABLES WITH READ LOCK` 명령은 잠금을 걸기 전에 테이블을 플러시 해야한다. 따라서 테이블에 실행 중인 모든 종류의 쿼리가 완료되어야 한다.
    - 장시간 SELECT 쿼리가 실행되고 있을때 실행하면 서버의 모든 테이블에 큰 영향을 미치기 때문에 웹 서비스용으로는 적절하지 않다.
- InnoDB는 트랜잭션을 지원하기 때문에 모든 데이터 변경을 멈출 필요는 없다. → 가벼운 글로벌 락의 필요성이 생김 → 백업락 도입
- 백업 락은 일반적인 테이블의 데이터 변경은 허용하지만 다음 테이블의 스키마나 사용자의 인증 관련 정보를 변경할 수 없게 된다.

### 테이블 락

- 개별 테이블 단위로 설정되는 잠금이다.
- `LOCK TABLE WITH READ LOCK` 명령으로 명시적으로 테이블락을 걸 수 있다.
    - 하지만 명시적으로 락을 거는 작업은 글로벌 락처럼 온라인 작업에 상당한 영향을 미친다.
    - 명시적으로 잠금을 반납해야한다.
- MyISAM이나 메모리 테이블에 데이터를 변경하는 쿼리를 실행하면 묵시적으로 발생한다.
    - 완료된 후 자동으로 해제된다.
    - InnoDB 테이블의 경우 레코드 기반의 잠금을 제공하기 때문에 묵시적 락이 설정되지 않는다.
        - 정확히는 DML의 경우는 묵시적 락이 설정되지 않고 DDL의 경우만 묵시적 락이 설정된다.

### 네임드 락

- `GET_LOCK()` 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다.
- 테이블이나 레코드 같은 데이터베이스 객체가 아니라 사용자가 지정한 문자열에 대해 거는 락이다.
- 자주 사용되지 않는다.
- 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용할 수 있다.
    - 배치 프로그램처럼 한번에 많은 레코드를 변경하면 데드락의 원인이 된곤한다.
- MySQL 8.0 부터는 네임드 락을 중첩해서 사용, 한 세션이 휙득한 네임드락을 한 번에 해제 할 수 있게 됐다.

### 메타데이터 락

- 데이터베이스 객체(테이블 이나 뷰 등)의 이름이나 구조를 변경하는 경우에 휙득하는 잠금이다.
- 명시적으로 휙득하는것이 아니라 이름은 변경하는 경우 자동으로 휙득된다.

## InnoDB 스토리지 엔진 잠금

- MySQL에서 제공하는 잠금과 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고있다.
    - 이전에는 MySQL 명령을 이용해 InnoDB의 잠금정보를 접근하기가 매우 까다로웠다.
    - 하지만 최근 버전에서는 information_schema 데이터베이스의 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS 테이블들을 조인해서 조회하면 어떤 트랜잭션이 해당 잠금을 가지고 있는지 조회할 수 있고 장시간 잠금을 가지는 클라이언트를 찾아 종료시킬 수도 있다.

### 레코드 락

- 레코드 자체만을 잠근다.
- 레코드 자체가 아니라 인덱스의 레코드를 잠근다.
- 프라이머리 키 또는 유니크 인덱스에 의한 변경작업에서 레코드락을 건다.

### 갭 락

- 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만 잠금다.
- 새로운 레코드가 생성 되는것을 제어한다.
- 갭 락 자체보다는 넥스트 키 락의 일부로 자주 사용된다.

### 넥스트 키 락

- 레코드 락과 갭 락을 합쳐놓은 형태의 락이다.
- STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 REPEATABLE READ 격리수준을 사용해야 한다. (왜??)
- innodb_locks_unsafe_binlog 가 비활성화 되면 변경을 위해 검색하는 레코드에서는 넥스트 키 락 방식으로 잠금이 걸린다. (?)
- InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다.
    - 넥스트 키락과 갭락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생한다.
    - 가능하면 바이너리 로그 포맷을 ROW로 바꾸자

### 자동 증가 락

- 자동 증가하는 숫자 값을 추출하기 위해 AUTO_INCREMENT 라는 칼럼 속성을 제공한다.
- 여러 레코드가 INSERT될 때 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호를 가져야한다.
- `innodb_autoinc_lock_mode = 0`
    - InnoDB 스토리지 엔진에서 내부적으로 AUTO_INCREMENT 락 이라고 하는 테이블 수준의 잠금을 사용한다.
    - AUTO_INCREMENT 락은 새로운 레코드를 저장하는 쿼리(INSERT, REPLACE)에서만 필요하며 DELETE, UPDATE에서는 필요하지 않다.
    - 트랜잭션과 관계없이 AUTO_INCREMENT 값만 가져오는 순간 잠금이 풀린다.
- `innodb_autoinc_lock_mode = 1`
    - MySQL서버가 INSERT되는 레코드의 건수를 정확히 예측할 수 있을 때는 자동 증가 락을 사용하지 않고, 훨씬 가볍고 빠른 래치(뮤텍스)를 이용해 처리한다. 개선된 래치는 자동 증가 락과 달리 아주 짧은 시간 동안만 잠금을 걸고 필요한 자동 증가 값을 가가져오면 즉시 잠금이 해제된다.
    - 정확한 레코드건수를 알 수 없는 INSERT 에서는 `innodb_autoinc_lock_mode = 0` 처럼 자동증가락을 사용한다. (`INSERT ... SELECT ...`)
    - 이때는 INSERT 문장이 완료되기 전까지 자동증가 락은 해제되지 않기 때문에 다른 커넥션에서는 INSERT를 시키지 못하고 대기하게 된다.
    - 이렇게 대량 INSERT가 수행될때는 InnoDB 스토리지 엔진은 여러 개의 자동증가 값을 한 번에 할당받아서 INSERT되는 레코드에 사용한다.
    - 그래서 대량 INSERT 되는 레코드는 자동 증가 값이 누락되지 않고 연속되게 INSERT 된다.
    - 하지만 한번에 할당받은 자동 증가 값이 남아서 사용되지 못하면 폐기하므로 대량 INSERT 문장의 실행 이후에 INSERT되는 레코드의 자동 증가 값은 연속되지 않고 누락된 값이 발생할 수 있다.
    - 이 설정에서 최소한 대량 INSERT의 문장으로 INSERT되는 값은 연속된 값을 가지므로 이 설정을 연속모드 라고도 한다.
- `innodb_autoinc_lock_mode = 2`
    - InnoDB 스토리지 엔진이 절대 자동 증가 락을 걸지 않고 경량화된 래치를 사용한다.
    - 하지만 이 설정에서는 하나의 INSERT문장으로 INSERT되는 레코드라고 하더라도 연속된 자동 증가 값을 보장하지는 않는다.
    - 그래서 이 설정을 인터리빙 모드 라고 한다.
    - `INSERT ... SELECT ...` 같은 대량 INSERT 문장이 실행되는 중에도 다른 커넥션에서 INSERT를 수행할 수 있다. → 동시 처리 성능이 높아진다.
    - 그러나 이 설정에서 작동하는 자동 증가 기능은 유니크한 값이 생성된다는 것만 보장한다.
    - STATEMENT 포맷의 바이너리 로그를 사용하는 복제에서는 소스 서버와 레플리카 서버의 자동 증가 값이 달리질 수도 있기 때문에 주의해야한다.
- 5.7버전까지 `innodb_autoinc_lock_mode = 1` 가 기본설정 이었다.
- 8.0부터는 `innodb_autoinc_lock_mode = 2` 가 기본설정 이다.
    - STATEMENT 포맷의 바이너리 로그를 사용한다면 `innodb_autoinc_lock_mode = 1` 을 권장한다.

### 인덱스와 잠금

- InnoDB의 잠금과 인덱스는 상당히 중요한 연관관계가 있다.
- InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다.
- `UPDATE employees SET hire_date=NOW() WHERE first_name=’Georgi’ AND last_name=’Llassen’`
    - `first_name=’Georgi’` 에 해당하는 레코드는 253개
    - `last_name=’Llassen’` 에 해당하는 레코드는 1개다
    - 이 업데이트 문이 실행되려면 253개의 레코드가 잠긴다.
    - 인덱스가 하나도 없다면 모든 레코드를 잠그게 된다.
- → 인덱스 설계가 중요하다.

### 레코드 수준의 잠금 확인 및 해제

- MySQL 5.1버전부터는 레코드 수준의 잠금과 잠금 대기에 대한 조회가 가능하다.
- 필요할때 p173을 읽어보자

## MySQL의 격리수준

- 트랜잭션의 격리수준이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.
- `READ UNCOMMITED` `READ COMMITED` `REPEATABLE READ` `SERIALIZABLE` 이 있는데 동시성이 중요한 데이터베이스에서는 `SERIALIZABLE` 이 잘 사용되지 않는다.
    - `SERIALIZABLE` 이 아니라면 MySQL서버의 처리 성능이 크게 저하되지 않는다.

### READ UNCOMMITED

- `READ UNCOMMITED` 격리수준에서는 COMMIT이나 ROLLBACK 여부와 상관없이 다른 트랜잭션에서 보인다.
- 더티 리드(Dirty Read)가 발생한다.
    - (존재하지 않는 데이터가 생겼다 없어졌다함)
    1. 트랜잭션 A에서 직원1을 인서트
    2. 트랜잭션 B에서 직원1을 읽음 → 정상 직원으로 판단하고 다른 작업을 함
    3. 트랜잭션 A가 롤백됨
- 권장되지 않는다.

### READ COMMITED

- 더티 리드가 발생하지 않는다.
- 사용자가 데이터를 변경중이라면 다른 사용자는 언두영역에서 데이터를 읽어온다.
- NON-REPEATABLE READ 가 발생한다.
    - (하나의 트랜잭션 내에서 똑같은 SELECT쿼리를 실행했을때 같은 결과가 나오지 않을수 있음)
    1. 트랜잭션 A에서 이름이 Toto인 직원을 검색 → 0건
    2. 트랜잭션 B에서 이름이 Toto인 직원을 삽입
    3. 트랜잭션 A에서 이름이 Toto인 직원을 검색 → 1건
- 웹프로그래머에게는 큰 문제가 되지 않지만 금전적인 처리와 연결되면 문제가 될 수 있다.

### REPEATABLE READ

- InnoDB에서 기본적으로 사용되는 격리수준이다. (바이너리 로그를 가진 MySQL서버에서는 최소 `REPEATABLE READ` 를 사용해야한다.)
- NON-REPEATABLE READ 가 발생하지 않는다.
- InnoDB의 모든 트랜잭션은 고유한 트랜잭션 번호를 갖는다.
    - 언두영역의 데이터는 InnoDB스토리지 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제된다.
    - 가장 오래된 트랜잭션 번호보다 앞선 언두 영역의 데이터는 삭제할 수 없다.
- `SELECT ... FOR UPDATE` , `SELECT ... FOR SHARE` 를 제외하고 PHANTOM READ가 발생하지 않는다. (언두 레코드에는 잠금을 걸 수 없어서)

### SERIALIZABLE

- 가장 단순하면서 가장 엄격한 격리수준이다.
- 동시 처리 성능이 떨어진다.
- 읽기 작업도 공유 잠금을 휙득해야 한다.
- PHANTOM READ가 전혀 발생하지 않는다.
