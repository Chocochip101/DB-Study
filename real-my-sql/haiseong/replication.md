
# 복제

- 확장성 : 대용량 트래픽을 안정적으로 처리하기 위해서
- 가용성 : 사용자가 언제든지 안정적인 서비스를 이용할 수 있게 하기 위해서

## 16.1 개요
- 소스 서버 (Source) : 원본 데이터를 가진 서버
    - 데이터, 스키마 변경이 최초로 발생
- 레플리카 서버 (Replica) : 복제된 데이터를 가지는 서버
    - 변경 내역을 소스 서버로 부터 받아 반영

복제의 목적
- 소스 서버에 문제가 생겼을때를 대비
- 스케일 아웃
    - 아무리 사양이 좋은 서버라도 트래픽이 많아지면 한계가 있음
- 데이터 백업
    - 백업 작업을 소스서버에서 하면 서비스에 문제가 생길 수 있음
    - 백업 작업은 레플리카 서버에서 실행
- 데이터 분석
    - 백업과 마찬가지 이유로 레플리카 서버에서 데이터 분석 작업을 함
- 데이터의 지리적 분산
    - 사용자에게 빠른 응답 속도를 제공하기 위해

## 16.2 복제 아키텍처

- 모든 변경 사항은 별도의 로그 파일에 순서대로 기록됨 (바이너리 로그 (Binary Log))
    - 바이너리 로그에는 데이터의 변경, 데이터베이스와 테이블 구조 변경, 계정 권한 변경 정보가 모두 저장됨
    - 이벤트(Event) : 각 변경 정보를 
- MySQL 복제는 바이너리 로그를 기반으로 구현
    - 소스 서버에서 생성된 바이너리 로그가 레플리카 서버로 전송
    - 레플리카 서버에서는 로컬 디스크에 저장 후 자신이 가진 데이터에 반영
    - 릴레이 로그(Relay Log) : 소스 서버의 바이너리 로그를 읽어 들여 로컬 디스크에 저장해둔 파일

### 복제를 담당하는 스레드
#### 바이너리 로그 덤프 스레드 (소스 서버)
- 레플리카 서버가 연결될 때 바이너리 로그 덤프 스레드를 생성
- 바이너리 로그를 레플리카 서버로 전송
- 레플리카 서버로 보낼때 각 이벤트를 읽을 때 일시적으로 바이너리 로그에 잠금을 수행 함
- 읽은 후 바로 잠금을 해제
- SHOW PROCESSLIST 를 이용해 확인
#### 레플리케이션 I/O 스레드 (레플리카 서버)
- 복제가 시작되면 레플리카 서버는 I/O 스레드를 생성 (START REPLICA(=SLAVE))
- 복제가 끝나면 I/O 스레드가 종료 (STOP REPLICA(=SLAVE))
- 소스 서버의 바이너리 로그를 읽어서 파일로 쓰는 역할
- SHOW REPLICA(=SLAVE) STATUS 로 확인
#### 레플리케이션 SQL 스레드
- I/O 스레드에 의해 작성된 릴레이 로그 파일의 이벤트들을 읽고 실행한다.
- SHOW REPLICA(=SLAVE) STATUS 로 확인
    

- 레플리카 서버에서 레플리케이션 I/O 스페드와 SQL 스레드는 서로 독립적으로 동작함
- 레플리카 서버에 문제가 생겨도 소스 서버는 영향이 전혀 없음
- 소스 서버에 문제가 생기면 레플리카 서버의 I/O 스레드가 정상 동작할 수 없음
    - 복제는 에러를 발생시키고 바로 중단
    - 복제기능은 중단 되었지만 레플리카 서버가 쿼리를 처리하는데는 문제가 없음
    - 예전 상태의 데이터를 보지 못함

### 레플리카 서버가 생성 관리하는 데이터
- 릴레이 로그
    - 레플리케이션 I/O 스레드에 의해 작성
    - 소스 서버의 바이너리 로그에서 읽어온 이벤트(트랜잭션) 정보를 저장
    - 현재 존재하는 릴레이 로그 파일들의 목록이 담긴 인덱스와 실제 이벤트 정보가 저장돼 있는 로그 파일들로 구성
    - 릴레이 로그에 저장된 트랜잭션 이벤트들은 래플리케이션 SQL에 의해 레플리카 서버에 적용됨
- 커넥션 메타데이터 
    - I/O 스레드에서 소스 서버에 연결할 때 사용하는 DB 계정 정보 및 현재 읽고 있는 소스 서버의 바이너리 파일명과 파일 내 위치 값 등이 담김 (mysql.slave_master_info 테이블에 저장)
- 어플라이어 메타데이터
    - 어플라이어 : 레플리케이션 SQL 스레드에서 릴레이 로그에 저장된 소스 서버의 이벤트들을 레플리카 서버에 적용하는 컴포넌트
    - 최근 적용된 이벤트에 대해 해당 이벤트가 저장돼 있는 릴레이 로그 파일명과 파일 내 위치 정보를 담음
    - SQL스레드가 이 정보들을 바탕으로 레플리카 서버에 나머지 이벤트들을 적용 (mysql.slave_relay_log_info 에 저장)


- 커넥션, 어플라이어 메타데이터는 master_info_repository와 relay_log_info_repository 시스템 변수로 어떤 형태로 관리될지 선택 가능 
    - FILE
        - 파일로 관리됨
        - I/O 스레드와 SQL 스레드가 동작할 때 동기화 되지 않던 문제가 빈번하게 발생했었음
    - TABLE
        - 8.0.2 버전부터 기본값
        - 테이블에 각각의 데이터가 생성
        - MySQL이 갑자기 종료되어도 다시 구동했을때 문제없이 복제가 진행 (세이프 복제)

## 16.3 복제타입

### 바이너리 로그 파일 위치 기반 복제
- 레플리카 서버에서 소스 서버의 바이너리 로그 파일명과 파일 내에서의 위치로 개별 바이너리 로그 이벤트를 식별
- 소스 서버에서 발생한 각 이벤트에 대한 식별이 반드시 필요함
    - 소스 서버의 어떤 이벤트로부터 동기화를 수행할 것인가에 대한 정보를 설정해야함.
    - 복제가 설정된 레플리카 서버는 소스 서버의 어느 이벤트까지 로컬 디스크로 가져왔고 또 적용했는지에 대한 정보를 관리함
    - 소스 서버에 해당 정보를 전달해 그 이후 바이너리 로그 이벤트를 가져옴
- 복제에 참여한 MySQL 서버들이 모두 고유한 server_id 값을 가져야함 (시스템 변수, 기본값 1)
- 바이너리 로그 파일에 기록된 이벤트가 레플리카 서버에 설정된 server_id 값과 동일한 server_id 값을 가지면 레플리카 서버에서  그 이벤트를 적용하지 않고 무시함 (자신의 서버에서 발생한 이벤트로 간주)
    - 모두가 고유한 server_id를 가져야함

#### 설정 준비
- 소스 서버
    - 고유한 server_id 설정
    - 데이터 디렉터리 아래 binlog 라는 이름로 바이너리 로그 파일이 자동 생성됨
    - 로그 동기화 방식, 바이너리 로그를 캐시하기 위한 메모리 크기, 바이너리 로그 파일 크기, 보관 주기를 지정 가능
    - SHOW MASTER STATUS : 소스 서버에 바이너리 로그가 정삭적으로 기록되는지 확인
        - File 이름과 Position(실제 파일의 바이트 수) 확인 가능
- 레플리카 서버
    - 고유한 server_id 설정
    - relay_log 시스템 변수 : 릴레이 로그 파일 위치, 파일명 설정 가능
        - relay_log_purge : 릴레이 로그가 자동으로 삭제되지 않게함 (기본은 레플리카 서버에 적용된 후 자동으로 삭제됨)
    - read_only 설정
    - log_slave_updates : 추후에 레플리카 서버가 소스 서버로 승격될 수 있음을 고려해 복제에 의한 데이터 변경 내용을 자신의 바이너리 로그에 기록
        - 기본적으로 레플리카 서버는 복제에 의한 데이터 변경 사항을 자신의 바이너리 로그에 기록하지 않음
    
#### 복제 계정 준비
- 소스 서버에 접속할 복제용 계정이 필요
- 반드시 REPLICATION SLAVE 권한이 필요함

#### 데이터 복사
- 데이터가 크지 않다면 mysqldump를 사용
    - --single-transaction 옵션 필수
        - 하나의 트랜잭션을 사용해 덤프 되도록함 (레코드에 잠금을 걸지 않고 InnoDB 테이블들에 대해 일관된 데이터를 덤프)
    -  --master-data 옵션 필수
        - 복제 설정구문(덤프 시작 시점의 소스 서버의 바이너리 로그 파일명과 위치 정보를 포함)이 덤프파일 헤더에 기록될 수 있게 함
        - mysqldump는 MySQL 서버에서 글로벌 락을 거는데 바이너리 로그의 위치를 순간적으로 고정시킴
        - 1 또는 2 옵션을 설정
            - 1 : 복제 설정 구문이 실제 실행 가능한 형태로 기록
            - 2 : 주석으로 처리되어 참조만 할 수 있는 형태로 기록
- 덤프가 완료되면 source_data.sql을 레플리카 서버로 옮겨 데이터 적재를 진행

#### 복제 시작
- mysqldump 시작 시점, 레플리카 서버 데이터 적재 완료 시점, 복제 시작 시점이 차이가 있음
    - mysqldump 시작 시점 (10:30)
    - 레플리카 서버 데이터 적재 완료 시점 (11:20)
    - 복제 시작 시점(11:45)
    - 레플리카 서버의 데이터는 소스 서버의 데이터보다 50분 지연된 상태임
- CHANGE REPLICATION SOUECE TO (CHANGE MASTER TO) : 복제 설정 명령어
    - SOURCE_HOST : 소스 서버의 IP / 도메인
    - SOURCE_USER / SOURCE_PASSWORD : 복제용 계정 정보
    - SOURCE_LOG_FILE / SOURCE_LOG_POS : 로그 파일명과 위치값
    - GET_SOURCE_PUBLIC_KEY : 공개키를 소스 서버에 요청할지 여부
- CHANGE REPLICATION SOUECE TO 을 수행하면 복제 관련 설정만 추가됨
- 실제 동기화를 사작하려면 START REPLICA (START SLAVE) 실행
    - 10:30 부터 11:45 까지의 데이터 변경사항들을 소스 서버로부터 가져와 적용
- SHOW REPLICA STATUS (SHOW SLAVE STATUS) 의 Seconds_Behind_Source의 값이 0이면 완전히 동가화 된것

#### 바이너리 로그 파일 위치 기반의 복제에서 트랜잭션 건너뛰기
- 소스 서버에서 넘어온 트랜잭션이 제대로 실행되지 못해 레플리카 서버에서 에러가 발생해서 복제가 멈추는 현상이 발생할 수 있다.
    - 대부분은 사용자의 실수로 인해 발생하는 경우가 많음 (중복 키 에러)
    - 보통 에러는 무시해도 되는 경우가 많다.
- sql_slave_skip_counter 시스템 변수를 이용해 문제되는 트랜잭션을 건너뛸 수 있다.
    - 1 : 현재 이벤트를 포함한 이벤트 그룹을 무시함


### 글로벌 트랜잭션 아이디(GTID) 기반 복제

바이너리 로그 파일 위치 기반 복제의 문제점
- (로그 파일명, 파일 내 위치 값) 이라는 조합은 소스 서버에서만 유효하고 레플리카 서버에서 동일하다는 보장이 없음
    - 동일한 이벤트인데 소스와 레플리카 에서 다른 식별값을 가짐
    - 일부 서버에 장애가 발생하여 토폴로지(노드들의 연결상태)를 변경할 때 토폴로지 변경이 어려움
    - 장애 복구가 어려움

#### GDID의 필요성
- 소스서버에서 발생한 이벤트들이 복제에 참여한 모든 MySQL 서버들에 동일한 고유 식별 값(글로벌 트랜잭션 아이디 : GTID)을 가지게 함
    - 손쉽에 토폴로지를 변경 가능
    - 장애 복구 시간 단축
- 소스 서버에 장애가 발생하면 레플리카 서버를 소스 서버로 승격시킴
    - 소스 서버의 (로그 파일명, 파일 내 위치 값) 이 식별자가 아닌 GTID를 기반이므로 아직 동기화 되어있지 않았던 다른 레플리카가 새롭게 승급한 소스서버의 내용으로 복제를 할 수 있음 

#### 글로벌 트랜잭션 아이디
- GTID는 논리적인 식별자다.
- MySQL의 GTID는 각 트랜잭션과 연결된 고유 식별자 이므로 그 서버가 속한 복제 토폴로지 내 모든 서버에서 고유하다.
- GTID는 커밋되어 바이너리 로그에 기록된 트랜잭션에 한해서만 할당된다.
    - SELECT 또는 sql_log_bin이 비활성화 되어있다면 GTID가 할당되지 않는다.
- 소스 아이디와 트랜잭션 아이디 값의 조합으로 생성된다.
    - GTID = (source_id):(transaction_id)
    - server_id
        - 소스 서버를 식별하는값
        - server_uuid 시스템 변수를 사용한다.
            - 사용자가 별도로 설정하는 값이 아님
            - MySQL 서버가 시작될 때 자동으로 부여 (auto.cnf에 저장)
-  GTID는 grid_executed 테이블을 조회하거나 gtid_executed 시스템 변수를 통해 확인 가능하다. SHOW MASTER STATUS 명령으로도 조회 가능하다.
- GTID 셋
    - 동일한 서버에서 생성된 연속하는 GTID 값을 축소시켜 범위로 보여준다.
    - 같은 서버에서 생성된 GTID는 '-'로 구분
    - 같은 서버에서 생성된 단일값과 연속값들은 ':'로 구분
    - 다른 서버에서 생성된 값들은 ','로 구분한다.
- mysql.gtid_excuted 테이블
    - GTID 값을 저장
    - 레플리카에서 바이너리 로그가 비활성 된 상태에서 GTID 기반의 복제를 사용할 수 있게함
    - 예기치 못한 문제로 바이너리 로그가 손실됐을 때 GTID 값이 보존될 수 있게 함
    - 8.0.17 이전 버전을 쓰거나 InnoDB 스토리지 엔진을 사용하지 않으면 MySQL 서버가 종료되는 시점에만 gtid_executed 테이블에 GTID를 저장한다.
    - MySQL 서버는 주기적으로 이 테이블을 압축한다. (여러 레코드로 저장된 interval_start와 interval_end를 연속된 것 끼리 모음)
        - 압축 수행 시점은 조건에 따라 달라짐 (p452 참고)

#### 글로벌 트랜잭션 아이디 기반 복제 구축 준비
- GTID를 활성화 하는것은 GTID 기반 복제의 필요조건일 뿐이다.
- 모든 서버들이 GTID가 활성화돼 있어야한다.
- 각 서버의 server_id, server_uuid가 고유해야한다.
- gtid_mode=ON 과  enforce_gtid_consistency=ON 을 명시해야 한다.
- 관리자 계정은 모든 권한이 할당되어 있는 경우가 많아 레플리카에 read_only 외에 super_read_only도 설정해주는게 좋다.

#### 데이터 복사
- mysqldump를 사용해 데이터를 덤프한다.
- 레플리카 서버에 다음 두변수를 설정해야한다.
    - gtid_executed
        - 서버에서 실행되어 기록된 모든 트랜잭션들의 GTID 셋
        - 읽기 전용이라 사용자가 변경 불가
    - gtid_purged
        - 서버의 바이너리 로그에 존재하지 않는 모든 트랜잭션의 GTID 셋
        - 처음에 서버를 실행하면 gtid_executed와 gtid_purge 모두 비어있는데 이 값을 수정하면 gtid_excuted도 동일한 값이 설정된다.
        - --set-gtid-purged 옵션으로 설정
        - 명시 안하면 AUTO 값으로 자동 설정 (옵션은 p456 참고)
    - sql_log_bin 시스템 변수 비활성화 : 레플리카 서버에서 새로운 GTID를 할당 받는걸 방지
        - 바이너리 로그에 덤프파일을 적재하면 GTID가 할당되므로 이를 막음

#### 복제 시작
- SOURCE_AUTO_POSITION 옵션이 들어가있음
    - SOURCE_LOG_FILE과 SOURCE_LOG_POS은 바이너리 로그 위치 기반 방식

#### GTID 기반 복제에서 트랜잭션 건너뛰기
- sql_slave_skip_counter 시스템 변수 사용 중단
- GTID 기반 복제에서 레플리카는 기본적으로 자신의 GTID 값과 소스의 GTID 값을 비교해서 소스 서버의 변경 이벤트를 가져옴
    - 레플리카 서버가 소스 서버의 GTID 값보다 더 적거나 많을 수 없음
- 소스의 트랜잭션을 무시하고 싶다면 수동으로 빈 트랜잭션을 만들어 GTID 값을 만들어야한다.
    - 복제를 멈추고 빈 트랜잭션을 만들어 바이너리 로그 스트림에 밀어넣는다.

### Non-GTID기반 복제에서 GTID 기반 복제로 온라인 변경
- Non-GTID기반 복제에서 GTID 기반 복제를 온라인으로 전환할 수 있는 기능을 제공한다.
- 반대도 가능하다.
- 필요할때 p462~p468 참고

## 16.4 복제 데이터 포멧

### Statement 기반 바이너리 로그 포멧
- 이벤트를 발생시킨 SQL문을 바이너리 로그에 기록하는 방식

#### 장점
- 용량이 작아지므로 저장공간 부담이 준다.
- 원격으로 백업 혹은 복제시 빠르게 처리 가능

#### 단점
- 비확정적으로 처리되는 쿼리에서 소스 서버와 레플리카 서버 간에 데이터 불일치
    - DELETE/UPDATE에서 ORDER BY 없이 LIMIT 사용
    - SELECT ... FOR UPDATE, SELECT ... FOR SHARE 에서 NOWAIT, SKIP LOCKED 사용
    - LOAD_FILE(), UUID(), UUID_SHORT(), USER(), FOUND_ROWS(), RAND(), VERSION() 등과 같은 함수
    - 동일한 파라미터여도 값이 다를수 있는 UDF나 스토어드 프로시져
- 복제시 락을 많이건다.
    - INSERT INTO ... SELECT
    - 적절한 인덱스가 없이 UPDATE 하는 경우
- 트랜잭션 격리 수준이 반드시 REPEATABLE READ 이상이어야 한다.

### Row 기반 바이너리 로그 시스템
- 데이터가 변경되었을때 변경된 값 자체가 바이너리 로그에 기록됨
- 5.7.7 버전부터 바이너리 로그의 기본 포멧이다.
- DDL 문은 전부 STATEMENT 포멧 형태로 기록된다.

#### 장점
- 변경된 데이터가 그대로 바이너리 로그에 기록된다.
    - 비확정성 함수를 사용했더라도 레플리카 서버는 함수의 결과값을 전달받아 처리되므로 안전하게 복제 가능
- 락이 최소화되어 처리된다.
- 모든 트랜잭션 격리수준에서 사용 가능하다.

#### 단점
- 변경된 데이터가 그대로 바이너리 로그에 기록된다.
    - 실행한 쿼리가 많은 데이터를 변경한 경우 데이터가 전부 기록되어 로그 파일이 매우 커질 수 있다.
    - BLOB 같은 형태의 큰 값이 저장되거나 변경되는 경우 마찬가지로 파일 크기가 커진다.
    - 레플리카 입장에서 어떤 쿼리가 소스 서버로부터 넘어온것인지 육안으로 바로 확인 불가능하다.
        - mysqlbinlog에 -v 옵션으로 유사 SQL 형태로 보여준다.

### Mixed 포멧
- 두가지 바이너리 로그 포맷을 혼합해서 사용하도록 설정
- 기본으로는 Statement 포맷을 사용, 실행된 쿼리에 따라 (비확정성 쿼리는) Row 포맷 사용

### Row 포맷의 용량 최적화
- Row 포맷의 가장 큰 단점은 용량이다.

#### 바이너리 로그 Row 이미지
- binlog_row_image 시스템 변수 
    - Row 포맷을 사용하면 각 변경 데이터마다 변경 전/후 레코드가 함께 저장된다.
    - 각 변경 전후 레코드들에 대해 테이블의 어떤 칼럼을 기록할 것인지를 결정한다.
- `full`
    - 기본값
    - 모든 칼럼들의 값을 바이너리 로그에 기록
        - INSERT의 경우 새롭게 INSERT된 레코드의 모든 칼럼들만 로그 파일에 기록
        - UPDATE의 경우 변경 전의 레코드와 변경 후의 레코드 모두 전체 칼럼들의 셋으로 로그에 기록
        - DELETE 문장의 경우 변경 전 레코드의 전체 칼럼들만 로그에 기록
- `minimal`
  - 변경 데이터에 대해 꼭 필요한 칼럼들의 값만 바이너리 로그에 기록
- `noblob`
  - full 옵션을 설정한 것과 동일하게 작동, 레코드의 BLOB이나 TEXT 칼럼에 대해 변경이 발생하지 않은 경우 해당 칼럼들은 기록하지 않음


#### 바이너리 로그 트랜잭션 압축
- MySQL 8.0.20 버전에서 Row 포맷으로 기록되는 트랜잭션에 대해 트랜잭션에서 변경한 데이터를 압축해서 바이너리 로그에 기록할 수 있게 하는 기능이 도입
    - 기존과 동일한 바이너리 로그 보관 주기를 유지하면서 이전보다 디스크 공간을 절약
    - 복제로 인해 소비되는 네트워크 대역폭 샤용량도 감소
- 트랜잭션에서 변경한 데이터들을 zstd 알고리즘을 사용해 압축 `transaction_payload_event`라는 하나의 이벤트로 로그에 기록
- 사용자는 시스템 변수를 통해 압축 기능을 활성화할 수 있고 압축 시 사용될 zstd 알고리즘 레벨을 설정 가능
- 바이너리 로그 트랜잭션 압축 기능을 사용하면 압축 처리로 인해 MySQL 내부적으로 오버헤드가 존재
    - CPU와 메모리 등 자원을 더 씀


## 복제 동기화 방식

### 비동기 복제(Asynchronous replication)
- 기본 방식이다.
- 소스 서버가 자신의 복제 연결된 레플리카 서버에서 변경 이벤트가 정상적으로 전달되어 적용됐는지를 확인하지 않음
- 비동기 복제 방식에서 소스 서버는 레플리카 서버로 변경 이벤트가 잘 전달됐는지 알지 못함
    - 소스 서버에 장애가 발생하면 소스 서버에서 최근까지 적용된 트랜잭션이 레플리카 서버로 전송되지 않을 수 있음 
- 더 빠른 성능
- 레플리카 서버에 문제가 생기더라도 소스 서버는 영향을 받지 않는다.
- 읽기 트래픽을 분산하는 용도로 좋음

### 반동기 복제(Semi-synchronous replication)
- 레플리카 서버가 소스 서버로부터 전달받은 변경 이벤트를 릴레이 로그에 기록후 받았다는 응답을 보내면 소스서버에서 트랜잭션을 완전히 커밋
- 적어도 하나의 레플리카 서버에는 해당 트랜잭션들이 전송됐음을 보장
- 실제로 복제된 트랜잭션이 레플리카 서버에 적용되는 것까지 보장하지 못함
- 설정 방법은 p490 참고

#### AFTER_SYNC 반동기 복제
- 기본방식
- 소스 서버에서 각 트랜잭션을 바이너리 로그에 기록하고 난 후 스토리지 엔진에 커밋하기 전 레플리카 서버의 응답을 기다림.
- 레플리카 서버로부터 정상적으로 응답이 내려오면 소스 서버는 스토리지 엔진을 커밋
- 트랜잭션에 대한 처리가 완전히 끝나면 트랜잭션을 실행한 클라이언트에 그 처리 결과를 반환한다.
    - 소스 서버에 장애가 발생했을 때 팬텀 리드가 발생하지 않음
    - 장애가 발생한 소스 서버에 대해 조금 더 수월하게 복구 처리가 가능

#### AFTER_COMMIT 반동기 복제
- 소스 서버에서 트랜잭션을 바이너리 로그에 기록후 스토리지 엔진에서의 커밋도 진행
- 클라이언트에 결과를 반환하기 전에 레플리카 서버의 응답을 기다림.
- 레플리카 서버로부터 응답을 받으면 그때 클라이언트는 처리 결과를 얻음

## 복제 토폴로지

### 싱글 레플리카 복제 구성
- 가장 기본적인 형태
- 레플리카 서버는 소스 서버의 장애 상황에서 사용될 수 있는 예비 서버 및 데이터 백업 수행을 하는 에비 용도로 사용하는게 좋음
- 애플리케이션 서버가 레플리카 서버에서도 읽기 쿼리를 실행하면 레플리카 서버에 문제가 발생한 경우 서비스 장애 상황이 도래 가능

![image](./src/img/싱글%20레플리카%20복제%20구성.png)


### 멀티 레플리카 복제 구성
- 하나의 소스 서버에 2개 이상의 레플리카 서버를 연결한 복제 형태
- 싱글 레플리카 복제 구성에서 추가적인 용도를 위해 여분의 레플리카 서버가 더 필요해졌을 때 자주 사용
    - 대부분 읽기 요청이 더 많으므로 멀티 레플리카 형태로 복제 구성을 전환해 읽기 요청 처리를 분산
- 배치나 통계, 분석 등 용도별로 하나씩 레플리카 서버를 나눠 전용으로 사용하는게 좋음
- 레플리카 서버 한 대는 예비용으로 남겨두는 것이 좋다. 
- 레플리카 서버로 서비스 읽기 요청이 들어오는 경우 소스 서버만큼 중요
    - 레플리카 서버도 장애가 발생했을 떄 최대한 빠르게 복구해야함


### 체인 복제 구성
- 1:M:M 구조임
- 멀티 레플리카 복제 구성에서 레플리카 서버가 너무 많아 소스 서버의 성능에 악영향이 예상된다면 고려
    - 소스 서버는 레플리카 서버가 요청할 때마다 계속 바이너리 로그를 읽어서 전달해야 함. 
    - 그래서 만약 하나의 소스 서버에 연결된 레플리카 서버 수가 맣다면 바이너리 로그를 읽고 전달하는 작업 자체가 부하임
    - 레플리카가 이 역할을 하게함
- 이 복제 형태는 MySQL 서버를 업그레이드 하거나 장비를 일괄 교체할 떄도 사용


### 듀얼 소스 복제 구성
- 두 개의 MySQL 서버가 서로 소스 서버이자 레플리카 서버로 구성
- 두 MySQL 서버 모두 쓰기가 가능
- 각 서버에서 변경한 데이터는 복제를 통해 다시 각 서버에 적용되므로 양쪽에 쓰기가 발생하지만 두 서버는 서로 동일한한 데이터를 갖는다
- 목적에 따라 두 MySQL 서버를 ACTIVE-PASSIVE, ACTIVE-ACTIVE 형태로 사용할 수 있다.
    - ACTIVE-PASSIVE
        - 하나의 MySQL 서버에서만 쓰기를 수행
        - 다른 쓰기 서버에 문제가 발상핼 시 바로 예비용 서버로 쓰기 작업을 전환할 수 있는 점이 다르다.
    - ACTIVE-ACTIVE
        - 두 서버에 모두 쓰기 작업을 수행
        - 거리가 매우 떨어진 위치의 쓰기 요청도 잘 처리가능
        - 동일한 데이터에 대해 변경 트랜잭션이 각 MySQL 서버에 동시점에 유입되는 경우 예상하지 못한 방향으로 데이터가 처리될 수 있다. 
        - ACTIVE-ACTIVE 형태에서 동일한 시점에 유입되는 경우 중복 키 에러가 발생할 수 있다.
            - 테이블의 Auto-Increment 키 사용을 하지않고 애플리케이션 단에서 글로벌하게 값을 생성해서 사용하는 것이 좋음 (근데 어플리케이션 서버도 여러대라면?)


### 멀티 소스 복제 구성
- 하나의 레플리카 서버가 둘 이상의 소스 서버를 갖는 형태
- 다음 목적에서 쓰인다.
    - 여러 MySQL 서버에 존재하는 각기 다른 데이터를 하나의 MySQL 서버로 통합
    - 여러 MySQL 서버에 샤딩돼 있는 테이블 데이터를 하나의 테이블로 통합
    - 여러 MySQL 서버의 데이터들을 모아 하나의 MySQL 서버에서 백업을 수행
- 멀티 소스 복제 구축은 p506 참고
