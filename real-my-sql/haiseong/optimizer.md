
# 옵티마이저와 힌트

## 9.1
옵티마이저 : 쿼리의 실행 계획을 수립함.

### 쿼리 실행 절차
1. [파싱], SQL 문장을 분리한다. (파스 트리)

2. [최적화 및 실행계획 수립] 파스 트리를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 결정한다. (실행계획 생성)
    - 불필요한 조건 제거 및 복잡한 연산의 단순화
    - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
    - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
    - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정

3. 2번 단계에서 결정된 테이블의 읽기 순서나 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

1, 2번 은 MySQL엔진에서 처리, 3번은 MySQL 엔진과 스토리지 엔진이 동시에 참여

### 옵티마이저의 종류

- 비용 기반 최적화 (Cost-based optimizer, CBO)
    - 쿼리를 처리하기 위한 여러가지 가능한 방법을 만들고 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출
    - 현재 대부분 DBMS가 채택

- 규칙 기반 최적화 (Rule-based optimizer)
    - 옵티마이져에 내장된 우선순위에 따라 실행 계획을 수립
    - 거의 사용되지 않음

## 9.2 기본 데이터 처리

### 풀 테이블 스캔과 풀 인덱스 스캔

풀 테이블 스캔을 선택하는 경우
- 테이블의 레코드 건수가 너무 작음
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우

풀 테이블 스캔은 많은 디스크 읽기가 필요하다. 
-  대부분 DBMS는 풀 테이블 스캔을 실행할 때 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능을 내장하고 있다. 
- InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터가 읽히면 백그래안드 스레드에 의해 리드 어헤드 작업이 자동으로 시작된다. (MyISAM은 없다) 
    - 리드 어헤드 : 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 버퍼 풀에 가져다 두는 것
    - 풀 테이블 스캔이 실행되면 처음 몇개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다.
    - 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 상당히 빨리 처리된다.
    - innodb_read_ahead_threshold 라는 변수를 낮게 설정해 더 빨리 리드 어헤드를 유도할 수 있다.

- 풀 인덱스 스캔에서도 리드 어헤드가 사용된다.

### 병렬처리
- innodb_parallel_read_threads 로 하나의 쿼리를 최대 몇개의 스레드를 이용해서 처리할지 설정 가능하다.

### ORDER BY 처리(Using filesort)

1. 인덱스 이용
- 장점 : 인덱스 순서대로 읽기만 하면 되므로 매우 빠르다.
- 단점 : CUD 작업시 부가적인 인덱스 작업이 필요하다, 인덱스 때문에 디스크 공간이 더 많이 필요하다.
2. Filesort 이용
- 장점 : 인덱스를 사용하지 않아도 되므로 공간이 많이 필요하지 않다, 정렬해야 할 레코드가 많지 않으면 충분히 빠르다.
- 단점 : 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 느리다.

모든 인덱스를 이용하도록 튜닝하는것은 어렵다.
- 정렬 기준이 너무 많아서 요건별로 모든 인덱스를 생성하는것이 불가능한 경우
- GROUP BY 의 결과 또는 DISTINCT 같은 처리의 결과를 정렬하는 경우
- UNION의 결과같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

소트 버퍼
- 정렬을 수행하기 위한 메모리 공간
- 정렬이 필요할때만 할당되고 가변적으로 증가, 최대 가능 크기 설정가능 (sort_buffer_size), 작업 완료시 시스템으로 반납
- 정렬할 레코드가 소량이면 빠르게 처리
- 정렬할 레코드의 건수가 소트 버퍼로 할당된 공간보다 크면 임시 저장을 위해 디스크를 사용한다. (메모리에서 정렬하고 디스크에 저장하는 방법을 반복해 병합정렬을 함 = 멀티 머지)
- 소트 버퍼를 크게 설정해도 크게 설정해도 크게 성능이 개선되지 않는다. (운영체제가 메모리 부족 현상으로 프로세스를 강제종료 할 수 있음)

정렬 알고리즘
- 옵티마이저 트레이스 기능으로 어떤 정렬 모드를 사용하는지 확인할 수 있다. (p291 참고)
- 정렬 방법은 3가지다.
    - <sort_key, rowid> : 정렬 키와 로우 아이디만 가져와서 정렬하는 방식 (투 패스 정렬 방식)
    - <sort_key, addirional_fields> : 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드의 칼럼들은 고정 사이즈로 메모리 저장 (싱글 패스 정렬 방식)
    - <sort_key, packed_addirional_fields> : 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드의 칼럼들은 가변 사이즈로 메모리 저장 (싱글 패스 정렬 방식)


싱글 패스 정렬 방식
- 처음 테이블을 읽을 때 정렬에 필요하지 않은 칼럼까지 전부 읽어 소트 버퍼에 담고 정렬을 수행

투 패스 정렬 방식
- 정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 프라이머리 키로 테이블을 읽어서 SELECT할 칼럼을 가져오는 정렬 방식이다.

비교
- 투 패스 방식은 테이블을 두 번 읽어야 하기 때문에 상당히 불합리 하다.
- 싱글 패스 방식은 더 많은 소트 버퍼 공간이 필요하다.
- 최신버전에서는 일반적으로 싱글 패스 방식을 주로 사용한다.
- 다음의 경우 MySQL 서버는 투 패스 정렬 방식을 사용한다.
    - 레코드의 크기가 max_length_for_sort_data 시스템 변수에 설정된 값보다 클 때
    - BLOB이나 TEXT 타입의 칼럼이 SELECT 대상에 포함될 때
- 싱글 패스 방식은 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보이고 투 패스 방식은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적이라고 볼 수 있다.
- SELECT 쿼리에서 꼭 필요한 칼럼만 조회하도록 개발하자. 불필요한 칼럼을 SELECT 하지 않게 쿼리를 작성하는게 효율적이다.

정렬 처리 방법
- 쿼리에 ORDER BY가 사용되면 다음 3가지 방법 중 하나로 정렬이 처리된다. 일반적으로 아래로 갈수록 처리 속도는 떨어진다.
    - 인덱스를 사용한 정렬 : 실행 계획 표기 x
    - 조인에서 드라이빙 테이블만 정렬 : "Using filesort"
    - 조인에서 조인 결과를 임시테이블로 저장 후 정렬 : "Using temporary; Using filesort"
- 옵티마이저는 정렬 처리를 위해 우선적으로 인덱스를 이용할수 있는지 확인한다.
    - 이용가능하다면 별도의 Filesort없이 인덱스를 순서대로 읽어 결과를 반환한다.
- 인덱스를 이용할 수 없다면 WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리 할것이다. 옵티마이저는 정렬 대상 레코드를 최소화 하기 위해 다음 2가지 방법중 하나를 선택한다.
    - 조인의 드라이빙 테이블만 정렬한 다음 조인을 수행
        - 일반적으로 조인이 수행되면서 레코드 건수와 레코드의 크기는 거의 배수로 불어나기 때문에 가능하다면 이 방법으로 처리한다. (조인을 하면 보통 레코드 건수와 크기가 불어나기 때문에)
    - 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행

인덱스를 이용한 정렬
- ORDER BY에 명시된 칼럼이 드라이빙 테이블이에 속하고 ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.
- 해시 인덱스나 전문 검색 인덱스, R-Tree 인덱스 등에서는 인덱스를 이용한 정렬을 사용할 수 없다.
- 여러 테이블이 조인되는 경우에는 네스티드-루프(Nested-loop)방식의 조인에서만 이 방식을 이용할 있다.
- 이미 인덱스의 값이 정렬돼 있어 인덱스의 순서대로 읽기만 하면 된다.
    - ORDER BY 절이 없어도 정렬이 된다고 일부러 ORDER BY 절을 지우는건 좋지 않다. (MySQL은 한번 더 작업을 처리하지 않고 인덱스로 처리할 . 수있는 경우 부가적으로 불필요한 정렬 작업을 수행하지 않는다.)
- 조인이 사용된 쿼리의 실행 계획에 조인 버퍼가 사용되면 순서가 흐트러질 수 있다.

조인의 드라이빙 테이블만 정렬
- 조인을 실행하기 전에 드라이빙 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는것이 차선책이다.
- 이 방법으로 정렬이 처리되려면 조인에서 첫 번째로 읽히는 테이블의 칼럼만으로 ORDER BY 절을 작성해야 한다.

- ```sql
    SELECT * FROM employees e, salaries s
    WHERE s.emp_no = e.emp_no
        AND e.emp_no BETWEEN 100002 and 100010
    ORDER BY e.last_name
    ```
    - WHERE 절의 검색조건이 e의 프라이머리 키여서 검색시 작업량을 줄일 수 있다.
    - 드리븐 테이블의 조인 칼럼인 emp_no 칼럼에 인덱스가 있다.
    - 따라서 옵티마이져는 e를 드라이빙 테이블로 선택한다.
    - ORDER BY 절의 e.last_name이 드라이빙 테이블에 포함된 칼럼이다.
    - 옵티마이져는 드라이빙 테이블만 검색해서 정렬을 먼저 수행하고 그 결과와 s를 조인한다.

임시 테이블을 이용한 정렬
- 쿼리가 2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수도 있다.
- "인덱스를 이용한 정렬"과 "조인의 드라이빙 테이블만 정렬" 방법을 제외한 패턴에서는 항상 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬한다.
- ```sql
    SELECT * FROM employees e, salaries s
    WHERE s.emp_no = e.emp_no
        AND e.emp_no BETWEEN 100002 and 100010
    ORDER BY s.salary
    ```
    - 드리븐 테이블에 있는 칼럼으로 정렬을 해야하므로 조인된 데이터를 가지고 정렬할 수밖에 없다.

정렬 처리 방법의 성능 비교
- 웹 서비스용 쿼리에서는 ORDER BY와 LIMIT이 거의 필수로 사용된다.
- LIMIT은 테이블이나 처리 결과의 일부만 가져와 작업량을 줄여준다.
- 하지만 ORDER BY나 GROUP BY 같은 작업은 우선 조건을 만족하는 레코드를 모두 가져와서 정렬을 수행하거나 그루핑 작업을 해야 하므로 쿼리가 느려진다.

- 스트리밍 방식
    - 서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식 -> 첫 번째 레코드를 받기까지 빠른 응답 시간을 보장
    - LIMIT처럼 결과 건수를 제한하는 조건들은 쿼리의 전체 실행 시간을 상당히 줄여줄 수 있음
    - 인덱스를 사용한 정렬 방식만 해당됨
- 버퍼링 방식
    - ORDER BY, GROUP BY 같은 처리는 쿼리의 결과가 스트리밍되는 것이 불가능 -> 응답 속도가 느려짐
    - LIMIT처럼 결과 건수를 제한하는 조건이 있어도 성능 향상에 별로 도움이 되지 않음
    - 인덱스를 제외한 방법이 해당

```sql
-- tb_test1 레코드 100건, tb_test2 레코드 1,000건
-- tb_test1 건당 tb_test2 의 레코드가 10건씩 존재한다고 가정 
-- 두 테이블의 조인 결과는 1,000건 
 SELECT *
 FROM tb_test1 t1, tb_test2 t2
 WHERE t1.col1 = t2.col1
 ORDER BY t1.col2
 LIMIT 10;
 ```

- tb_test1이 드라이빙

    | 정렬 방법 | 읽어야 할 건수 | 조인 횟수 | 정렬해야 할 대상 건수 |
    |---------|-------------|--------|------------------|
    | 인덱스 사용 | test1:1건, test2:10건| 1번 | 0건|
    | 조인의 드라이빙 테이블만 정렬 | test1:100건, test2:10건| 1번 | 100건 |
    | 임시 테이블 사용 후 정렬 | test1:100건, test2:1000건| 100번 | 1000건 |

- tb_test2이 드라이빙

    | 정렬 방법 | 읽어야 할 건수 | 조인 횟수 | 정렬해야 할 대상 건수 |
    |---------|-------------|--------|------------------|
    | 인덱스 사용 | test1:10건, test2:10건| 10번 | 0건|
    | 조인의 드라이빙 테이블만 정렬 | test1:10건, test2:1000건| 10번 | 1000건 |
    | 임시 테이블 사용 후 정렬 | test1:100건, test2:1000건| 1000번 | 1000건 |

어느 테이블이 먼저 드라이빙되어 조인되는지도 중요하지만 어떤 정렬 방식으로 처리되는지는 더 큰 성능차이를 만든다.
- 가능하다면 인덱스를 사용한 정렬로 유도하고, 그렇지 못하다면 최소한 드라이빙 테이블만 정렬해도 되는 수준으로 유도하자.

### GROUP BY 처리
- HAVING : GROUP BY 결과에 대해 필터링 역할 수행
    - GROUP BY에 사용된 조건은 인덱스를 사용해서 처리될 수 없음, HAVING을 처리하려고 인덱스를 생성하거나 다른 방법을 고민할 필요 없음
- GROUP BY 작업은 타이트 인덱스 스캔 방법과 인덱스를 건너뀌면서 읽는 루스 인덱스 스캔 방법으로 나뉜다. 그렇지 못하면 GROUP BY 작업은 임시 테이블을 사용한다.

타이트 인덱스 스캔을 이용하는 GROUP BY
- 정렬과 마찬가지로 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때 GROUP BY 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리한다.
- 인덱스를 사용해서 처리된다 하더라도 Aggregation 함수 등의 그룹값을 처리해야 해서 임시 테이블을 필요할 때도 있다.
- GROUP BY가 인덱스를 통해 처리되는 쿼리는 이미 정렬된 인덱스를 읽는 것이므로 쿼리 실행 시점에 추가적인 정렬 작업이나 내부 임시 테이블은 필요하지 않다.
- 별도로 GROUP BY 관련 코멘트나 임시 테이블 사용 또는 정렬 관련 코멘트가 표시되지 않는다.

루스 인덱스 스캔을 이용하는 GROUP BY
- Using index for group-by 코멘트가 표시된다.
- ```sql
    -- 인덱스 : (emp_no, from_date)
    SELECT emp_no
    FROM salaries
    WHERE from_date='1985-03-01'
    GROUP BY emp_no
    ```
    - EXPLAIN을 찍어보면 type에 range라고 적혀있고, Extra에 Using index for group-by라고 적혀있다.
        1. (emp_no, from_date) 인덱스를 차례대로 스캔하면서 emp_no의 첫 번째 유일한 값 10001을 찾아낸다.
        2. (emp_no, from_date) 인덱스에서 emp_no가 10001 인 것 중에서 from_date 값이 '1985-03-01'인 레코드만 가져온다.  차례대로 스캔하면서 emp_no의 첫 번째 유일한 값 10001을 찾아낸다. 
        3. (emp_no, from_date) 인덱스에서 emp_no의 그다음 유니크한(그룹 키) 값을 가져온다.
        4. 3번 단계에서 결과가 없으면 처리를 종료하고, 결과가 있다면 2번 과정으로 돌아간다.
    - 루스 인덱스 스캔 방식은 단일 테이블에 대해 수행되는 GROUP BY 처리에만 사용할 수 있다.
    - 프리픽스 인덱스(칼럼값의 앞쪽 일부만으로 생성된 인덱스)는 루스 인덱스 스캔을 이용할 수 없다.
    - 인덱스 레인지 스캔에서는 유니크한 값의 수가 많을수록 성능이 향상되는 반면 루스 인덱스 스캔에서는 인덱스의 유니크한 값의 수가 적을수록 성능이 향상된다.
    - 루스 인덱스 스캔으로 처리되는 쿼리에서는 별도의 임시 테이블이 필요하지 않다.
    - 인덱스 스캔을 사용할 수 없는 쿼리 패턴
        - MIN(), MAX() 이외의 집합 함수 사용
        - GROUP BY에 사용된 칼럼이 인덱스 구성 칼럼의 왼쪽부터 일치하지 않음
        - SELECT 절의 칼럼이 GROUP BY와 일치하지 않으면 사용 불가

임시 테이블을 사용하는 GROUP BY
- GROUP BY의 기준 칼럼이 인덱스를 전혀 사용할 수 없을때 이 방법을 사용한다.
- Extra 칼럼에 Using temporary 메시지가 표시된다.
    - 8.0 이전버전까지는 GROUP BY가 사용된 쿼리는 그루핑 되는 칼럼을 기준으로 묵시적 정렬까지 수행했지만 8.0 부터는 묵시적 정렬이 실행되지 않는다.
    - GROUP BY가 필요한 경우 내부적으로 GROUP BY 절의 칼럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만들어서 중복 제거와 집합 함수 연산을 수행한다.
    - ```sql
        CREATE TEMPORARY TABLE ... (
        last_name VARCHAR(16),
        salary INT,
        UNIQUE INDEX ux_lastname (last_name)
        )
        ```
    - 다음 테이블에서 중복 체크를 하면서 INSERT 또는 UPDATE를 실행해 별도의 정렬 없이 GROUP BY가 처리된다.
    - 하지만 GROUP BY와 ORDER BY가 같이 사용되면 명시적으로 정렬 작업을 수행한다.
