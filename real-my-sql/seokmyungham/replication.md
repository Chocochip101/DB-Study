# 복제

데이터베이스를 사용하고 운영할 때 가장 중요한 두 가지 요소는 바로 `확장성(Scalability)`과 `가용성(Availability)`이다.
서비스에서 발생하는 대용량 트래픽을 안정적으로 처리하기 위해서는 데이터베이스 서버의 확장이 필수적이며, 사용자가 언제든지 안정적인
서비스를 이용할 수 있게 하려면 DBMS 서버를 포함한 하위 시스템들의 가용성이 반드시 뒷받침돼야 한다. 이 두 요소를 위해
가장 일반적으로 사용되는 기술이 바로 `복제(Replication)`다.
  
일반적으로 서비스에서 사용될 DB 서버를 구축할 때는 메인으로 사용될 `소스(Source)` 서버 한 대와 `레플리카(Replica)` 서버를 한 대 이상 함께 구축한다.
이는 서비스의 메인 DB 서버인 소스 서버에 문제가 생겼을 때를 대비하려는 목적이 제일 크지만 그 외에도 이처럼 복제를 통해 레플리카 서버를 구축하는 데는 여러가지 목적이 있다.

### 스케일 아웃(Scale-out)

`스케일 업` 방법은 애플리케이션 단의 큰 변화 없이 늘어난 트래픽을 처리할 수 있다는 장점이 있지만 일시적이라는 단점도 있다.
서버의 사양을 업그레이드한다 하더라도 한 대에서 처리할 수 있는 양에는 한계가 있기 때문이다.
  
만약 동일한 데이터를 가진 DB 서버를 한 대 이상 더 사용할 수 있다면 애플리케이션으로부터 실행되는 쿼리들을 분산시킬 수 있을 것이다. 이 같은 방법을 `스케일 아웃`이라고 하며 스케일 아웃은 스케일 업보다 갑자기 늘어나는 트래픽을 대응하는 데 훨씬 더 유연한 구조다. 복제를 통해 DB 서버를 스케일 아웃할 수 있으며, 이를 통해 서비스를 좀 더 안정적으로 운영할 수 있다.

### 데이터 백업

백업에 사용되는 툴들은 DBMS마다 종류와 방식이 다르지만 보통은 데이터가 저장돼 있는 DB 서버에서 백업 프로그램이 실행되어 백업을 진행한다. 동일한 서버 내에서 백업이 실행되는 경우, 백업 프로그램과 DBMS가 서버의 자원을 공유하기 때문에 서비스에 영향을 줄 수 있다. 때문에 주로 복제를 사용해 레플리카 서버를 구축하고, 데이터 백업은 레플리카 서버에서 실행한다. 이렇게 구축된 백업용 레플리카 서버는 소스 서버가 문제 생겼을 때를 대비한 대체 서버의 역할을 하기도 한다.

### 데이터 분석

DB 서버에서는 기본적으로 서비스에서 사용되는 쿼리들이 실행되지만 무거운 분석용 쿼리들을 실행하기도 한다. 이로 인해 서비스에서 사용되는 쿼리들이 영향을 받을 수 있으므로 복제를 사용해 여분의 레플리카 서버를 구축해 분석용 쿼리만 전용으로 실행될 수 있는 환경을 만드는 것이 좋다.

### 데이터의 지리적 분산

DB 서버와 애플리케이션 서버가 서로 떨어져 있는 경우 두 서버 간의 통신 시간은 거리만큼 비례해서 늘어난다. 사용자에게 빠른 응답 속도를 제공하려면 애플리케이션 서버와 DB 서버가 가깝게 위치하는 것이 좋다. 만약 떨어져 있는 DB 서버의 위치를 이동시키지 못한다면 복제를 사용해 애플리케이션 서버가 위치한 곳에 기존 DB 서버에 대한 레플리카 서버를 새로 구축해 사용함으로써 응답 속도를 개선할 수 있다.

## 복제 아키텍처

![image](https://github.com/user-attachments/assets/e87699b4-4ef5-428d-9e9a-551dbf0d36ec)

MySQL 서버에서 발생하는 모든 변경 사항은 별도의 로그 파일에 순서대로 기록되는데, 이를 `바이너리 로그(Binary Log)`라고 한다. 바이너리 로그에는 데이터의 변경 내역뿐만 아니라 데이터베이스나 테이블의 구조 변경과 계정이나 권한의 변경 정보까지 모두 저장된다. 바이너리 로그에 기록된 각 변경 정보들을 `이벤트`라고도 한다.
  
- 소스 서버에서 생성된 바이너리 로그가 레플리카로 전송
- 레플리카 서버에서는 해당 내용을 로컬 디스크에 저장하고 자신이 가진 데이터에 반영

위와 같은 과정으로 소스 서버와 레플리카 서버 간에 동기화가 이뤄진다.
  
레플리카 서버에서 소스 서버의 바이너리 로그를 읽어 따로 로컬 디스크에 저장해둔 파일을 `릴레이 로그(Relay Log)`라 한다.

- 바이너리 로그 덤프 스레드
  - 레플리카 서버는 데이터 동기화를 위해 소스 서버에 접속해 버이너리 로그 정보를 요청한다. 소스 서버에서는 레플리카 서버가 연결될 때 내부적으로 `바이너리 로그 덤프 스레드`를 생성해서 바이너리 로그의 내용을 레플리카 서버로 전송한다. 바이너리 로그 덤프 스레드는 레플리카 서버로 보낼 각 이벤트를 읽을 때 일시적으로 바이너리 로그에 잠금을 수행하며, 이벤트를 읽고난 후에는 바로 잠금을 해제한다.
- 레플리케이션 I/O 스레드
  - 복제가 시작되면 레플리카 스레드는 I/O 스레드를 생성하고, 복제가 멈추면 I/O 스레드는 종료된다. I/O스레드는 소스 서버의 바이너리 로그 덤프 스레드로부터 바이너리 로그 이벤트를 가져와 로컬 서버의 릴레이 로그로 저장하는 역할을 담당한다.
- 레플리케이션 SQL 스레드
  - 레플리케이션 I/O 스레드가 소스 서버로부터 가져온 바이너리 로그 이벤트들을 로컬 파일로 기록하는 역할이라면, 레플리케이션 SQL 스레드는 I/O 스레드에 의해 작성된 릴레이 로그 파일의 이벤트들을 읽고 실행한다.
 
레플리카 서버에서 I/O 스레드와 SQL 스레드는 서로 독립적으로 동작한다. 만약 SQL 스레드에서 이벤트를 적용하는 게 느리더라도 I/O 스레드는 그것과 무관하게 정상적으로 빠르게 소스 서버로부터 이벤트를 읽어올 수 있다. 또한 레플리카 서버에서 변경 사항을 적용하는 것은 소스 서버가 동작하는 것과 별개로 진행되므로 레플리카 서버에 문제가 생기더라도 소스 서버는 전혀 영향을 받지 않는다.
  
그러나 소스 서버에 문제가 생겨 레플리카 서버의 I/O 스레드가 정상적으로 동작하지 않게되면 복제는 에러를 발생시키고 즉시 중단된다. 하지만 이는 레플리카 서버의 복제 기능만 중단된 것이므로 여전히 레플리카 서버가 쿼리를 처리하는 데는 아무런 문제가 없다. 다만 레플리카 서버의 데이터는 소스 서버로부터 동기화되지 못하기 떄문에 예전 상태의 데이터를 보게 된다.

## 복제 타입

MySQL의 복제 타입은 `바이너리 로그 파일 위치 기반 복제`와 `글로벌 트랜잭션 ID 기반 복제`로 나뉜다.

### 바이너리 로그 파일 위치 기반 복제

MySQL에 복제 기능이 처음 도입됐을 때부터 제공된 방식으로, 레플리카 서버에서 소스 서버의 바이너리 로그 파일명과 파일 내에서의 위치로 개별 바이너리 로그 이벤트를 식별해서 복제가 진행되는 형태를 말한다.
  
이벤트 하나하나를 소스 서버의 바이너리 로그 파일명과 파일 내에서의 오프셋 조합으로 식별한다. 레플리카 서버에서는 이처럼 각 이벤트들을 식별하고 자신의 적용 내역을 추적함으로써 복제를 일시적으로 중단할 수 있으며 재개할 때도 자신이 마지막으로 적용했던 이벤트 이후의 이벤트들로부터 다시 읽어올 수 있다. 
  
이 떄 중요한 것은 복제에 참여한 MySQL 서버들이 모두 고유한 `server_id` 값을 가지고 있어야 한다는 점이다. 서버마다 원하는 값으로 설정할 수 있으며 기본값은 1이다. 만약 바이너리 로그 파일에 기록된 이벤트가 레플리카 서버에 설정된 `server_id` 값과 동일한 `server_id` 값을 가지는 경우 레플리카 서버에서는 해당 이벤트를 적용하지 않고 무시한다. 자신의 서버에서 발생한 이벤트로 간주해버리기 때문이다.

> 레플리카 서버가 소스 서버로부터 바이너리 로그를 가져오려면 소스 서버에 접속할 DB 계정이 필요하다. 복제에서 사용되는 계정의 비밀번호는 레플리카 서버의 커넥션 메타데이터에 평문으로 저장되므로 보안을 고려해서 복제에 사용되는 권한만 주어진 별도의 계정을 새로 생성해 사용하는 것이 좋다.

### 글로벌 트랜잭션 ID 기반 복제

MySQL 5.5 버전까지는 복제를 설정할 때 바이너리 로그 파일 위치 기반 복제 방식만 가능했다. 문제는 로그 파일명과 파일 내 위치 값 식별 조합이 바이너리 로그 파일이 저장돼 있는 소스 서버에서만 유효하다는 것이다. 동일한 이벤트가 레플리카 서버에서도 동일한 파일명의 동일한 위치에 저장된다는 보장이 없다. 한마디로 복제에 투입된 서버들마다 동일한 이벤트에 대해 서로 다른 식별 값을 갖게 되는 것이다.
  
이러한 문제는 복제 토폴로지를 변경하는 작업을 거의 불가능하게 만든다. 복제 토폴로지 변경은 주로 복제에 참여하는 서버들 중에서 일부 서버에 장애가 발생했을 때 필요한데, 토폴로지 변경이 어렵다는 것은 그만큼 복제를 이용한 장애 복구가 어렵다는 것을 의미한다.
  
소스 서버에서만 유효한 고유 식별 값이 아닌 복제에 참여한 전체 MySQL 서버들에서 고유하도록 각 이벤트에 부여된 식별 값을 `글로벌 트랜잭션 아이디(GTID)`라고 하며, 이를 기반으로 복제가 진행되는 형태를 GTID 기반 복제라 한다.

### GTID의 필요성

복제 구성이나 장애에 대한 복구 대책을 고민해본 사용자라면 누구나 바이너리 로그 파일의 위치 기반 복제 방식의 문제점을 알고 있다. 아래는 간단하게 우리가 자주 사용하는 복제 토폴로지 예시다.
  
하나의 소스 서버에 두 개의 레플리카 서버가 연결 돼 있는 복제 토폴로지다. 이러한 형태는 주로 레플리카 서버를 읽기 부하 분산 및 통계나 배치용으로 구성할 때 많이 사용한다.
  
현재 소스 서버 A의 바이너리 로그 위치는 `binary-log.000002:320`이며, 레플리카 서버 B는 완전히 동기화 되어 똑같이 `binary-log.000002:320` 바이너리 로그 이벤트까지 완전히 실행 완료된 상태다. B 서버는 SELECT 쿼리 분산용으로, C 서버는 배치나 통계용으로 사용되고 있었다. 그런데 레플리카 서버 C는 조금 지연이 발생해서 소스 서버의 `binary-log.000002:120` 위치까지만 복제가 동기화된 상태였다.

![image](https://github.com/user-attachments/assets/198da30f-5e1e-4b84-a857-c1f5ef62eb00)

그런데 이때 소스 서버인 A가 장애가 발생하면서 서버가 비정상적으로 종료됐다고 가정해보자. 그러면 레플리카 서버 B와 C 중에서 하나를 소스 서버로 승격하고, A 서버로 연결돼 있던 클라이언트 커넥션을 새로 승격된 소스 서버로 교체하고자 할 것이다. 이 때 당연히 완전히 동기화돼 있는 레플리카 서버 B를 소스 서버로 승격할 것이다. 이제 그럼 복제는 모두 끊어지고 B 서버로 사용자 트래픽이 유입되고 있다. 그러나 C 서버는 여전히 동기화되지 않은 상태여서 서비스에서 SELECT 용도로 사용할 수가 없는 상태다.

![image](https://github.com/user-attachments/assets/dc084921-3ff8-46a5-ab91-887d15abd12a)

B 서버가 새로운 소스 서버로 승격되면서 클라이언트의 쿼리 요청이 B 서버로 들어오기 시작하는데, 이미 B 서버는 SELECT 쿼리의 부하 분산용이었기 때문에 분산 SELECT 쿼리의 부하 분산용이었기 때문에 분산 SELECT 쿼리 처리와 더불어 기존 서스 서버의 역할까지 겹치면서 과부하 상태가 된다. C는 동기화가 되지 않은 상태여서 SELECT 쿼리를 옮길 수도 없고, A 서버가 종료돼 버렸으므로 복제를 최종 시점까지 동기화할 방법이 없다.

### GTID

GTID는 논리적인 의미로서 물리적인 파일의 이름이나 위치와는 전혀 무관하게 생성된다. MySQL의 GTID는 커밋된 각 트랜잭션과 연결된 고유 식별자로, 해당 트랜잭션이 발생한 서버에서 고유할뿐만 아니라 그 서버가 속한 복제 토폴로지 내 모든 서버에서 고유하다. GTID는 커밋되어 바이너리 로그에 기록된 트랜잭션에 한해서만 할당되며, 데이터 읽기만 수행하는 SELECT 쿼리나 혹은 sql_log_bin 설정이 비활성화돼 있는 상태에서 발생한 트랜잭션은 바이너리 로그에 기록되지 않으므로 GTID가 할당되지 않는다.
  
GTID는 소스 아이디와 트랜잭션 아이디 값의 조합으로 생성되고 :로 구분되어 표시된다. 현재 사용되고 있는 GTID 값을 확인하는 방법에는 여러 가지가 있는데, mysql 데이터베이스 내의 `gtid_executed 테이블`을 조회하거나 `gtid_executed 시스템 변수`를 통해 확인할 수 있따. 또한 SHOW MASTER STATUS 명령을 통해 GTID와 이에 상응하는 바이너리 로그 파일 및 위치 값을 같이 확인할 수도 있다.

## 복제 데이터 포맷

바이너리 로그에 이벤트가 어떤 포맷으로 기록되는지는 복제가 처리되는 과정에도 영향을 준다. 레플리카 서버의 소스 서버의 바이너리 로그 이벤트를 내부적으로 가공하지 않고 가져온 그대로 실행해서 데이터에 적용하기 떄문이다.
  
MySQL에서는 실행된 SQL문을 바이너리 로그에 기록하는 `Statement` 방식과 변경된 데이터 자체를 기록하는 `Row` 방식으로 두 종류의 바이너리 로그 포맷을 제공하며, 사용자는 `binlog_format` 시스템 변수를 통해 이 두가지 종류 중 하나로 설정하거나 혹은 혼합된 형태로 사용하도록 설정할 수 있다.

### Statement 기반 바이너리 로그 포맷

Statement 기반 바이너리 로그 포맷은 MySQL에 바이너리 로그가 처음 도입됐을 떄부터 존재해왔던 포맷으로, 앞서 언급한 바와 같이 변경 이벤트에 대해 이벤트를 발생시킨 SQL문을 바이너리 로그에 기록하는 방식이다. 하나의 SQL문은 여러 개의 데이터를 수정할 수 있는데 이 경우 Statement 포맷에서는 바이너리 로그에 SQL문 하나만 기록된다. 바이너리 로그는 변경 내역이 전부 저장되는 파일이므로 감사 등의 목적으로도 활용될 수 있는데, Statement 포맷을 사용하면 손쉽게 SQL문을 확인할 수 있으므로 감사에 더 용이하다고 할 수 있다.
  
몇 가지 단점들도 있다. 대표적인 단점은 비확정적으로 처리될 수 있는 쿼리가 실행된 경우 Statement 포맷에서는 복제 시 소스 서버와 레플리카 서버 간에 데이터가 달라질 수 있다는 점이다.

- DELETE/UPDATE 쿼리에서 ORDER BY 절 없이 LIMIT 사용
- SELECT ... FOR UPDATE 및 SELECT ... FOR SHARE 쿼리에서 NOWAIT이나 SKIP LOCKED 옵션 사용
- LOAD_FILE(), UUID(), UUID_SHORT(), USER(), FOUND_ROWS(), RAND(), VERSION() 등과 같이 함수를 사용하는 쿼리
- 동일한 파라미터 값을 입력하더라도 결괏값이 달라질 수 있는 사용자 정의 함수나 스토어드 프로시저를 사용하는 쿼리

Statement 포맷의 또 다른 단점은 Row 포맷으로 복제될 때보다 데이터에 락을 더 많이 건다는 점이다. INSERT INTO ... SELECT 구문이 대표적인 경우이고 그 외에 데이터 검색 조건으로 주어진 칼럼에 대해 적절한 인덱스가 테이블에 존재하지 않아 풀 테이블 스캔을 유발하는 UPDATE 쿼리가 실행된 경우 등이 있다.
  
Statement 기반 바이너리 로그 포맷은 또한 트랜잭션 격리 수준이 반드시 `REPEATABLE-READ` 이상이어야 한다는 제한사항이 있다. 그 이하 방식에서는 하나의 트랜잭션 내에서도 각 쿼리가 실행되는 시점마다 데이터 스냅샷이 달라질 수 있는데, 이로 인해 복제 시 소스 서버와 레플리카 서버의 데이터가 일치하지 않게 될 수 있으므로 Statement 포맷 사용이 허용되지 않는다.

### Row 기반 바이너리 로그 포맷

Row 기반 바이너리 로그 포맷은 MySQL 5.1버전부터 도입된 포맷으로, 데이터 변경이 발생했을 떄 변경된 값 자체가 바이너리 로그에 기록되는 방식이다. 어떤 형태의 쿼리가 실행됐든 간에 복제시 소스 서버와 레플리카 서버의 데이터를 일관되게 하는 가장 안전한 방식이다. 또한 5.7.7 버전부터는 바이너리 로그 기본 포맷으로 지정되었다.
  
Row 기반 바이너리 로그 포맷은 함수의 결괏값을 전달받아 처리되므로 Statement 기반 로그 포맷보다 더 안전한 복제와 최소화된 락만을 사용한다. 그런데 변경된 데이터가 그대로 바이너리 로그에 기록된다는 것은 큰 장점이자 단점이 된다. 만약 MySQL 서버에서 실행된 쿼리가 굉장히 많은 데이터를 변경한 경우에는 데이터가 전부 기록되므로 바이너리 로그 파일 크기가 단시간에 매우 커질 수 있따. 또한 변경된 데이터 수가 적더라도 BLOB 형태의 큰 값이 새로 저장되거나 변경되는 경우에는 마찬가지로 파일 크기가 많이 커질 수 있음을 유의해야 한다.
  
Row 포맷은 모든 트랜잭션 격리 수준에서 사용 가능하며, MySQL 서버의 바이너리 로그 포맷이 Row 포맷으로 설정돼 있다 하더라도 사용자 계정 생성과 권한 부여 및 회수, 테이블과 뷰, 트리거 생성과 같은 DDL문은 전부 Statement 포맷 형태로 바이너리 로그에 기록된다.

### Mixed 포맷

사용자는 MySQL 서버가 두 가지 바이너리 로그 포맷을 혼합해서 사용하도록 설정할 수 있다. MySQL 서버의 `binlog_format` 시스템 변수를 `MIXED` 값으로 지정하면 된다. MySQL 서버는 MIXED 포맷으로 설정되면 기본적으로는 Statement 포맷을 사용하며, 실행된 쿼리와 스토리지 엔진 종류에 따라 필요시 자동으로 Row 포맷으로 전환해서 로그에 기록한다. 쿼리의 경우 대부분 Statement 포맷으로 기록될 가능성이 높은데, 만약 실행된 쿼리가 Statement 포맷으로 기록되어 복제됐을 때 문제가 될 쿼리(비확정적) 형태라면 Row 포맷 형태로 변환되어 기록된다.
  
### Row 포맷 용량 최적화

사용자들이 Row 기반의 바이너리 포맷을 사용할지 망설이는 대표적인 이유는 바로 바이너리 로그 파일의 용량이 Statement 포맷을 사용할 때보다 많이 커질 수 있다는 점인데 MySQL은 Row 포맷 용량 최적화를 제공한다.

#### 바이너리 로그 Row 이미지

Row 포맷을 사용할 경우 바이너리 로그에는 각 변경 데이터마다 변경 전 레코드와 변경 후 레코드가 함께 저장되는데 `binlog_row image` 시스템 변수는 각 변경 전후 레코드들에 대해 테이블의 어떤 칼럼을 기록할 것인지를 결정한다.

- `full`
  - 모든 칼럼들의 값을 바이너리 로그에 기록하는 방식이다.
  - INSERT의 경우 새롭게 INSERT된 레코드의 모든 칼럼들만 로그 파일에 기록되며, UPDATE의 경우 변경 전의 레코드와 변경 후의 레코드 모두 전체 칼럼들의 셋으로 로그에 기록, DELETE 문장의 경우 변경 전 레코드의 전체 칼럼들만 로그에 기록
- `minimal`
  - 변경 데이터에 대해 꼭 필요한 칼럼들의 값만 바이너리 로그에 기록
- `noblob`
  - full 옵션을 설정한 것과 동일하게 작동하지만 레코드의 BLOB이나 TEXT 칼럼에 대해 변경이 발생하지 않은 경우 해당 칼럼들은 기록하지 않는다.
 
#### 바이너리 로그 트랜잭션 압축

MySQL 8.0.20 버전에서 Row 포맷으로 기록되는 트랜잭션에 대해 트랜잭션에서 변경한 데이터를 압축해서 바이너리 로그에 기록할 수 있게 하는 기능이 도입됐다. 따라서 사용자는 기존과 동일한 바이너리 로그 보관 주기를 유지하면서 이전보다 디스크 공간을 절약할 수 있게 됐으며, 복제로 인해 소비되는 네트워크 대역폭 샤용량도 줄일 수 있게 됐다.
  
MySQL 서버에서 바이너리 로그 트랜잭션 압축 기능이 활성화돼 있으면 트랜잭션에서 변경한 데이터들을 zstd 알고리즘을 사용해 압축한 뒤 `transaction_payload_event`라는 하나의 이벤트로 로그에 기록한다. 사용자는 시스템 변수를 통해 압축 기능을 활성화할 수 있고 압축 시 사용될 zstd 알고리즘 레벨을 설정할 수 있다.
  
바이너리 로그 트랜잭션 압축 기능을 사용하면 압축 처리로 인해 MySQL 내부적으로 오버헤드가 존재하며 CPU와 메모리 등의 서버 자원을 더 소모할 수 있다. 그에 따른 데이터 저장 소요시간이 추가로 소모될 수 있음을 유의해야 한다.

## 복제 동기화 방식

MySQL에서는 소스 서버와 레플리카 서버 간의 복제 동기화에 대해 두 가지 방식을 제공한다.

### 비동기 복제(Asynchronous replication)

MySQL의 복제는 기본적으로 비동기 방식으로 동작한다. 비동기 방식이란 소스 서버가 자신의 복제 연결된 레플리카 서버에서 변경 이벤트가 정상적으로 전달되어 적용됐는지를 확인하지 않는 방식을 말한다.
  
비동기 복제 방식에서 소스 서버는 레플리카 서버로 변경 이벤트가 잘 전달됐는지, 실제로 적용됐는지 알지 못하며 이에 대한 어떠한 보장도 하지 않는다. 이로 인해 소스 서버에 장애가 발생하면 소스 서버에서 최근까지 적용된 트랜잭션이 레플리카 서버로 전송되지 않을 수 있다. 
  
비동기 복제는 소스 서버가 레플리카 서버의 동기화 여부를 보장하지 않는다는 것이 가장 큰 단점이지만 트랜잭션 처리에 있어서도 좀 더 빠른 성능을 보이고, 아울러 레플리카 서버에 문제가 생기더라도 소스 서버는 아무런 영향도 받지 않는다는 장점이 있다. 따라서 레플리카 서버를 확장해서 읽기 트래픽을 분산하는 용도로 제격이다. 

### 반동기 복제(Semi-synchronous replication)

반동기 복제에서 소스 서버는 레플리카 서버가 소스 서버로부터 전달받은 변경 이벤트를 릴레이 로그에 기록 후 응답을 보내면 그때 트랜잭션을 완전히 커밋시키고 클라이언트에 결과를 반환한다. 따라서 반동기 복제에서는 소스 서버에서 커밋되어 정상적으로 결과가 반환된 모든 트랜잭션에 대해 적어도 하나의 레플리카 서버에는 해당 트랜잭션들이 전송됐음을 보장한다. 하지만 `전송`됐음을 보장한다는 것이지, 실제로 복제된 트랜잭션이 레플리카 서버에 `적용`되는 것까지 보장한다는 것은 아니다.
  
반동기 복제에서는 소스 서버가 트랜잭션 처리 중 어느 지점에서 레플리카 서버의 응답을 기다리느냐에 따라 소스 서버에서 장애가 발생했을 때 문제 상황이 조금 다를 수 있다.

![image](https://github.com/user-attachments/assets/7ce9551b-9ee4-4ba9-9ab8-124b6c39c03f)

AFTER_SYNC 반동기 복제는 소스 서버에서 각 트랜잭션을 바이너리 로그에 기록하고 난 후 스토리지 엔진에 커밋하기 전 레플리카 서버의 응답을 기다리게 된다. 레플리카 서버로부터 정상적으로 응답이 내려오면 소스 서버는 그때 스토리지 엔진을 커밋해서 트랜잭션에 대한 처리를 완전히 끝내고 트랜잭션을 실행한 클라이언트에 그 처리 결과를 반환한다.

![image](https://github.com/user-attachments/assets/0d589545-dc66-482d-b95b-9b024d17b9ee)

AFTER_COMMIT 반동기 복제는 소스 서버에서 트랜잭션을 바이너리 로그에 기록하고 스토리지 엔진에서의 커밋도 진행하고 나서 최종적으로 클라이언트에 결과를 반환하기 전에 레플리카 서버의 응답을 기다린다. 레플리카 서버로부터 응답이 내려오면 그때 클라이언트는 처리 결과를 얻고 그다음 쿼리를 실행할 수 있게 된다.

5.7 버전에서 새롭게 AFTER_SYNC 방식이 도입됐으며 8.0 버전에서 기본적으로 설정된 동작 방식은 AFTER_SYNC다. AFTER_SYNC 방식은 AFTER_COMMIT 방식과 비교해서 다음과 같은 장점이 있다.

- 소스 서버에 장애가 발생했을 때 팬텀 리드가 발생하지 않음
- 장애가 발생한 소스 서버에 대해 조금 더 수월하게 복구 처리가 가능

반동기 복제는 비동기 복제 방식과 비교했을 때 트랜잭션 처리 속도가 더 느릴 수 있다. 최소 레플리카 서버로 응답을 요청하고 전달받기까지의 네트워크 왕복 시간만큼 더 걸린다고 할 수 있으며, 만약 레플리카 서버에서 응답이 늦어지는 경우 그만큼 트랜잭션 처리가 더 지연될 수 있다. 
  
이처럼 네트워크로 통신하는 부분으로 인해 반동기 복제는 물리적으로 가깝게 위치한 레플리카 서버와의 복제에 더 적합하다고 할 수 있다. 물론 소스 서버에서 레플리카 서버의 응답을 무기한적으로 기다리는 것은 아니며, 사용자는 타임아웃 시간을 설정할 수 있고 시간만큼 레플리카 서버의 응답이 없으면 반동기 복제에서 자동으로 비동기 복제 방식으로 전환한다.

## 복제 토폴로지

이전에는 하나의 레플리카 서버는 둘 이상의 소스 서버를 가질 수 없다는 제약이 있었으나 MySQL 5.7 버전부터 멀티 소스 복제 기능이 도입되면서 그러한 제약은 사라졌고 사용자가 구성할 수 있는 복제 형태가 더욱 다양해졌다.

### 싱글 레플리카 복제 구성

![image](https://github.com/user-attachments/assets/6bd4bfbf-8aa8-4436-92f7-05bf7e704674)

가장 기본적인 형태로, 제일 많이 사용되는 복제 형태이다. 보통 애플리케이션 서버는 소스 서버에만 직접적으로 접근해 사용하고 레플리카 서버에는 접근하지 않으며, 레플리카 서버는 소스 서버에서 장애가 발생했을 때 사용될 수 있는 예비 서버 및 데이터 백업 수행을 위한 용도로 많이 사용된다. 
  
만약 이 같은 형태에서 애플리케이션 서버가 레플리카 서버에서도 읽기 쿼리를 실행한다고 하면 레플리카 서버에 문제가 발생한 경우 서비스 장애 상황이 도래할 수 있따. 따라서 이렇게 소스 서버와 레플리카 서버가 일대일로 구성된 형태에서는 레플리카 서버를 정말 예비용 서버로만 사용하는게 가장 적합하다고 할 수 있다. 

### 멀티 레플리카 복제 구성

![image](https://github.com/user-attachments/assets/3872e2d2-2108-4d64-98d0-cb91318a532d)

멀티 레플리카 복제는 하나의 소스 서버에 2개 이상의 레플리카 서버를 연결한 복제 형태로, 보통 싱글 레플리카 복제 구성에서 추가적인 용도를 위해 여분의 레플리카 서버가 더 필요해졌을 때 자주 사용되는 형태다.
  
새로 오픈될 서비스에서 사용할 MySQL 서버를 설정할 때는 보통 싱글 레플리카 복제 구성으로 MySQL 서버를 구축한다. 이후 서비스의 트래픽이 크게 증가하면 소스 서버 한 대에서만 쿼리 요청을 처리하기에는 벅찰 수 있는데, 이렇게 증가된 쿼리 요청은 대부분 읽기 요청이 더 많으므로 멀티 레플리카 형태로 복제 구성을 전환해 읽기 요청 처리를 분산시킬 수 있다.
  
배치나 통계, 분석 등의 여러 작업이 하나의 MySQL 서버 내에 있는 데이터에 대해 수행돼야 하는 경우에도 멀티 레플리카 형태로 복제를 구축해 용도별로 하나씩 레플리카 서버를 나눠 전용으로 사용하게 할 수도 있다. 이처럼 여러 용도로 나누어 사용하는 경우와 더불어 서비스의 읽기 요청 처리를 분산하는 용도로 사용하는 경우 모두 레플리카 서버 한 대는 예비용으로 남겨두는 것이 좋다. 
  
레플리카 서버로 서비스 읽기 요청이 들어오는 경우 해당 레플리카 서버는 소스 서버만큼 중요해지며, 그 외 다른 용도로 사용되는 레플리카 서버들도 지정된 시간 내에 쿼리 처리가 반드시 수행돼야 하는 등의 요건이 있을 수 있다. 따라서 이러한 레플리카 서버들은 장애가 발생했을 떄 최대한 빠르게 복구돼야 하며, 그렇지 못한 경우에는 다른 레플리카 서버가 문제가 발생한 레플리카 서버로 유입되는 쿼리 요청을 전부 넘겨받아야 한다.
  
결론적으로 대체 서버 및 백업 수행 용도 외에는 최소한의 용도로만 사용되는 예비용 서버 한 대를 남겨놓는 것이 좋으며, 이렇게 예비용으로 남겨진 서버는 소스 서버의 대체 서버 겸 다른 레플리카 서버의 대체 서버로도 사용할 수 있따.

### 체인 복제 구성

멀티 레플리카 복제 구성에서 레플리카 서버가 너무 많아 소스 서버의 성능에 악영향이 예상된다면 `1:M:M` 구조의 체인 복제 구성을 고려해볼 수 있다.

MySQL 복제에서 소스 서버는 레플리카 서버가 요청할 때마다 계속 바이너리 로그를 읽어서 전달해야 한다. 그래서 만약 하나의 소스 서버에 연결된 레플리카 서버 수가 맣다면 바이너리 로그를 읽고 전달하는 작업 자체가 부하가 될 수도 있다. 이럴 때는 소스 서버가 해야 할 바이너리 로그 배포 역할을 새로운 MySQL 서버로 넘길 수 있다.
  
이 복제 형태는 MySQL 서버를 업그레이드 하거나 장비를 일괄 교체할 떄도 많이 사용된다.

### 듀얼 소스 복제 구성

![image](https://github.com/user-attachments/assets/4bfeb31a-6d22-40ee-9bf9-0252995dccc9)

듀얼 소스 복제 구성은 두 개의 MySQL 서버가 서로 소스 서버이자 레플리카 서버로 구성돼 있는 형태를 말한다.
  
듀얼 소스 구성은 두 MySQL 서버 모두 쓰기가 가능하다는 것이 제일 큰 특징이며, 각 서버에서 변경한 데이터는 복제를 통해 다시 각 서버에 적용되므로 양쪽에 쓰기가 발생하지만 두 서버는 서로 동일한한 데이터를 갖게 된다. 듀올 소스 복제 구성에서는 목적에 따라 두 MySQL 서버를 ACTIVE-PASSIVE, ACTIVE-ACTIVE 형태로 사용할 수 있다.

- ACTIVE-PASSIVE
  - 하나의 MySQL 서버에서만 쓰기 작업이 수행되는 형태
  - 싱글 레플리카 복제 구성과 비슷해보이지만 다른 MySQL 서버가 바로 쓰기 작업이 가능한 상태기 때문에 다른 쓰기 서버에 문제가 발상핼 시 바로 예비용 서버로 쓰기 작업을 전환할 수 있는 점이 다르다.
- ACTIVE-ACTIVE
  - 두 서버에 모두 쓰기 작업을 수행하는 형태
  - 지리적으로 매우 떨어진 위치에서 유입되는 쓰기 요청도 원활하게 처리가 가능하다.
 
 듀얼 소스 복제 구성을 사용할 때는 다음과 같은 부분에서 문제가 발생할 수 있다.

- 동일한 데이터를 각 서버에서 변경
  - ACTIVE-ACTIVE 형태에서 동일한 데이터에 대해 변경 트랜잭션이 각 MySQL 서버에 동시점에 유입되는 경우 사용자가 예상하지 못한 방향으로 데이터가 처리될 수 있다. 
- 테이블에서 Auto-Increment 키 사용
  - ACTIVE-ACTIVE 형태에서 동일한 시점에 유입되는 경우 중복 키 에러가 발생할 수 있다.
  - 테이블의 Auto-Increment 키 사용을 지양하고 애플리케이션 단에서 글로벌하게 값을 생성해서 사용하는 것이 좋다.
 
### 멀티 소스 복제 구성

![image](https://github.com/user-attachments/assets/4c28fdee-fdb7-4c17-9683-bc9fc4d76b1f)

멀티 소스 복제 구성은 하나의 레플리카 서버가 둘 이상의 소스 서버를 갖는 형태를 말한다.

- 여러 MySQL 서버에 존재하는 각기 다른 데이터를 하나의 MySQL 서버로 통합
- 여러 MySQL 서버에 샤딩돼 있는 테이블 데이터를 하나의 테이블로 통합
- 여러 MySQL 서버의 데이터들을 모아 하나의 MySQL 서버에서 백업을 수행


## Reference 

**위 글은 책 RealMySQL 8.0을 구입하여 읽고 정리한 내용입니다.**
- [도서 홈페이지 https://wikibook.co.kr/realmysql801/](https://wikibook.co.kr/realmysql801/)
