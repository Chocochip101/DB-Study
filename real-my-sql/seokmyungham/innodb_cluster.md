# InnoDB Cluster

MySQL 복제 기능을 사용해 서비스의 고가용성을 실현할 수 있지만 단순히 소스-레플리카 구조 형태로 구성해놓는다고 해서 고가용성이 실현되는 것은 아니다. 소스 서버에서 장애가 발생했을 때 레플리카 서버가 자동으로 기존 소스 서버를 대체하는 새로운 소스 서버로 전환되는 것이 아니기 때문이다. 
  
MySQL 서버 자체적으로 `페일오버`를 처리하는 기능을 제공하지 않으므로 사용자는 장애가 발생했을 떄 레플리카 서버가 새로운 소스 서버가 될 수 있도록 일련의 작업들을 수행해야 한다. 즉 레플리카 서버에 설정된 읽기 모드를 해제해야 하며, `스플릿 브레인` 현상을 방지하기 위해 장애가 발생한 소스 서버에서 데이터 변경을 실행하지 못하도록 해야 한다. 그리고 애플리케이션 서버는 새로운 소스 서버를 바라보도록 커넥션 설정을 변경해야 한다. 이러한 작업은 모두 수동으로 처리할 수밖에 없으며 완료되기 까지 적지 않은 시간이 소요된다.
  
대부분의 경우 이 같은 전환 작업을 자동화하는 것을 고려하곤 한다. 따라서 MySQL 서버 장애를 감지해 자동으로 페일오버를 처리하는 프로그램을 직접 개발해서 사용하거나 혹은 서드파티 HA 솔루션을 사용하게 되는데, 대표적으로 MMM과 MHA 그리고 Ochestrator등이 있다. MySQL 5.7.17 버전에서 빌트인 형태의 HA 솔루션인 InnoDB 클러스터가 도입되면서 사용자는 좀 더 쉽고 편리하게 고가용성을 실현할 수 있게 됐다.

## InnoDB Cluster 아키텍처

InnoDB 클러스터를 구성하는 요소는 다음과 같다.

![image](https://github.com/user-attachments/assets/3ed8f7dc-9c2e-421b-9717-fad34d66b0b8)

- 그룹 복제(Group Replication)
  - 소스 서버의 데이터를 레플리카 서버로 동기화하는 기본적인 복제 역할뿐만 아니라 복제에 참여하는 MySQL 서버들에 대한 자동화된 멤버십 관리 역할을 담당한다.
- MySQL 라우터(MySQL Router)
  - 애플리케이션 서버와 MySQL 서버 사이에서 동작하는 미들웨어 프로그램으로, 애플리케이션이 실행한 쿼리를 직접 한 MySQL 서버로 전달하는 프록시 역할을 한다. 
- MySQL 셸(MySQL Shell)
  - 기존 MySQL 클라이언트보다 좀 더 확장된 기능을 가진 새로운 클라이언트 프로그램으로, 기본적인 SQL 문 실행뿐만 아니라 자바스크립트 및 파이썬 기반의 스크립트 작성 기능과 MySQL 서버에 대해 클러스터 구성 등의 어드민 작업을 할 수 있게 하는 API를 제공한다.
 
InnoDB 클러스터에서 데이터가 저장되는 MySQL 서버들은 그룹 복제 형태로 복제가 구성되며, 각 서버는 프라이머리 혹은 세컨더리중 하나로 역할로 동작하게 된다. 여기서 프라이머리는 기존 MySQL 복제에서의 소스 서버라 할 수 있으며, 세컨더리는 레플리카 서버라고 할 수 있다. 그룹 복제에 설정된 모드에 따라 프라이머리는 하나만 존재할 수도 있고 여러 대가 존재할 수도 있다. 그룹 복제에서는 InnoDB 스토리지 엔진만 사용될 수 있다. 또한 그룹 복제를 구성할 때 고가용성을 위해 MySQL 서버를 최소 3대 이상으로 구성해야 하는데, 이는 3대로 구성했을 떄부터 MySQL 서버 한대에 장애가 발생하더라도 복제 그룹이 정상적으로 동작하기 떄문이다.
  
InnoDB 클러스터를 사용하는 환경에서 클라이언트는 MySQL 서버로 직접 접근해서 쿼리를 실행하는 것이 아니라 `MySQL 라우터에 연결해서 쿼리를 실행`한다. MySQL 라우터는 `InnoDB 클러스터로 구성된 MySQL 서버들에 대한 메타데이터 정보`를 지니며 이를 바탕으로 클라이언트의 쿼리를 클러스터 내 적절한 MySQL 서버로 전달한다. 따라서 클라이언트는 현재 InnoDB 클러스터가 어떤 서버로 구성돼 있는지 알고 있을 필요가 없으며, `커넥션 정보에는 MySQL 라우터 서버만 설정해두면 된다.`
  
MySQL 셸은 사용자가 손쉽게 InnoDB 클러스터를 생성하고 관리할 수 있도록 API를 제공하며, 그 외에도 InnoDB 클러스터의 상태를 확인하거나 MySQL 서버의 설정을 변경하는 것과 같은 여러 가지 기능들을 제공한다.
  
InnoDB 클러스터에서는 MySQL 서버에 장애가 발생하면 그룹 복제가 먼저 이를 감지해서 `자동으로 해당 서버를 복제 그룹에서 제외`시키며, 라우터는 이러한 `복제 토폴로지 변경을 인지하고 자신이 가진 메타데이터를 갱신`해서 클라이언트로부터 실행된 쿼리가 현재 복제 그룹에서 정상적으로 동작하는 MySQL 서버로만 전달될 수 있도록 한다.
  
InnoDB 클러스터에서 각 구성 요소들은 상호 유기적으로 동작해서 고가용성를 이뤄내고, 사용자는 수동으로 장애 복구 처리를 할 필요가 없이 모두 자동으로 처리된다.

## 그룹 복제

![image](https://github.com/user-attachments/assets/05d24c02-659b-4596-ad02-88ae430b5f24)

그룹 복제는 MySQL 5.7.17 버전에서 도입된 새로운 복제 방식이며, 기존 MySQL 복제 프레임워크를 기반으로 구현되어 내부적으로 Row 포맷의 바이너리 로그와 릴레이 로그, GTID를 사용한다. 기존 복제의 경우 일반적으로 소스-레플리카 형태로 구성되어 단방향 복제가 이뤄지는 반면, 그룹 복제에서는 하나의 복제 그룹 내에서 양방향 쓰기를 처리하는 서버가 여러 대 존재할 수 있다.

![image](https://github.com/user-attachments/assets/e43c29ad-45ad-4cca-a6e5-f98385aa2f7c)
  
그룹 복제에서도 트랜잭션에 대해 그룹 내 다른 멤버들의 응답을 확인하는 단계가 존재한다. 한 서버에서 트랜잭션이 커밋될 준비가 되면 트랜잭션의 정보를 다른 멤버들에 전송하고 과반수 이상의 멤버로부터 응답을 전달받으면 그때 해당 트랜잭션을 `인증(Certify)`하고 최종적으로 커밋 처리를 완료한다. 트랜잭션 인증은 인증 대상 트랜잭션이 이미 인증 단계를 통과한 `선행 트랜잭션과 동시점에 동일한 데이터를 변경했는지 충돌 여부를 검사`해서 문제없이 적용 가능한지를 확인하는 과정이다.
    
그룹 내 멤버들의 응답에 따라 전체 복제 그룹에서 해당 트랜잭션의 여부가 결정되므로 이러한 부분이 기본 복제와의 가장 큰 차이점이라고 볼 수 있다. 이처럼 트랜잭션 커밋을 처리할 때 그룹의 다른 멤버들에 대한 응답을 확인하는 과정을 `합의(Consensus)`라고 하는데, 이는 그룹 멤버들로 부터 이 트랜잭션을 복제 그룹에 적용하는 것에 대한 동의를 구하는 것이기 때문이다. 그룹 복제에서는 매 트랜잭션을 처리할 때마다 이 합의 과정을 반드시 거친다. 물론 데이터를 읽기만 하는 트랜잭션에 대해서는 그룹 멤버간의 합의 과정이 필요치 않다.
  
그룹 복제는 기존 복제를 사용하는 환경에서 수동으로 처리하거나 혹은 복잡하게 구현해야 했던 부분들을 빌트인된 형태의 자동화된 기능으로 제공함으로 사용자의 편의성을 증대시켰다. 그룹 복제는 InnoDB 클러스터의 핵심 구성 요소로, InnoDB 클러스터를 제대로 사용하기 위해서는 그룹 복제를 반드시 이해해야 한다.

- 그룹 멤버 관리
- 그룹 단위의 정렬된 트랜잭션 적용 및 트랜잭션 충돌 감지
- 자동 페일오버
- 자동 분산 복구

### 그룹 복제 아키텍처

![image](https://github.com/user-attachments/assets/13658dc1-a0f3-4a22-8e73-8596cf859710)

그룹 복제는 별도의 플러그인으로 구현돼 있으며, 그룹 복제를 사용하기 위해서는 MySQL 서버에 그룹 복제 플러그인이 설치돼 있어야 한다. 

![image](https://github.com/user-attachments/assets/bd619cdb-b468-4623-b29b-fa935bfd82f4)

플러그인 최상위 계층에는 플러그인 API 집합이 존재한다. API를 통해 MySQL 서버에서 그룹 복제 플러그인으로 혹은 그 반대 방향으로 요청이 전달되며, MySQL 서버에서는 MySQL 서버의 시작 또는 복구 트랜잭션 커밋 등의 이벤트를 그룹 복제 플러그인에 전달하고 그룹 복제 플러그인에서는 처리 중인 트랜잭션에 대한 커밋 또는 중단, 릴레이 로그 기록을 위한 요청 들을 서버에 전달한다.
  
복제 플러그인 계층은 그룹 복제의 기능이 실질적으로 구현돼 있는 계층이다. 계층 내부는 여러 가지 모듈들로 나눠져 있고, API를 통해 들어온 요청들은 각각 적절한 모듈로 전달된다. 
  
마지막 두 계층은 그룹 통신 시스템 API와 그룹 통신 엔진으로 이루어져 있다. 상위 플러그인 계층은 그룹 통신 시스템 API를 통해 그룹 통신 엔진과 상호작용 하며, 그룹 통신 엔진은 `Xcom` 이라고 불리는데 그룹 복제에 참여 중인 다른 MySQL 서버들과의 통신 처리를 담당하는 그룹 복제의 핵심 구성 요소다. 그룹 통신 엔진은 그룹 복제를 설정할 때 지정된 별도의 포트(33061)을 통해 통신을 수행한다. 
  
그룹 통신 엔진은 `트랜잭션이 그룹 복제 멤버들에 동일한 순서로 전달될 수 있도록 보장해주며, 그룹 복제 토폴로지 변경과 그룹 멤버의 장애 등을 감지`한다. 또한 트랜잭션 적용 등을 위한 `그룹 멤버 간의 합의` 처리도 담당한다.
  
그룹 복제에서 또 다른 중요한 부분은 바로 그룹 복제를 구성하는 MySQL 서버의 수이다. 그룹 복제에서는 복제를 처리할 떄 그룹 멤버 간의 합의 절차가 수행되므로, 정상적으로 동작하려면 그룹의 과반수에 해당하는 서버가 정상적으로 동작하고 있어야 한다. 따라서 하나의 서버에 장애가 발생하더라도 그룹 복제가 문제없이 처리되려면 적어도 세 대의 서버가 그룹에 존재해야 한다. 따라서 사용자는 그룹 복제를 구성할 때 허용 가능한 서버 수에 따른 전체 서버수를 다음과 같이 계산해서 그룹 복제로 구성할 서버 수를 결정해야 한다.

```
N = 2F + 1 (N: 전체 서버 수, F: 허용하고자 하는 장애 서버 수)
```

### 싱글 프라이머리 모드(그룹 복제 모드)

싱글 프라이머리 모드는 그룹 내에서 쓰기를 처리할 수 있는 프라이머리 서버가 한 대만 존재하는 형태다. 싱글 프라이머리 모드로 그룹 복제를 처음 구축하는 경우 그룹 복제 구축을 진행한 MySQL 서버가 프라이머리로 지정된다. 
  
싱글 프라이머리 모드로 동작 중인 그룹에서 다음과 같은 상황에 그룹 내 프라이머리 서버가 변경될 수 있다.

- 자발적으로 혹은 예기치않게 프라이머리 서버가 그룹을 탈퇴
- group_replication_set_as_primary() UDF를 사용해 그룹의 특정 멤버를 새로운 프라이머리로 지정한 경우

UDF를 통해 사용자가 지정한 서버로 변경되는 경우가 아닌 경우 그룹 복제에서는 다음과 같은 우선순위들을 바탕으로 새로운 프라이머리를 선출하게 된다.

- MySQL 서버 버전
- 각 멤버의 가중치 값
- UUID값 의 사전식 순서

### 멀티 프라이머리 모드(그룹 복제 모드)

멀티 프라이머리 모드는 그룹 복제에서 멤버들이 전부 프라이머리로 동작하는 형태로, 클라이언트는 그룹의 어떤 MySQL 서버로든 쓰기와 읽기 요청을 보낼 수 있다. 때문에 무엇보다도 `그룹 멤버 간의 MySQL 버전 호환성이 중요`하다. 멀티 프라이머리 모드를 사용하는 그룹에서는 최적의 호환성과 성능을 위해 그룹의 `모든 멤버가 동일한 MySQL 버전으로 실행`되는 것이 좋다. 만약 서로 다른 MySQL 버전을 사용하는 멤버로 구성된 프라이머리 모드의 그룹 복제에서는 새로 참여하는 멤버가 읽기 전용 모드로 유지될 수 있다.
  
### 그룹 멤버 관리(Group Membership)

```
GR_mysql> SELECT * FROM performance_schema.replication_group_members \G
*************************** 1. row ***************************
  CHANNEL_NAME: group_replication_applier
     MEMBER_ID: a2252f46-639a-11eb-ae0c-0ade3e9a4daf
   MEMBER_HOST: ic-node1
   MEMBER_PORT: 3306
  MEMBER_STATE: ONLINE
   MEMBER_ROLE: PRIMARY
MEMBER_VERSION: 8.0.22
*************************** 2. row ***************************

...

```
그룹 복제에서는 현재 어떤 서버들이 그룹에 참여하고 있는지 그룹 멤버들에 대한 목록과 상태 정보를 내부적으로 관리하고 있으며, 사용자는 `performance_schema`의 `replication_group_members` 테이블을 통해서 그룹 멤버 목록을 확인할 수 있다. 그룹 복제에서는 해당 테이블 데이터를 자동으로 갱신한다.
  
사용자는 `replication_group_members` 테이블 데이터를 통해 그룹 멤버들의 호스트명과 사용하는 포트, UUID 값, MySQL 버전을 확인할 수 있으며, 각 그룹 멤버들의 Role도 알 수 있다. 또한 MEMBER_STATE 칼럼을 통해 멤버의 현재 상태도 확인할 수 있다. (`ONLINE`, `RECOVERING`, `OFFLINE`, `ERROR`, `UNREACHABLE`)
  
그룹 복제가 관리하는 멤버 목록과 상태 정보를 `뷰(VIEW)`라고도 하는데, 그룹 복제에서 멤버는 새로 가입하거나 탈퇴할 수 있으므로 뷰는 특정 시점의 그룹 멤버 목록이다. 뷰는 뷰 ID라는 고유 식별자를 가지며, 그룹 멤버가 변경될 때마다 뷰 ID값이 갱신된다.

```
VIEW ID = [Prefix value]:[Sequence value]

Prefix value: 그룹 복제가 초기화될 떄 생성되며, 그 시점의 타임스탬프를 기반으로 값 생성
Sequence value: 단조 증가하는 정숫값, 그룹에서 멤버가 변경될 때마다 1씩 증가
```

그룹의 현재 뷰 ID 값은 `performance_schema`의 r`eplication_group_member_stats` 테이블에서 VIEW_ID 칼럼을 통해 확인할 수 있다. 그룹에 새로운 멤버가 추가되어 뷰 ID 값이 변경되면 바이너리 로그에도 `View_change`라는 이벤트로 뷰 변경 내역이 기록된다. 

### 그룹 복제에서의 트랜잭션 처리

그룹 복제에서 트랜잭션은 `합의`와 `인증` 단계들을 거친 후 최종적으로 그룹의 각 서버들에 적용된다.

`합의`는 그룹 내 일관된 트랜잭션 적용을 위해 그룹 멤버들에게 트랜잭션 적용을 제안하고 승낙을 받는 과정으로, 그룹 멤버 간 통신 결과를 바탕으로 처리된다.

- 클라이언트가 한 그룹 멤버에서 트랜잭션을 실행하고 커밋 요청 전송
- 해당 그룹 멤버는 `그룹 통신 엔진(XCOM)`을 통해 트랜잭션에서 변경한 데이터에 대한 WriteSet과 트랜잭션이 커밋도리 당시의 gtid_executed 스냅샷 정보, 트랜잭션의 이벤트 로그 데이터 등이 포함된 트랜잭션 데이터를 그룹의 다른 멤버들로 전파
- 그룹 복제의 그룹 통신 엔진에서는 트랜잭션을 전파하면서 Paxos 기반의 프로토콜을 바탕으로 그룹 멤버들 간의 합의를 수행
- 최종적으로 합의가 완료되어 실행된 멤버에서 그룹의 과반수 이상에 해당하는 멤버들로부터 응답 메시지를 전달받으면 해당 멤버는 그다음 프로세스를 진행
- 만약 과반수 이상의 멤버들로부터 응답을 받지 못한 경우 그룹 복제에서 트랜잭션은 적용되지 않고 클라이언트에는 에러 반환

실행된 트랜잭션들은 `합의` 단계를 거친 후 글로벌하게 정렬되어, 각 멤버들에서 모두 동일한 순서로 `인증` 단계를 거치게 된다. 

- 각 멤버들은 전달받은 트랜잭션 WriteSet 데이터와 로컬에서 내부적으로 관리하고 있는 WriteSet 히스토리 데이터를 비교
- 해당 트랜잭션이 이미 인증 단계를 거친 선행 트랜잭션과 동시점에 동일한 데이터를 변경한 것인지 검사해서 트랜잭션 충돌 여부 확인

> 트랜잭션 충돌은 그룹 멤버 전체가 쓰기를 처리할 수 있는 멀티 프라이머리 모드에서만 발생할 수 있다.  
> 인증 단계에서 트랜잭션 충돌이 감지된 트랜잭션은 커밋되지 못하고 롤백  
> 따라서 트랜잭션 충돌이 자주 발생할 수 있는 환경에서는 그룹 복제를 싱글 프라이머리로 사용해 대기 후 처리될 수 있게 하는 것이 더 나은 방법이 될 수 있다.

- 각 트랜잭션이 실행된 로컬 멤버에서는 인증 단계를 거친 후 바이너리 로그에 트랜잭션을 기록하고 최종적으로 커밋을 완료
- 클라이언트는 이 시점에 커밋 요청에 대한 응답을 받는다.
- 원격으로 트랜잭션 데이터를 전달받은 그룹의 다른 멤버들에서는 인증 단계를 수행한 후 함께 전달받은 트랜잭션 로그 데이터를 바탕으로 릴레이 로그 작성
- 그룹 복제의 어플라이어 스레드에서는 릴레이 로그에 기록된 트랜잭션을 실행하고 바이너리 로그에도 기록해서 최종적으로 서버에 해당 트랜잭션을 적용

### 트랜잭션 일관성 수준

그룹 복제에서 각 멤버들은 모두 동일한 트랜잭션을 적용하지만 실제 적용 시점까지 완전히 일치하지는 않는다. 그래서 아주 짧은 순간에 최신 쓰기 변경 사항이 반영이 되기 전 한 멤버에서 예전의 데이터를 읽게 되거나하는 문제가 발생할 수 있다. 그런데 MySQL 8.0.14 버전부터 그룹 복제에서 트랜잭션의 일관성 수준을 설정하는 기능이 도입되면서 `group_replication_consistency` 시스템 변수를 통해 사용자가 트랜잭션 일관성을 선택해서 사용할 수 있게됐다. 
  
#### EVENTUAL 일관성 수준

`EVENTUAL` 수준은 트랜잭션 일관성 수준의 기본 값으로, 시스템 변수가 도입되기 이전의 일관성 수준과 동일하다. `EVENTUAL` 일관성 수준에서는 읽기 전용 및 읽기-쓰기 트랜잭션이 별도의 제약 없이 바로 실행 가능하다. 
  
즉 최종적으로는 그룹 멤버들이 일관된 데이터를 가지게 됨을 의미하지만, 트랜잭션이 직접 실행된 멤버가 아닌 `다른 그룹 멤버들에서는 일시적으로 변경 직전 상태의 데이터`가 읽힐 수 있다. 또한 프라이머리 페일오버가 발생한 경우 새로운 프라이머리가 이전 프라이머리의 트랜잭션을 모두 적용하기 전에 새로운 프라이머리에서 트랜잭션이 실행 가능해서 읽기 트랜잭션이 오래된 데이터를 읽을 수 있고, 읽기-쓰기 트랜잭션의 경우 커밋 시 이전 프라이머리의 트랜잭션과의 충돌로 인해 롤백될 수 있음을 의미한다.

#### BEFORE_ON_PRIMARY_FAILOVER 일관성 수준

`BEFORE_ON_PRIMARY_FAILOVER` 수준은 싱글 프라이머리 모드로 설정된 그룹 복제에서 프라이머리 페일오버가 발생해서 신규 프라이머리가 선출됐을 때만 트랜잭션에 영향을 미친다. 선출된 신규 프라이머리가 `BEFORE_ON_PRIMARY_FAILOVER` 수준을 가지고 있고, 아직 이전 프라이머리의 트랜잭션을 적용하는 경우 유입되는 읽기 전용 및 읽기-쓰기 트랜잭션은 트랜잭션이 모두 적용될 떄 까지 대기한다.
  
신규 프라이머리로 유입되는 트랜잭션의 대기 시간은 신규 프라이머리와 이전 프라이머리 간의 트랜잭션 갭에 따라 달라진다. 대기 시간이 MySQL `wait_timeout` 시스템 변수에 설정된 값을 초과하면 `ER_GR_HOLD_WAIT_TIMEOUT` 에러가 클라이언트로 반환된다. `wait_timeout` 기본 값은 8시간으로 매우 긴 편이므로 애플리케이션에서 적절히 쿼리의 타임아웃을 설정하는 것이 좋다.
  
새로 유입된 모든 읽기-쓰기 트랜잭션들은 처리가 지연되지만 읽기 전용 트랜잭션에서는 MySQL 서버 모니터링 등을 위한 일부 쿼리들은 바로 실행이 가능하다. 
- `SHOW`, `SET`, `DO`, `EMPTY`, `USE`
- performance_schema, sys db에 대한 SELECT
- information_schema의 processlist select
- 테이블 또는 사용자 정의 함수를 사용하지 않는 select
- stop group_replication
- shutdown 문
- reset persist 문

`BEFORE_ON_PRIMARY_FAILOVER` 일관성 수준은 프라이머리 페일오버가 발생하지 않는 상황에서는 프라이머리로 유입된 트랜잭션들에 아무런 영향을 미치지 않는다. 즉 일반적인 상황에서는 트랜잭션들이 `EVENTUAL` 일관성 수준으로 설정된 트랜잭션처럼 처리된다.

#### BEFORE 일관성 수준

`BEFORE` 일관성 수준에서 읽기 전용 및 읽기-쓰기 트랜잭션은 모든 선행 트랜잭션이 완료될 떄 까지 대기 후 처리된다. `BEFORE` 일관성 수준으로 설정된 트랜잭션은 항상 최신 데이터를 읽으며, 트랜잭션의 처리 시간은 선행 트랜잭션의 처리 시간에 영향을 받는다. 또한 대기 시간이 MySQL `wait_timeout` 시스템 변수에 설정된 값을 초과하면 `ER_GR_HOLD_WAIT_TIMEOUT` 에러가 클라이언트로 반환된다. `BEFORE` 일관성 수준은 트랜잭션에서 반드시 최신 데이터를 읽어야 하며, DB에서 읽기 요청은 적고 쓰기 요청이 많은 경우에 사용하는 것이 좋다. 

#### AFTER 일관성 수준

`AFTER` 일관성 수준은 트랜잭션이 적용되면 해당 시점에 그룹 멤버들이 모두 동기화된 데이터를 갖게 한다. 즉 읽기-쓰기 트랜잭션은 다른 모든 멤버들에서도 해당 트랜잭션이 커밋될 준비가 됐을 때 까지 대기한 후 최종적으로 처리된다. 또한 대기 시간이 MySQL `wait_timeout` 시스템 변수에 설정된 값을 초과하면 `ER_GR_HOLD_WAIT_TIMEOUT` 에러가 클라이언트로 반환된다. 읽기-쓰기 트랜잭션은 다른 멤버들에서 트랜잭션 커밋이 준비될 때 까지 대기해야 하므로 항상 본래의 처리 시간보다 더 많은 시간을 소요하게 된다. 따라서 `AFTER` 일관성 수준은 DB에서 쓰기 요청보다 읽기 요청이 많고, 분산된 최신 읽기를 수행하고자 할 때 사용하는 것이 좋다. 

#### BEFORE_AND_AFTER 일관성 수준

![image](https://github.com/user-attachments/assets/bb3cc649-f20b-4b91-a746-3fee42af94a8)

`BEFORE_AND_AFTER` 일관성 수준은 `BEFORE` 수준과 `AFTER` 수준이 결합된 형태라고 볼 수 있다 읽기-쓰기 트랜잭션은 모든 선행 트랜잭션이 적용될 떄까지 기다린 후 실행되며, 트랜잭션이 다른 모든 멤버들에서도 커밋이 준비되어 응답을 보내면 그때 최종적으로 커밋된다. 읽기 전용 트랜잭션은 모든 선행 트랜잭션이 적용될 때 까지 대기한 후 실행된다. 또한 대기 시간이 MySQL `wait_timeout` 시스템 변수에 설정된 값을 초과하면 `ER_GR_HOLD_WAIT_TIMEOUT` 에러가 클라이언트로 반환된다.
  
### 흐름 제어(Flow Control)

그룹 복제에서는 그룹 멤버 간의 트랜잭션 적용 불균형으로 인해 발생하는 문제를 방지하기 위해 그룹 멤버들의 쓰기 처리량을 조절하는 흐름 제어멤 매커니즘이 구현돼 있다. 멤버 간 트랜잭션 갭을 적게 유지해서 멤버들의 데이터가 최대한 동기화된 상태로 유지될 수 있게 하며, 그룹에 평소와 다른 워크로드가 유입되는 등에 변화에도 빠르게 적응해서 각 멤버들의 쓰기 처리량이 균등할 수 있게 한다.
  
`group_replication_flow_control_mode` 시스템 변수를 통해 흐름 제어 기능의 사용 여부를 설정할 수 있다. 현재는 `QUOTA` 모드밖에 존재하지 않으며 또는 `DISABLED` 값으로 설정할 수 있다. `QUOTA` 모드는 흐름 제어의 기본 모드로 멤버가 정해진 할당량만큼만 쓰기를 처리하도록 제어하는 방식이다. `DISABLED`는 흐름 제어 비활성화로, 현재 트랜잭션을 적용하지 않고 있거나 혹은 아직 적용하지 못한 트랜잭션을 아주 많이 가지고 있더라도 다른 멤버들의 흐름 제어에 영향을 주지 않는다. 

흐름 제어는 각 멤버에서 개별적으로 수행되는데, 멤버에서 `인증 큐 크기`, `적용 큐 크기`, `인증된 총 트랜잭션 수`, `적용된 원격 트랜잭션 수`, `로컬 트랜잭션 수`와 같은 통계 정보들을 수집하여 다른 멤버들에게 공유한다. 통계 정보 데이터 수집 주기는 `group_replication_flow_control_period` 시스템 변수로 설정할 수 있다. 흐름 주기 변수 값은 관리상의 편의를 위해서라도 모든 멤버에서 동일한 값으로 설정하는 것이 좋다.
  
사용자는 인증과 적용 큐 크기에 의한 흐름 제어 임계값을 설정할 수 있다. 인증과 적용 큐에서 대기중인 트랜잭션 수가 각각 해당 변수에 지정된 수를 초과하면 흐름 제어가 작동한다. 

- `group_replication_flow_control_cerfifier_threshold`,
- `group_replication_flow_control_applier_threshold`
  
흐름 제어에서는 통계 정보를 바탕으로 그룹에서 `트랜잭션 적용이 가장 뒤쳐진 멤버가 처리할 수 있는 수준으로 멤버의 쓰기 처리량을 계산`하게 된다. 이렇게 계산된 값은 멤버에게 바로 적용되지 않고, 흐름 제어에서 `멤버에게 할당하는 쓰기 처리량과 관련된 시스템 변수들의 값을 참조해서 최종적으로 할당`할 쓰기 처리량을 결정한다.

### 그룹 복제의 자동 장애 감지 및 대응

#### 추방

그룹 복제에는 자동 장애 감지 매커니즘이 구현돼 있다. 그룹 복제에서는 멤버 간 주기적으로 통신 메시지를 주고받으며 서로의 상태를 확인하는데, 멤버로부터 5초 내로 메시지를 받지 못하면 해당 멤버에 문제가 생긴 것으로 의심하기 시작한다. 그리고 장애가 의심되는 멤버에 대해 과반수의 멤버가 동의하면 해당 멤버를 그룹에서 추방한다. 기본적으로 MySQL 8.0.20 버전까지는 의심되는 즉시 그룹에서 멤버를 추방했지만 MySQL 8.0.21 버전부터는 5초의 대기 시간이 추가되어 대기 시간이 초과되면 그떄 추방된다. 
  
추방되기 전 대기 시간 동안 멤버는 `UNREACHABLE` 상태로 표시되고 대기 시간은 `group_replication_member_expel_timeout` 시스템 변수로 멤버가 의심을 받고 나서 추방되기 전까지의 대기 시간을 초 단위로 지정할 수 있다. 해당 변수는 8.0.13 버전에서 추가되었고 8.0.20 버전까지 기본 값이 0이었다. 8.0.13 버전에서는 해당 변수에 값을 1년까지 설정할 수 있으며, 8.0.14 버전부터는 최대 1시간까지만 설정 가능하다.

기본 값을 그대로 사용하는 경우 `5초 또는 10초 후 의심받은 멤버가 추방되는데, 이 시간은 네트워크가 느린 환경에서는 충분하지 않을 수 있다.` 이로 인해 불필요하게 그룹 멤버가 그룹에서 추방당하거나 혹은 프라이머리 페일오버가 발생할 수도 있다. 멤버가 추방되면 그룹 뷰가 변경되므로 그룹 멤버들은 새로운 뷰 ID 값을 갖게 된다. 따라서 멤버가 추방되고 나서 다시 통신을 재개할 수 있는 경우 해당 멤버는 자신이 그룹에서 추방됐음을 알게 된다. 추방된 멤버는 자동으로 그룹에 재가입을 시도할 수도 있는데, 이는 `group_replication_autorejoin_tries` 시스템 변수에 설정된 값에 따라 달라진다. 

#### 재가입 정책

`group_replication_autorejoin_tries` 시스템 변수는 MySQL 8.0.16 버전에서 도입된 변수로, 멤버는 그룹에서 추방되면 해당 시스템 변수에 설정된 횟수만큼 그룹에 재가입을 시도한다. `group_replication_autorejoin_tries` 시스템 변수는 8.0.20 버전까지 기본값이 0이었다. 따라서 8.0.20 버전까지는 그룹 복제에서 멤버가 자신이 추방됐음을 알게 되더라도 그룹에 다시 가입하려고 시도하지 않았다. 8.0.21 버전부터는 기본 값이 3으로 변경되었다. 각 시도당 5분의 시간 간격을 둔다. 변수 설정 최댓값은 2016이다.

#### 소수 정책

그룹에서 추방된 멤버는 다른 그룹 멤버들과 다시 통신이 되지 않으면 자신이 추방됐음을 알지 못한다. 기본적으로 네트워크 단절로 인해 그룹 멤버들이 분리되는 경우 소수에 속하는 멤버들은 스스로 그룹을 탈퇴하지 않는다(ㅋㅋ). `group_replication_unreachable_mejority_timeout` 시스템 변수를 사용해서 소수에 속한 멤버들이 과반수의 그룹 멤버들과 통신이 단절됐을 때 일정 시간 동안 대기한 후 스스로 그룹을 탈퇴하도록 설정할 수 있다.

소수에 속한 멤버들에서도 트랜잭션은 실행될 수 있으며, 실행된 트랜잭션은 그룹의 과반수 동의를 얻을 수가 없으므로 처리가 보류된 상태로 남아 있게 된다. `group_replication_unreachable_majority_timeout` 시스템 변수에 지정된 시간이 초과되면 멤버는 보류 상태의 모든 트랜잭션을 롤백하고 그룹에서 탈퇴하며, 상태는 ERROR로 표기된다. 그리고 재가입 정책에 따라 재가입을 시도한다.

#### 종료 액션

멤버가 타의 혹은 자의로 그룹에서 탈퇴한 상태에서 자동 재가입에 실패하거나 혹은 재가입을 아예 시도하지 않게 설정된 경우 멤버는 최종적으로 `group_replication_exit_state_action` 시스템 변수에 설정된 작업을 진행한다. `group_replication_exit_state_action` 시스템 변수는 MySQL 8.0.12 버전부터 사용할 수 있다.

- READ_ONLY
  - `super_read_only` 시스템 변수를 ON으로 설정해서 MySQL 서버를 슈퍼 읽기 전용 모드로 전환시킨다. 8.0.16 버전부터 기본 값으로 설정. `CONNECTION_ADMIN` 권한을 가지고 있더라도 서버에서 데이터 변경을 수행할 수 없다.
- OFFLINE_MODE
  - `offline_mode` 시스템 변수를 ON으로 설정해서 MySQL 서버를 오프라인 모드로 전환시키고 `super_read_only` 시스템 변수도 ON으로 설정한다. 오프라인 모드에서는 기존에 이미 연결돼 있는 세션의 경우 다음 요청에서 연결이 끊어지고 `CONNECTION_ADMIN` 권한을 가진 사용자를 제외하고 더이상 연결이 허용되지 않는다. 
- ABORT_SERVER
  - MySQL 서버를 종료시킨다. (??)
 
### 그룹 복제의 분산 복구

멤버가 그룹에 새로 가입하거나 혹은 탈퇴 후 다시 가입할 때, 그룹을 떠나있는 동안 그룹에 적용된 트랜잭션이 있을 수 있다. 멤버는 이러한 트랜잭션들을 모두 적용해야 다른 그룹 멤버들과 동일한 데이터를 가지게 된다. 그룹 복제에서는 가입 멤버가 동일한 최신 데이터를 가질 수 있도록 누락된 트랜잭션들을 다른 그룹 멤버에서 가져와 적용하는 복구 프로세스를 자동으로 수행하게 되는데 이를 `분산 복구`라고 한다. 분산 복구에서 가입 멤버가 복구 작업을 위해 선택한 기존 그룹 멤버를 `기증자 멤버`라고 한다.

#### 분산 복구 방식

분산 복구 작업 시 먼저 가입 멤버에서 `group_replication_applier` 복제 채널의 릴레이 로그를 확인하는데, 이전에 그룹에 가입한 적이 있다면 그룹에서 탈퇴하는 시점에 릴레이 로그에는 기록돼 있으나 아직 실제로 적용되지 않은 트랜잭션이 존재할 수 있기 떄문이다. 이처럼 미처 적용되지 못하고 남아있는 트랜잭션이 있는지 확인하고 이를 먼저 적용하는 것으로 복구 작업을 시작한다. 
  
이후 그룹에 온라인 상태로 존재하는 다른 그룹 멤버에 연결해서 분산 복구 작업을 마저 진행하는데, 이 때 두 가지 방식을 적절히 조합해서 작업을 시작한다.

- 바이너리 로그 복제 방식
  - 바이너리 로그 복제 방식은 MySQL의 기본 복제 방식인 비동기 복제를 기반으로 구현됐다. 기증자로 선택된 다른 그룹 멤버와 `group_recpliation_recovery`라는 별도의 복제 채널로 연결되어 가입한 멤버에 적용되지 않은 트랜잭션들을 복제해서 가져와 적용하는 방식이다.
- 원격 클론 방식
  - 원격 클론 방식은 MySQL 8.0.17 버전에서 도입된 클론 플러그인을 사용하는 형태로, 다른 그룹 멤버의 InnoDB 스토리지 엔진에 저장된 모든 데이터와 메타데이터를 일관된 스냅숏으로 가져와 가입 멤버를 재구축하는 방식이다. 그룹 멤버들과 가입 멤버 모두 클론 플러그인이 설치돼 있어야 한다.

가입한 멤버에 대해 가장 적합한 형태의 복구 방식을 자동으로 선택한다. 현재 가입한 멤버에서 필요한 트랜잭션 수와 해당 트랜잭션들이 기존 그룹 멤버의 바이너리 로그 파일에 모두 존재하는지 등을 확인한다. 트랜잭션 갭이 크거나 필요한 트랜잭션들 중 일부가 기존 그룹 멤버 바이너리 로그 파일에 존재하지 않는 경우 원격 클론 방식으로 복구 작업을 진행한다. 그게 아니라면 바이너리 로그 복제 방식으로만 진행한다. 
    
원격 클론 방식에서는 가입한 멤버의 기존 데이터는 모두 제거되며 클론 작업으로 연결된 기존 그룹 멤버의 스냅샷 데이터로 대체된다. 가입한 멤버가 스냅샷 데이터로 재구축되면, 클론 작업 동안 그룹에서 적용된 트랜잭션을 가져오기 위해 바이너리 로그 복제 방식으로 한번 더 복구 작업을 진행한다.

분산 복구에서 원격 클론 방식을 복구 방식으로 채택하게 되는 트랜잭션 갭의 임계값은 `group_replication_clone_threshold` 시스템 변수에 따라 달라진다. 근데 기본 값이 매우 큰 값이므로 바이너리 로그 복제 방식이 가능한 환경에서는 원격 클론 방식이 사용되지 않는다. 따라서 원격 클론 작업을 사용하고 싶은 경우 적절한 값으로 시스템 변수를 변경해야 한다. 
  
하지만 시스템 변수를 너무 낮은 값으로 설정해서는 안된다. 원격 클론 방식으로 복구가 진행되는 동안 그룹에 적용된 트랜잭션 수가 시스템 변수에 지정된 값을 초과하는 경우 클론 작업이 완료되고 나서 다시 또 클론 작업이 진행되고, 이 상황이 계속 반복될 수 있다.

#### 분산 복구 프로세스

1. 로컬 복구

가입 멤버가 이전에 그룹에 가입한 적이 있는 경우 릴레이 로그에 미처 적용하지 못한 트랜잭션이 존재할 수 있는데, 이 트랜잭션을 먼저 적용한 후 본격적인 복구 작업을 진행한다.

2. 글로벌 복구

가입 멤버는 그룹의 기존 멤버들에서 기증자 역할을 할 멤버를 선택해서 해당 멤버로부터 데이터 또는 누락된 트랜잭션을 가져와 자신에게 적용한다. 이 작업을 진행하는 동안 `현재 그룹에서 처리되는 트랜잭션을 내부적으로 캐싱`한다.

3. 캐시 트랜잭션 적용

글로벌 복구 단계가 완료되면 캐싱해서 보관되고 있던 트랜잭션을 적용해서 최종적으로 그룹에 참여한다.

#### 분산 복구 오류 처리

그룹 복제의 분산 복구에서는 복구 작업 도중 문제가 발생하더라도 가능한 경우 자동으로 다시 작업을 시도하는 장애 감지 매커니즘이 구현돼 있다. 다음과 같은 경우에서는 자동으로 새로운 그룹 멤버로 연결을 전환해서 다시 작업을 시도한다.

- 기증자로 선택한 그롭 멤버로익 연결이 인증 문제 등으로 인해 정상적으로 이뤄지지 않는 경우
- 바이너리 로그 복제 방식으로 복구 작업읍 진햄하는 증에 레플리케이션 1/0 스레드 또는 SQL 스레드에서 에러가 발생한 경우
- 원격 클론 작업이 실패하거나 혹은 완료되기 전에 중단된 경우 
- 복구 작업 동안 기증자 멤버에서 그룹 복제가 중단된 경우

### 그룹 복제 요구사항

그룹 복제를 사용하려는 MySQL 서버는 데이터 저장시 테이블에 대해 InnoDB 스토리지 엔진을 사용해야 한다. 그룹 복제에서 트랜잭션은 일단 실행된 후 커밋 시 충돌이 있는지 확인하는데, 충돌이 있는 경우 트랜잭션을 롤백하기 때문에 트랜잭션이 지원되는 스토리지 엔진을 사용해야 한다.

이외에도 PK를 사용해야 하고, 원활한 네트워크 통신 환경, 바이너리 로그 활성화, GTID 사용등등 책을 참고..

### 그룹 복제 제약 사항

그룹 복제에는 제약 사항이 존재하는데 그룹 복제는 GTID를 사용하므로 GTID를 사용함으로써 수반되는 제약 사항에도 영향을 받는다.

## MySQL 셸

MySQL 셸은 MySQL을 위한 고급 클라이언트 툴로, 단순히 SQL문 실행만 가능했던 기존 클라이어트 툴인 mysql 보다 조금 더 확장된 기능을 사용자에게 제공한다. 대표적으로 MySQL 셸은 SQL뿐만 아니라 자바스크립트와 파이썬 언어 모드도 지원하고 사용자는 세 언어 중 원하는 언어로 설정할 수 있으며 다른 모드로 손쉽게 전환할 수 있다. MySQL 셸은 기본적으로 자바스크립트 모드로 동작한다.
  
또한 MySQL 셸은 사용자가 MySQL 서버에 대해 편리한 API를 제공하는데, MySQL 서버에서 관계형 데이터와 문서 기반 데이터를 모두 처리할 수 있게 하는 `X DevAPI`와 MySQL 서버 설정을 변경하고 InnoDB 클러스터 및 InnoDB 레플리카 셋을 구축할 수 있게 하는 `AdminAPI`가 있다.

사용자는 MySQL 셸에 내장돼 있는 글로벌 객체들과 각 객체에 구현돼 있는 메서드를 통해 API를 사용할 수 있다.MySQL 셸이 제공하는 글로벌 객체는 다음과 같다. 글로벌 객체는 자바스크립트 및 파이썬 모드에서만 사용할 수 있다.

- session, dba, cluster, rs, db, shell, util

## MySQL 라우터

![image](https://github.com/user-attachments/assets/9f43877d-f4d1-4a33-99c3-5dc1d02be2c1)

MySQL 라우터는 InnoDB 클러스터에서 애플리케이션 서버로부터 `유입된 쿼리 요청을 클러스터 내 적절한 MySQL 서버로 전달`하고 MySQL `서버에서 반환된 쿼리 결과를 다시 애플리케이션으로 전달`하는 프록시 역할을 수행한다.

MySQL 라우터의 중요 기능은 다음과 같다.

- InnoDB 클러스터의 MySQL 구성 변경 자동 감지
- 쿼리 부하 분산
- 자동 페일오버

MySQL 라우터같은 프록시 역할을 하는 프로그램을 사용하지 않는 애플리케이션 서버에서는 MySQL 서버에 직접 연결해서 쿼리를 실행한다. 애플리케이션 서버에서 도메인이나 Virtual IP를 통해 MySQL 서버에 접근하는 형태가 아니라면 애플리케이션 서버는 MySQL 서버의 IP 정보를 커넥션 설정에 저장해서 사용하게 된다. 이 경우에는 MySQL 서버 구성 변경 작업이 발생하면 사용자는 애플리케이션 서버의 DB 커넥션 정보를 반드시 수정하게 된다.
  
반면 InnoDB 클러스터를 사용하는 애플리케이션 서버에서는 MySQL 라우터를 통해 MySQL 서버에 접근하므로 커넥션 설정에는 라우터 서버 정보가 사용된다. MySQL 라우터에서는 클러스터 내 MySQL 서버들에 대한 정보를 메모리에 캐시하고 있으며, 주기적으로 이 정보를 갱신하기 떄문에 사용자는 애플리케이션의 커넥션 설정 정보를 직접 변경할 필요가 없다.
  
MySQL 라우터는 단순히 애플리케이션 서버에서 실행한 쿼리들을 클러스터 내 MySQL 서버들로 전달만 하는 것이 아니라 여러 MySQL 서버에 나눠서 처리되도록 부하 분산을 수행할 수도 있다. 이러한 부하 분산은 MySQL 라우터에서 클러스터로 설정된 라우팅 커넥션 별로 수행되는데, 사용자는 각 커넥션에서 사용하고자 하는 부하 분산 방식을 지정할 수 있다. 
  
또한 MySQL 라우터에는 MySQL 서버에 장애가 발생한 경우 자동으로 다른 MySQL 서버로 쿼리 실행을 재시도 하는데, 이때 지정된 부하 분산 방식에 따라 재시도할 MySQL 서버가 결정되고, 이를 라우터가 감지하고 자동으로 재시도하므로 애플리케이션 서버단에서는 별도의 장애 조치 없이도 정상적으로 쿼리를 실행할 수 있다.

## Reference 

**위 글은 책 RealMySQL 8.0을 구입하여 읽고 정리한 내용입니다.**
- [도서 홈페이지 https://wikibook.co.kr/realmysql801/](https://wikibook.co.kr/realmysql801/)
