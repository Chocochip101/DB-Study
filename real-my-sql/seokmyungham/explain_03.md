# 실행 계획

## 실행 계획 분석

### 분석 - possible_keys 칼럼

possible_keys 칼럼에 있는 내용은 옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방법에서 사용되는 인덱스의 목록일 뿐이다.  
즉 말 그대로 "사용될 법했던 인덱스의 목록"인 것
  
실제로 실행 계획을 보면 그 테이블의 모든 인덱스가 목록에 포함되어 나오는 경우가 허다하기 떄문에 쿼리를 튜닝하는 데 크게 도움이 되지 않는다.
특별한 경우를 제외하고는 그냥 무시하자. 절대 possible_keys 칼럼에 인덱스 이름이 나열됐다고 해서 그 인덱스를 사용한다고 판단하지 않도록 주의하자.

### 분석 - Key 칼럼

Key 칼럼에 표시되는 인덱스는 최종 선택된 실행 계획에서 사용하는 인덱스를 의미한다. 그러므로 쿼리를 튜닝할 때는 Key 칼럼에 의도했던 인덱스가 표시되는지 확인하는 것이 중요하다.
type 칼럼이 all일 때 처럼 인덱스를 전혀 사용하지 못한다면 key 칼럼은 NULL로 표시된다.

### 분석 - key_len 칼럼

key_len 칼럼은 많은 사용자가 쉽게 무시하는 정보지만 사실은 매우 중요한 정보 중 하나이다.  
실제 업무에서 사용하는 테이블은 단일 칼럼으로만 만들어진 인덱스보다 다중 칼럼으로 만들어진 인덱스가 더 많다.  
이 떄 key_len 칼럼의 값은 쿼리를 처리하기 위해 다중 칼럼으로 구성된 인덱스에서 몇 개의 칼럼까지 사용했는지 알려준다. 더 정확히는 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려주는 값이다.

```sql
mysql> explain
    -> select * from dept_emp where dept_no='d005';
+----+-------------+----------+------------+------+---------------+---------+---------+
| id | select_type | table    | partitions | type | possible_keys | key     | key_len |
+----+-------------+----------+------------+------+---------------+---------+---------+
|  1 | SIMPLE      | dept_emp | NULL       | ref  | PRIMARY       | PRIMARY | 16      |
+----+-------------+----------+------------+------+---------------+---------+---------+
1 row in set, 1 warning (0.00 sec)
```

두 개의 칼럼 (dept_no, emp_no)로 구성된 pk를 가지는 dept_emp 테이블을 조회하는 쿼리이다.  
이 때 pk중 dept_no만 비교에 사용한다.
  
dept_no 칼럼의 타입이 CHAR(4)이기 때문에 pk에서 앞쪽 16바이트만 유효하게 사용했다는 의미이다.
dpet_no 칼럼은 utf8mb4 문자 집합을 사용한다. 실제 utf8mb4 문자 집합에서는 문자 하나가 차지하는 공간이 1바이트에서 4바이트까지 가변적이지만 
MySQL 서버가 utf8mb4 문자를 위해 메모리 공간을 할당해야 할 때는 문자와 관계없이 고정적으로 4바이트로 계산하기 때문에 4*4 = 16 바이트가 표시된 것이다.

```sql
mysql> explain
    -> select * from dept_emp where dept_no='d005' and emp_no=10001;
+----+-------------+----------+------------+-------+---------------------------+---------+---------+-------------+------+----------+-------+
| id | select_type | table    | partitions | type  | possible_keys             | key     | key_len | ref         | rows | filtered | Extra |
+----+-------------+----------+------------+-------+---------------------------+---------+---------+-------------+------+----------+-------+
|  1 | SIMPLE      | dept_emp | NULL       | const | PRIMARY,ix_empno_fromdate | PRIMARY | 20      | const,const |    1 |   100.00 | NULL  |
+----+-------------+----------+------------+-------+---------------------------+---------+---------+-------------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

dept_no와 emp_no 모두 조건절에 사용되었다.  
emp_no 컬럼 타입은 INTEGER이며, INTEGER 타빙느 4바이트를 차지한다. 따라서 key_len 칼럼이 dept_no 칼럼의 길이와 emp_no 칼럼의 길이의 합 20으로 표시된 것이다.
  
또는 칼럼 타입이 Nullable일 경우 MySQL 에서는 NULL인지 아닌지를 저장하기 위해 1바이트를 추가로 사용해서 칼럼 타입보다 더 길게 표시되는 경우도 있다.

### 분석 - ref 칼럼

접근 방법이 ref면 동등 비교 조건으로 어떤 값이 제공됐는지 보여준다.
그런데 가끔 ref 칼럼의 값이 func라고 표시될 때가 있다. 이는 참조용으로 사용되는 값을 그대로 사용한 것이 아니라 콜레이션 변환이나 값 자체의 연산을 거쳐서 참조됐다는 것을 의미한다.

### 분석 - rows 칼럼

옵티마이저는 각 조건에 대해 가능한 처리 방식을 나열하고, 각 처리 방식의 비용을 비교해 최종적으로 하나를 선택해서 실행 계획을 수립한다.  
이때 각 처리 방식이 얼마나 많은 레코드를 읽고 비교해야 하는지 예측해서 비용을 산정한다.  
대상 테이블에 얼마나 많은 레코드가 포함돼 있는지 또는 각 인덱스 값의 분포도가 어떤지를 통계 정보를 기준으로 조사해서 예측한다.
  
rows 칼럼값은 실행 계획의 `효율성 판단을 위해 예측했던 레코드 건수`를 보여준다.  
즉 쿼리를 처리하기 위해 `얼마나 많은 레코드를 읽고 체크해야 하는지`를 의미한다.
이 값은 각 스토리지 엔진별로 가지고 있는 통계 정보를 참조해 옵티마이저가 산출해낸 예상값이라 정확하지는 않다.

```sql
mysql> explain
    -> select * from dept_emp where from_date>='1985-01-01';
+----+-------------+----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | dept_emp | NULL       | ALL  | ix_fromdate   | NULL | NULL    | NULL | 331143 |    50.00 | Using where |
+----+-------------+----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.01 sec)

mysql> explain
    -> select * from dept_emp where from_date>='2002-07-01';
+----+-------------+----------+------------+-------+---------------+-------------+---------+------+------+----------+-----------------------+
| id | select_type | table    | partitions | type  | possible_keys | key         | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+----------+------------+-------+---------------+-------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | dept_emp | NULL       | range | ix_fromdate   | ix_fromdate | 3       | NULL |  292 |   100.00 | Using index condition |
+----+-------------+----------+------------+-------+---------------+-------------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
```

첫 번째 쿼리는 옵티마이저가 인덱스(ix_fromdate)를 사용하지 않고 풀 테이블 스캔을 선택한 실행 계획(rows=331143)이고  
두 번째 쿼리는 옵티마이저가 대략 292건의 레코드만 읽고 체크 해보면 원하는 결과를 가져올 수 있을 것이라 판단한 실행 계획임을 알 수 있다.  
이는 전체 테이블 건수의 8.8%밖에 되지 않는다. 그래서 최종적으로 옵티마이저는 range 방식으로 처리한 것이다. 또한 form_date 칼럼이 DATE 타입이므로 key_len에는 3바이트로 표시됐다.


### 분석 - filtered 칼럼

옵티마이저는 각 테이블에서 일치하는 레코드 개수를 정확히 파악해야 좀 더 효율적인 실행 계획을 수립할 수 있다.
실행 계획에서 rows 칼럼의 값은 인덱스를 사용하는 조건에만 일치하는 레코드 건수를 예측한 것이다. 하지만 대부분 쿼리에서 where 절에 사용되는 조건이 모두 인덱스를 사용할 수 있는 것이 아니다.  
  
특히 조인이 사용되는 경우, where 절에서 인덱스를 사용할 수 있는 조건도 중요하지만 인덱스를 사용하지 못하는 조건에 일치하는 레코드 건수를 파악하는 것도 매우 중요하다.

```sql
mysql> explain
    -> select *
    -> from employees e, salaries s
    -> where e.first_name='Matt'
    -> and e.hire_date between '1990-01-01' and '1991-01-01'
    -> and s.emp_no=e.emp_no
    -> and s.from_date between '1990-01-01' and '1991-01-01'
    -> and s.salary between 50000 and 60000;
+----+-------------+-------+------+--------------+------+----------+
| id | select_type | table | type | key          | rows | filtered |
+----+-------------+-------+------+--------------+------+----------+
|  1 | SIMPLE      | e     | ref  | ix_firstname |  233 |    16.03 |
|  1 | SIMPLE      | s     | ref  | PRIMARY      |   10 |     0.48 |
+----+-------------+-------+------+--------------+------+----------+
2 rows in set, 1 warning (0.01 sec)
```

employees 테이블의 first_name 조건은 인덱스를 사용할 수 있고, salaries 테이블의 salary between 조건이 인덱스를 사용할 수 있다.  
이 경우 employees 테이블과 salaries 테이블 중 나머지 조건들까지 합쳐서 최종적으로 일치하는 레코드 건수가 적은 테이블이 드라이빙 테이블로 선정될 가능성이 높다.
  
실행 계획을 보면 employees 테이블이 드라이빙 테이블이 되었다.  
employees 테이블에서 인덱스 조건에만 일치하는 레코드는 233건이며, 이 중에서 16.03%만 인덱스를 사용하지 못하는 e.hire_date between 조건에 일치하는 것을 알 수 있다.  
  
filtered 칼럼의 값은 필터링 되고 남은 레코드의 비율을 의미한다. 그래서 employees 테이블에서 salaries 테이블로 조인을 수행한 레코드 건수는 대략 (233 * 0.1603)건 정도였다는 것을 알 수 있다.  
  
강제로 테이블 조인 순서를 반대로 했을 때 결과는 다음과 같다.

```sql
mysql> explain
    -> select /*+ join_order(s, e) */ *
    -> from employees e, salaries s
    -> where e.first_name='Matt'
    -> and e.hire_date between '1990-01-01' and '1991-01-01'
    -> and s.emp_no=e.emp_no
    -> and s.from_date between '1990-01-01' and '1991-01-01'
    -> and s.salary between 50000 and 60000;
+----+-------------+-------+--------+-----------+------+----------+
| id | select_type | table | type   | key       | rows | filtered |
+----+-------------+-------+--------+-----------+------+----------+
|  1 | SIMPLE      | s     | range  | ix_salary | 3314 |    11.11 |
|  1 | SIMPLE      | e     | eq_ref | PRIMARY   |    1 |     5.00 |
+----+-------------+-------+--------+-----------+------+----------+
2 rows in set, 1 warning (0.00 sec)
```

salaries 테이블을 드라이빙 테이블로 선택했다면 salaries 테이블에서 대략 368건(3314 * 0.1111)이 조건에 일치해서 employees 테이블로 조인을 수행했을 것이다.  
물론 MySQL 서버 옵티마이저는 레코드 건수뿐만 아니라 다른 요소들도 충분히 감안해서 실행 계획을 수립하겠지만 `조인의 횟수를 줄이고 
그 과정에서 읽어온 데이터를 저장해둘 메모리 사용량을 낮추기 위해 대상 건수가 적은 테이블을 선행 테이블로 선택`할 가능성이 높다.
  
그래서 `filtered 칼럼에 표시되는 값이 얼마나 정확히 예측될 수 있느냐에 따라 조인의 성능`이 달라지는 것이다.
  
8.0 버전에서는 filtered 칼럼의 값을 더 정확히 예측할 수 있도록 `히스토그램` 기능이 도입됐다.

### Extra 칼럼

쿼리의 실행 계획에서 성능에 관련된 중요한 내용이 Extra 칼럼에 자주 표시된다.  
Extra 칼럼에는 고정된 몇 개의 문장이 표시되는데, 일반적으로 2~3개씩 함께 표시된다. 아래 정리의 순서는 성능과 무관하다.

### const row not found

쿼리의 실행 계획에서 const 접근 방법으로 테이블을 읽었지만 실제로 해당 테이블에 레코드가 1건도 존재하지 않으면 이 내용이 표시된다.
Extra 칼럼에 이 메시지가 보이는 경우 테이블에 적절히 테스트용 데이터를 저장하고 다시 한번 실행 계획을 확인해 보는 것이 좋다. 

### Full scan or NULL key

이 처리는 `col1 IN (SELECT col2 FROM ...)` 과 같은 조건을 가진 쿼리에서 자주 발생할 수 있다.  
col1의 값이 NULL 이 된다면 결과적으로 조건은 `NULL IN (SELECT col2 FROM ...)`과 같이 바뀐다. SQL 표준에서는 NULL을 "알수 없는 값"으로 정의하고 있다.  
  
위 조건은 다음과 같이 비교된다.

- 서브쿼리가 1건이라도 결과 레코드를 가진다면 최종 비교 결과는 NULL
- 서브쿼리가 1건이라도 결과 레코드를 가지지 않는다면 최종 비교 결과는 FALSE

비교 과정에서 col1이 NULL이면 서브쿼리에 사용된 테이블을 풀 테이블 스캔을 해야만 결과를 알아낼 수 있다.  
따라서 쿼리를 실행하는 중 col1이 NULL을 만나면 차선책으로 서브쿼리 테이블에 대해 풀 테이블 스캔을 사용할 것이라는 사실을 알려주는 키워드다.
  
col1이 NOT NULL로 정의된 칼럼이라면 이러한 차선책은 사용되지 않고 Extra 칼럼에도 표시되지 않을 것이다.  
칼럼이 NOT NULL로 정의되지는 않았지만 이러한 NULL 비교 규칙을 무시해도 된다면, 쿼리 조건에 `col1 IS NOT NULL` 이라는 조건을 지정해 옵티마이저에게 알려주면 된다.
  
Extra 칼럼에 키워드가 표시됐다고 하더라도, IN, NOT IN 왼쪽에 있는 값이 실제로 NULL이 없다면 풀 테이블 스캔은 일어나지 않으므로 걱정하지 않아도 된다.
하지만 IN이나 NOT IN 연산자의 왼쪽 값이 NULL인 레코드가 있고, 서브쿼리에 개별적으로 WHERE 조건이 지정돼 있다면 상당한 성능 문제가 발생할 수 있다.

### IMPOSSIBLE HAVING / WHERE

HAVING이나 WHERE 조건이 항상 FALSE 가 되는 경우 가능성이 없다는 의미로 해당 키워드가 Extra에 표시된다.  
쿼리를 다시 점검해보면 된다.

### No matching min/max row

min(), max() 같은 집합 함수의 조건절에 일치하는 레코드가 없을 때 나타난다. 그리고 min(), max()의 결과로 NULL이 반환된다.

### No matching (row in const table / after partition pruning ... )

마찬가지

### Not exists

프로그램을 개발하다 보면 A 테이블에는 존재하지만 B 테이블에는 없는 값을 조회해야 하는 쿼리가 자주 사용된다.  
이럴 때는 주로 NOT IN(subquery) 형태나 NOT EXISTS 연산자를 주로 사용한다. 이러한 형태의 조인을 안티-조인(Anti-JOIN)이라고 부른다.  
  
똑같은 처리를 아우터 조인(LEFT OUTER JOIN)을 이용해서도 구현할 수 있다.  
일반적으로 NOT IN이나 NOT EXISTS 등의 연산자를 사용하는 안티-조인으로 처리해야 하지만 레코드 건수가 많을 때는 아우터 조인을 사용하면 빠른 성능을 낼 수 있다.

```sql
mysql> explain
    -> select *
    -> from dept_emp de
    -> left join departments d on de.dept_no=d.dept_no
    -> where d.dept_no is null;
```

departments 테이블을 아우터로 조인해서 ON 절이 아닌 WHERE 절에 아우터 테이블(departments)의 dept_no 칼럼이 NULL인 레코드만 체크해서 가져온다.  
즉 안티-조인은 일반 조인(INNER JOIN)을 했을 때 나오지 않는 결과만 가져오는 방법이다.
이렇게 아우터 조인을 이용해 안티-조인을 수행하는 쿼리에서는 실행 계획의 Extra 칼럼에 `NOT EXISTS`가 표시된다.
  
NOT EXISTS 메시지는 옵티마이저가 dept_emp 테이블의 레코드를 이용해 departments 테이블을 조인할 때 departments 테이블의 레코드가
존재하는지 아닌지만 판단한다는 것을 의미한다. 즉 departments 테이블에 조인 조건에 일치하는 레코드가 여러 건 있다 하더라도 딱 1건만 조회해보고 처리를 완료하는 최적화를 의미한다.

### Plan isn't ready yet

8.0 버전에서는 `SHOW PROCESSLIST` 명령어와 `EXPLAIN FOR CONNECTION` 명령어로 다른 커넥션에서 실행 중인 쿼리의 실행 계획을 살펴볼 수 있다.  
`EXPLAIN FOR CONNECTION` 명령은 옵티마이저가 의도된 인덱스를 사용하지 못해서 풀 스캔을 한다거나 잘못된 실행 계획을 선택한 것이 아닌지 확인할 때 유용하다.
  
`EXPLAIN FOR CONNECTION` 명령을 실행했을 때 Extra 칼럼에 Plan isn't ready yet 메시지가 표시될 때가 있는데, 이 경우 해당 커넥션에서 아직
쿼리의 실행 계획을 수립하지 못한 때에 명령이 실행된 것을 의미한다.

### Range checked for each record(index map: N)

```sql
mysql> explain
    -> select *
    -> from employees e1, employees e2
    -> where e2.emp_no >= e1.emp_no;
```

e1 테이블의 레코드를 하나 읽을 때마다 e1.emp_no 값이 계속 바뀌므로 쿼리의 비용 계산을 위한 기준 값이 계속 바뀐다.  
그래서 어떤 접근 방법으로 e2 테이블을 읽는 것이 좋을지 판단할 수 없다.
  
예를 들어 사번이 1번부터 1억번 까지 있다고 가정하면, e1 테이블을 처음부터 끝까지 스캔하면서 e2 테이블에서 조건에 만족하는 레코드를 찾아야 하는데,
문제는 e1.emp_no=1인 경우에는 e2 테이블의 1억 건 전부를 읽어야 한다. 반면 e1.emp_no=1억인 경우 e2 테이블을 한 건만 읽으면 된다.
  
그래서 e1.emp_no가 작을 때는 e2 테이블을 풀 테이블 스캔으로 접근하고, 큰 값일 때는 e2 테이블을 인덱스 레인지 스캔으로 접근하는 형태를 수행하게 될 것이다.  
이렇게 `레코드마다 인덱스 레인지 스캔을 체크한다.`는 의미가 Range checked for each record 의 의미이다.
  
Range checked for each record가 Extra 칼럼에 보이면 type은 ALL로 표시가 되는데, 풀 테이블 스캔으로 처리된 것으로 해석하면 안된다.  
`index map`에 표시된 후보 인덱스를 사용할지 여부를 검토해서 이 후보 인덱스가 별로 도움이 되지 않는다면 최종적으로 풀 테이블 스캔을 사용하기 때문에 ALL로 표시된 것이다.

### Select tables optimized away

MIN(), MAX()만 SELECT 절에 사용되거나 GROUP BY로 MIN(), MAX()를 조회하는 쿼리가 인덱스를 오름차순 또는 내림차순으로 1건만 읽는 형태의 최적화가 적용된다면, 
Extra 칼럼에 Select tables optimized away가 표시된다.
  
인덱스를 이용할 수 있다면 옵티마이저가 위와 같은 최적화가 가능

### Start temporary, End temporary

세미 조인 최적화 중 `Duplicate Weed-out` 최적화 전략이 사용되면 옵티마이저는 실행 계획 Extra 칼럼에 "Start temporary" "End temporary" 를 표시한다.
  
`Duplicate Weed-out` 최적화 전략은 불필요한 중복 건을 제거하기 위해서 내부 임시 테이블을 사용하는데, 이 때 조인되어 내부 임시 테이블에 저장되는 테이블을 식별할 수 있게
첫 번째 테이블에 "Strat temporary" 문구를 보여주고 조인이 끝나는 부분에 "End temporary" 문구를 표시해준다.

```sql
mysql> explain
    -> select * from employees e
    -> where e.emp_no in (select s.emp_no from salaries s where s.salary>150000);
+----+-------------+-------+--------+-----------+-------------------------------------------+
| id | select_type | table | type   | key       | Extra                                     |
+----+-------------+-------+--------+-----------+-------------------------------------------+
|  1 | SIMPLE      | s     | range  | ix_salary | Using where; Using index; Start temporary |
|  1 | SIMPLE      | e     | eq_ref | PRIMARY   | End temporary                             |
+----+-------------+-------+--------+-----------+-------------------------------------------+
```

### unique row not found

두 개의 테이블이 각각 유니크 칼럼으로 아우터 조인을 수행하는 쿼리에서 아우터 테이블에 일치하는 레코드가 존재하지 않을 때 이 코멘트가 표시된다.

### Using filesort

ORDER BY를 처리하기 위해 인덱스를 이용할 수도 있지만 적절한 인덱스를 사용하지 못할 때는, MySQL 서버가 조회한 레코드를 다시 한번 정렬해야 한다.  
ORDER BY 처리가 인덱스를 사용하지 못할 때만 실행 계획에 "Using filesort" 코멘트가 표시되며, 이는 조회된 레코드를 정렬용 메모리 버퍼에 복사해
퀵 소트 또는 힙 소트 알고리즘을 이용해 정렬을 수행하게 된다는 의미이다.
  
`Extra 칼럼에 "Using filesort"가 출력되는 쿼리는 많은 부하를 일으키므로 가능하다면 쿼리를 튜닝하거나 인덱스를 생성하는 것이 좋다.`

### Using index(커버링 인덱스)

인덱스만 읽어서 쿼리를 모두 처리할 수 있을 때 "Using index"가 표시된다.  
인덱스를 이용해 처리하는 쿼리에서 가장 많은 부하를 차지하는 부분은 인덱스 검색에서 일치하는 값들의 레코드를 읽기 위해 데이터 파일을 검색하는 작업이다. 
최악의 경우에는 인덱스를 통해 검색된 결과 레코드 한 건 한 건마다 디스크를 읽어야할 수도 있다.

<img src="https://github.com/seokmyungham/TIL/assets/97608735/6f5d00b4-93f3-4890-81e6-db2d611f4404" width=50%>

위 그림과 같이 employees 테이블에 데이터가 저장돼 있고, 다음의 쿼리가 인덱스 레인지 스캔 접근 방법을 사용한다면?  
인덱스는 first_name 칼럼에 생성된 ix_firstname 인덱스가 존재하고 where 조건절에 일치하는 레코드가 대략 50000건이라 가정한다.

```sql
mysql> explain
    -> select first_name, birth_date
    -> from employees
    -> where first_name between 'Babette' AND 'Gad';
```

이 쿼리가 ix_firstname을 사용한다면 employees 테이블의 first_name 칼럼에 생성된 인덱스를 이용해 일치하는 레코드 5만여 건을 검색하고,  
각 레코드의 birth_date 칼럼의 값을 읽기 위해 각 레코드가 저장된 데이터 페이지를 5만여 번 읽어야한다.
  
실제로 옵티마이저는 위 쿼리를 인덱스를 사용하는 것 보다 풀 테이블 스캔으로 처리하는 편이 더 효율적이라고 판단했다.

```sql
+----+-------------+-----------+------+------+--------+-------------+
| id | select_type | table     | type | key  | rows   | Extra       |
+----+-------------+-----------+------+------+--------+-------------+
|  1 | SIMPLE      | employees | ALL  | NULL | 299969 | Using where |
+----+-------------+-----------+------+------+--------+-------------+
```

그럼 birth_date 칼럼을 빼고 first_name 칼럼만 select 쿼리를 실행시키면, 옵티마이저가 위 쿼리와는 달리 인덱스 레인지 스캔으로 처리하는 것을 볼 수 있다.

```sql
mysql> explain
    -> select first_name
    -> from employees
    -> where first_name between 'Babette' AND 'Gad';
+----+-------------+-----------+-------+--------------+--------------------------+
| id | select_type | table     | type  | key          | Extra                    |
+----+-------------+-----------+-------+--------------+--------------------------+
|  1 | SIMPLE      | employees | range | ix_firstname | Using where; Using index |
+----+-------------+-----------+-------+--------------+--------------------------+
```

위 쿼리는 인덱스를 통해서 필요한 레코드를 검색하고 필요한 칼럼(first_name)까지 인덱스에서 가져올 수 있다.  
즉 필요한 칼럼이 모두 인덱스에 있으므로 데이터 파일을 읽어 올 필요가 없다. 이 쿼리는 디스크에서 30~40개 페이지만 읽으면 되기 때문에 매우 빠른 속도로 처리된다.
  
위와 같이 인덱스만으로 쿼리를 처리할 수 있을 때 Extra 칼럼에는 `Using index`라는 메시지가 출력된다.  
이렇게 인덱스만으로 처리되는 것을 커버링 인덱스라고 한다. 인덱스 레인지 스캔을 사용하지만 쿼리의 성능이 만족스럽지 못한 경우라면 
인덱스에 있는 칼럼만 사용하도록 쿼리를 변경해 큰 성능 향상을 볼 수 있다.

<img src="https://github.com/seokmyungham/TIL/assets/97608735/bd4c9057-f273-4b85-b9a2-1f8b8502c8e2" width=50%>
   
InnoDB의 모든 테이블은 클러스터링 인덱스로 구성돼 있다. 그리고 이 때문에 모든 세컨더리 인덱스는 데이터 레코드의 주솟값으로 pk 값을 가진다.  
인덱스의 "레코드 주소" 값에 employees 테이블의 pk인 emp_no가 저장된 것을 볼 수 있다.
  
InnoDB 테이블에서는 first_name 칼럼만으로 인덱스를 만들어도 결국 그 인덱스에 emp_no 칼럼이 같이 저장되는 효과를 낸다.  
이러한 클러스터링 인덱스 특성 때문에 쿼리가 커버링 인덱스로 처리될 가능성이 상당히 높다.

```sql
mysql> explain
    -> select emp_no, first_name
    -> from employees
    -> where first_name between 'Babette' and 'Gad';
+----+-------------+-----------+-------+--------------+--------------------------+
| id | select_type | table     | type  | key          | Extra                    |
+----+-------------+-----------+-------+--------------+--------------------------+
|  1 | SIMPLE      | employees | range | ix_firstname | Using where; Using index |
+----+-------------+-----------+-------+--------------+--------------------------+
```
  
위 쿼리도 같은 where 조건으로 인해 first_name 칼럼의 인덱스를 이용해 일치하는 레코드를 검색할 것이다.  
뿐만 아니라 select 시 emp_no 칼럼도 가져와야 하는데, emp_no는 employees 테이블의 pk이기 때문에 이미 세컨더리 인덱스에 포함되어 있어 데이터 파일을 읽지 않아도 된다.
  
즉 InnoDB 세컨더리 인덱스에는 데이터 레코드를 찾아가기 위한 주소로 사용하기 위해 pk를 저장해두는 것이지만, 추가 칼럼을 하나 더 가지는 인덱스의 효과를 동시에 얻을 수 있다.
  
레코드 건수에 따라 차이가 있겠지만 쿼리를 커버링 인덱스로 처리할 수 있을 때와 그렇지 못할 때의 성능 차이는 수십 배에서 수백 배까지 날 수 있다. 
하지만 무조건 커버링 인덱스로 처리하려고 인덱스에 많은 칼럼을 추가하면 더 위험한 상황이 초래될 수 있다.
너무 과도하게 인덱스의 칼럼이 많아지면 인덱스의 크기가 커져서 메모리 낭비가 심해지고 레코드를 저장하거나 변경하는 작업이 매우 느려질 수 있기 때문이다.
  
접근 방법인 type 칼럼이 eq_ref, ref, range, index_merge, index 등과 같이 인덱스를 사용하는 실행 계획에서는 모두 Extra 칼럼에 Using index가 표시될 수 있다.
즉 인덱스 레인지 스캔을 사용할 때만 커버링 인덱스로 처리되는 것은 아니다. 인덱스 풀 스캔(type=idnex)을 실행할 때도 커버링 인덱스로 처리될 수 있는데,
이때도 똑같은 인덱스 풀 스캔의 접근 방법이라면 커버링 인덱스가 아닌 경우보다 훨씬 빠르게 처리된다.

### Using where

MySQL 서버는 내부적으로 MySQL 엔진과 스토리지 엔진이라는 두 개의 레이어로 나눠 볼 수 있다.  
각 스토리지 엔진은 디스크나 메모리상에서 필요한 레코드를 읽거나 저장하는 역할을 하며, MySQL 엔진은 스토리지 엔진으로 받은 레코드를 가공 또는 연산하는 작업을 수행한다.
이 때 MySQL 엔진 레이어에서 별도의 가공을 해서 필터링 작업을 처리한 경우에만 Extra 칼럼에 "Using where" 코멘트가 표시된다.


각 스토리지 엔진에서 전체 200건의 레코드를 읽었는데 MySQL 엔진에서 별도의 필터링이나 가공 없이 그 데이터를 그대로 클라이언트로 전달하면 Using where 코멘트는 표시되지 않는다.
  
작업 범위 결정 조건과 체크 조건 중 작업 범위 결정 조건은 각 스토리지 엔진 레벨에서 처리되지만 체크 조건은 MySQL 엔진 레이어에서 처리된다.

```sql
mysql> explain
    -> select *
    -> from employees
    -> where emp_no between 10001 and 10100
    -> and gender='F';
+----+-------------+-----------+-------+---------+------+----------+-------------+
| id | select_type | table     | type  | key     | rows | filtered | Extra       |
+----+-------------+-----------+-------+---------+------+----------+-------------+
|  1 | SIMPLE      | employees | range | PRIMARY |  100 |    50.00 | Using where |
+----+-------------+-----------+-------+---------+------+----------+-------------+
```

이 쿼리에서 작업 범위 결정 조건은 emp_no between 조건이고 체크 조건은 gender 조건임을 알 수 있다.  
처음 emp_no 조건만 만족하는 레코드 건수는 100건이지만, 두 조건을 모두 만족하는 레코드는 37건밖에 안된다.  
이는 스토리지 엔진은 100개를 읽어서 MySQL 엔진에게 넘겨줬지만, MySQL 엔진은 그중에서 63건의 레코드를 그냥 필터링해서 버렸다는 의미가 된다.  
여기서 Using where는 63건의 레코드를 버리는 처리를 의미한다.
  
실행 계획에서 Extra 칼럼에 가장 흔히 표시되는 내용이 "Using where"다.  
그래서 가장 쉽게 무시해버리는 메시지이기도 하면서, 왜 Using where가 표시됐는지 이해할 수 없을 때도 많다.  
그래서 실행 계획의 Using where가 성능상의 문제를 일으킬지 아닐지를 적절히 선별하는 능력이 필요한데, 8.0 버전에서는 실행 계획에 filtered 칼럼이 같이 표시되므로
쉽게 성능상의 이슈가 있는지 없는지를 알아낼 수 있다.
  
위 실행 계획에서는 filtered 칼럼의 값이 50%인 것을 보면 옵티마이저는 100건 중에서 50건은버려지고 최종 남은 50건이 반환될 것으로 예측했다는 것을 알 수 있다.
  
인덱스 최적화를 조금 더 살펴보면 최종적으로 쿼리에 일치하는 레코드는 37건밖에 안 되지만 스토리지 엔진은 100건의 레코드를 읽은 것이다.  
이는 상당히 비효율적인 과정이라고 볼 수 있다. employees 테이블에 (emp_no, gender)로 인덱스가 준비돼 있었다면 어떻게 될까?  
이 때는 두 조건 모두 작업 범위의 제한 조건으로 사용되어 필요한 37개의 레코드만 정확하게 읽을 수 있다.

## Reference 

**위 글은 책 RealMySQL 8.0을 구입하여 읽고 정리한 내용입니다.**
- [도서 홈페이지 https://wikibook.co.kr/realmysql801/](https://wikibook.co.kr/realmysql801/)
