# 쿼리 작성 및 최적화

## SELECT

### JOIN

인덱스 레인지 스캔은 인덱스를 탐색하는 단계와 인덱스를 스캔하는 과정으로 구분해 볼 수 있다. 일반적으로 인덱스를 스캔하는 작업은 부하가 작지만
인덱스 키를 찾는 인텍스 탐색 작업은 부하가 높은 편이다.
  
조인 작업에서 드라이빙 테이블을 읽을 때는 인덱스 탐색 작업을 단 한 번만 수행하고, 그 이후부터는 스캔만 실행하면 된다.
하지만 드리븐 테이블에서는 인덱스 탐색 작업과 스캔 작업을 드라이빙 테이블에서 읽은 레코드 건수만큼 반복한다.
드라이빙 테이블과 드리븐 테이블이 1대1로 조인되더라도 드리븐 테이블을 읽는 것이 훨씬 더 큰 부하를 차지한다.
그래서 옵티마이저는 항상 드리븐 테이블을 최적으로 읽을 수 있도록 실행계획을 수립한다. 

```sql
SELECT *
FROM employees e, dept_emp de
WHERE e.emp_no=de.emp_no;
```

#### 두 칼럼 모두 각각 인덱스가 있는 경우

두 테이블에 emp_no 칼럼에 대해 인덱스가 모두 존재하는 경우 어느 테이블을 드라이빙 테이블로 선택하든 인덱스를 이용해
드리븐 테이블의 검색 작업을 빠르게 처리할 수 있다. 이럴 때 옵티마이저가 통계 정보를 이용해서 적절히 드라이빙 테이블을 선택한다.

#### employees.emp_no에만 인덱스가 있는 경우

employees.emp_no에만 인덱스가 있는데 만약 dept_emp 테이블을 드리븐 테이블로 선택하면
employees 테이블의 레코드 건수만큼 dept_emp 테이블을 풀스캔해서 where 절을 만족해야한다.
그레서 옵티마이저는 항상 dept_emp 테이블을 드라이븐 테이블로 선택하고 employees 테이블을 드리븐 테이블로 선택한다.

#### dept_emp.emp_no에만 인덱스가 있는 경우

위와 반대로 처리된다. employees 테이블의 반복되는 풀 스캔을 피하기 위해 employees 테이블을 드라이빙 테이블로 선택하도록 실행 계획을 수립한다.

#### 두 칼럼 모두 인덱스가 없는 경우 

어느 테이블을 드라이빙으로 선택하더라도 드리븐 테이블의 풀 스캔은 발생하기 때문에 옵티마이저가 적절히 드라이빙 테이블을 선택한다.
단 이때는 레코드 건수가 적은 테이블을 드라이빙 테이블로 선택하는 것이 훨씬 효율적이다.
 
#

#### OUTER JOIN의 성능과 주의 사항

```SQL
SELECT *
FROM employees e
LEFT JOIN dept_emp de ON de.emp_no=e.emp_no
LEFT JOIN departments d ON d.dept_no=de.dept_no AND d.dept_name='Development';
```

위 쿼리를 실행 시 employees 테이블을 풀 스캔하면서 dept_emp 테이블과 departments 테이블을 드리븐 테이블로 사용하게 된다.
  
MySQL 옵티마이저는 절대 아우터로 조인되는 테이블을 드라이빙 테이블로 선택하지 못하기 때문에 풀 스캔이 필요한 employees 테이블을 드라이빙 테이블로 선택한다.
때문에 쿼리의 성능이 떨어지는 실행 계획을 수립하게 된다.
  
위 쿼리에 이너 조인을 사용했다면 departments 테이블에서 부서명이 'Development'인 레코드 1건만 찾아서 조인을 실행하는 실행 계획을 수립했을 것이다.
이너 조인으로 사용해도 되는 쿼리를 아우터 조인으로 작성하면 MySQL 옵티마이저가 조인 순서를 변경하면서 수행할 수 있는 최적화의 기회를 빼앗아버린다.
꼭 필요한 경우가 아니라면 이너 조인을 사용하는 것이 쿼리의 성능을 향상시키는데 도움을 줄 수도 있다.

```sql
SELECT *
FROM employees e
LEFT JOIN dept_manager mgr ON mgr.emp_no=e.emp_no
WHERE mgr.dept_no='d001';
```

아우터 조인 쿼리를 작성하면서 많이 하는 실수는 아우터로 조인되는 테이블에 대한 조건을 WHERE 절에 함께 명시하는 것이다.
아우터로 조인되는 테이블인 dept_manager의 dept_no='d001' 조건을 WHERE 절에 명시하는 것은 잘못된 조인 방법이다. 위 쿼리는 
WHERE 절의 조건 때문에 MySQL 옵티마이저가 LEFT JOIN을 INNER JOIN으로 변환해서 실행해 버린다.

#### 지연된 조인(Delayed Join)

조인을 사용해서 데이터를 조회하는 쿼리에 GROUP BY, ORDER BY를 사용할 때 각 처리 방법에 인덱스를 사용하고 있다면 이미
최적으로 처리되고 있을 가능성이 높다.
  
조인은 대체로 실행되면 될수록 결과 레코드 건수가 늘어난다. 그래서 조인의 결과를 GROUP BY하거나 ORDER BY하면 조인을 실행하기 전보다 
더 많은 레코드를 처리해야 한다. 지연된 조인이란 조인이 실행되기 이전에 GROUP BY나 ORDER BY를 처리하는 방식을 의미한다.
지연된 조인은 주로 LIMIT이 함께 사용된 쿼리에서 더 큰 효과를 얻을 수 있다.

```SQL
SELECT e.* 
FROM salaries s, employees e 
WHERE e.emp_no=s.emp_no 
AND s.emp_no BETWEEN 10001 AND 13000 
GROUP BY s.emp_no 
ORDER BY SUM(s.salary) DESC 
LIMIT 10;

+----+-------+-------+---------+------+----------------------------------------------+
| id | table | type  | key     | rows | Extra                                        |
+----+-------+-------+---------+------+----------------------------------------------+
|  1 | e     | range | PRIMARY | 3000 | Using where; Using temporary; Using filesort |
|  1 | s     | ref   | PRIMARY |    9 | NULL                                         |
+----+-------+-------+---------+------+----------------------------------------------+
2 rows in set, 1 warning (0.04 sec)
```

실행 계획 상 employees 테이블을 드라이빙 테이블로 선택해서 `s.emp_no BETWEEN 10001 AND 13000` 조건을 만족하는 레코드 3000건을 읽고
salaries 테이블을 조인했다. 이때 조인을 수행한 횟수가 12000번이라면 12000건의 레코드를 임시 테이블에 저장하고 GROUP BY 처리를 통해 3000건으로 줄인 것이다.
그리고 ORDER BY를 처리해서 상위 10건만 최종적으로 반환한다.

```SQL
SELECT e.*
FROM
    (SELECT s.emp_no 
     FROM salaries s 
     WHERE s.emp_no BETWEEN 10001 AND 13000 
     GROUP BY s.emp_no 
     ORDER BY SUM(s.salary) DESC 
     LIMIT 10) x, employees e 
WHERE e.emp_no=x.emp_no;


+----+------------+--------+---------+-------+----------------------------------------------+
| id | table      | type   | key     | rows  | Extra                                        |
+----+------------+--------+---------+-------+----------------------------------------------+
|  1 | <derived2> | ALL    | NULL    |    10 | NULL                                         |
|  1 | e          | eq_ref | PRIMARY |     1 | NULL                                         |
|  2 | s          | range  | PRIMARY | 56844 | Using where; Using temporary; Using filesort |
+----+------------+--------+---------+-------+----------------------------------------------+
3 rows in set, 1 warning (0.00 sec)
```

지연된 조인으로 변경한 쿼리와 실행 계획이다.
FROM 절에 서브쿼리가 사용됐기 때문에 파생 테이블(DERIVED)로 처리됐다. 위 실행 계획에서 FROM 절의 서브쿼리를 위해 전체
56,844 건의 레코드를 읽어야 한다고 나왔지만 사실은 28,606건의 레코드만 읽으면 된다. 지연된 조인으로 변경된 쿼리는 salaries 테이블에서
28,606건의 레코드를 읽어 임시 테이블에 저장하고, GROUP BY를 통해 3000건으로 줄였다. 그리고 ORDER BY를 처리해 상위 10건만 
임시 테이블(<derived2>)에 저장한다. 최종적으로 임시 테이블의 10건을 읽어서 employees 테이블과 조인을 10번만 수행하고 결과를 반환한다.
  
지연된 조인으로 개선된 쿼리는 임시 테이블을 한 번 더 사용하기 때문에 느리다고 예상할 수 있지만, 임시 테이블에 저장할 레코드가
10건밖에 되지 않으므로 메모리를 이용해 빠르게 처리된다. 조인의 횟수를 비교해보면 지연된 쿼리로 변경된 쿼리가 훨씬 적다는 것을 알 수 있고
실행 계획상으로만 보면 지연된 조인이 더 느릴 것 같지만 실제로는 3~4배 정도는 더 빠르게 실행된다.
  
지연된 쿼리의 원리를 정확하게 이해하지 못한 채로 지연된 쿼리를 작성하면 오히려 역효과가 날 수도 있다.
하지만 잘 튜닝된 지연된 쿼리는 원래의 몇십 배, 몇백 배 나은 성능을 보일 수도 있다.
  
모든 쿼리를 지연된 조인 형태로 개선할 수 있는 것은 아니다. OUTER JOIN과 INNER JOIN에 대해 다음과 같은 조건이 갖춰져야만 지연된 쿼리로 변경해서 사용할 수 있다.

- LEFT (OUTER) JOIN 인 경우 드라이빙 테이블과 드리븐 테이블은 1:1 또는 M:1 관계여야 한다.
- INNER JOIN의 경우 드라이빙 테이블과 드리븐 테이블은 1:1, M:1의 관계임과 동시에 드라이빙 테이블에 있는 레코드는 드리븐 테이블에 모두 존재해야 한다. 두 번째와 세 번째 조건은 드라이빙 테이블은 서브쿼리로 만들고 이 서브쿼리에 LIMIT 을 추가해도 최종 결과의 건수가 변하지 않는다는 보증을 해주는 조건이다.
 
지연된 조인은 조인의 개수를 줄이는 것뿐만 아니라 GROUP BY나 ORDER BY 처리가 필요한 레코드의 전체 크기를 줄이는 역할도 한다.

### ORDER BY

ORDER BY에서 인덱스를 사용하지 못할 때는 추가 정렬 작업이 수행되며, 쿼리 실행 계획에 있는 Extra 칼럼에 `Using filesort`라는 코멘트가 표시된다.
  
ORDER BY 절은 1개 또는 그 이상 여러 개의 칼럼으로 정렬을 수행할 수 있다. 그리고 8.0 버전부터 오름차순과 내림차순을 혼용해서 인덱스를 생성할 수 있게 개선됐다. 

```SQL
ALTER TABLE salaries ADD INDEX is_salary_fromdate (salary DESC, from_date ASC);
```

특정 쿼리가 내림차순으로만 레코드를 정렬해서 가져간다면 인덱스는 당연히 DESC를 생성하는 것이 좋다.

## Reference 

**위 글은 책 RealMySQL 8.0 2권을 구입하여 읽고 정리한 내용입니다.**
- [도서 홈페이지 https://wikibook.co.kr/realmysql802/](https://wikibook.co.kr/realmysql802/)
