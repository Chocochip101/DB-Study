# InnoDB 스토리지 엔진 아키텍처

## InnoDB 버퍼 풀

디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다. 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 하는 버퍼 역할도 같이 한다.
일반 애플리케이션에서는 데이터를 변경하는 쿼리가 데이터 파일의 이곳저곳에 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시키지만, 
버퍼 풀을 이용하면 변경한 데이터를 모아 일괄 처리하여 랜덤한 디스크 작업의 횟수를 줄일 수 있다.  

MySQL 5.7 버전부터 InnoDB 버퍼 풀의 크기를 동적으로 조절할 수 있게 되었다. 그래서 가능하면 InnoDB 버퍼 풀의 크기를 적절히 작은 값으로 설정해서 조금씩 상황을 봐 가면서 증가시키는 것이 좋다. 
  
InnoDB 버퍼풀의 크기는 운영체제와 각 클라이언트 스레드가 사용할 메모리를 충분히 고려해서 설정해야 한다. 운영체제의 전체 메모리 공간이 8GB 미만이라면 50% 정도만 InnoDB 버퍼 풀로 설정하는 것이 좋다.
전체 메모리 공간이 그 이상이라면, 전체 메모리의 50%에서 시작해서 조금씩 올려가며 최적점을 찾는다. 전체 메모리 공간이 50GB 이상이라면, 대략 15GB에서 30GB 정도를 운영체제와 다른 응용 프로그램을 위해 남겨두고
나머지를 InnoDB 버퍼 풀로 할당하는 것이 좋다.  

InnoDB 버퍼 풀은 `innodb_buffer_pool_size` 시스템 변수로 크기를 설정할 수 있다. 변경 시점은 서버가 한가할 때 진행하고, 버퍼 풀을 더 크게 변경하는 작업은 시스템 영향도가 크지 않지만, 크기를 줄이는 작업은 시스템 영향도가 매우 크므로 가능하면 하지 않도록 주의해야한다. 

> 버퍼 풀은 내부적으로 128MB 단위로 처리되므로 크기를 동적으로 변경해야 한다면 https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool-resize.html 내용을 숙지하고 진행하자.

InnoDB 버퍼 풀은 전통적으로 버퍼 풀 전체를 관리하는 잠금으로 인해 내부 잠금 경합을 많이 유발해왔는데, 버퍼 풀이 여러 개로 쪼개어 관리될 수 있도록 개선 됨에 따라 경합 유발이 개선되었다. 
각 버퍼 풀 인스턴스는 8개로 초기화 되지만 전체 버퍼 풀을 위한 메모리 크기가 1GB 미만이면 버퍼 풀 인스턴스는 1개만 생성된다.

## 버퍼 풀 구조

InnoDB 버퍼 풀은 페이지 크기의 조각으로 나뉘어, InnoDB 스토리지 엔진이 데이터를 필요로 할 때 디스크로부터 해당 데이터 페이지를 읽어서 각 조각에 저장하도록 설계되어 있다.

버퍼 풀의 페이지 크기 조각을 관리하기 위해 InnoDB 스토리지 엔진은 크게 `LRU 리스트`, `플러시 리스트`, `프리 리스트` 3개의 자료 구조를 관리한다.

### LRU 리스트

LRU 리스트는 엄밀하게 MRU 서브 리스트와 LRU 서브 리스트가 결합된 형태이다. LRU 리스트를 관리하는 목적은 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 버퍼 풀 메모리에 유지해서 디스크 읽기를 최소화하는 데 있다.

InnoDB 스토리지 엔진에서 데이터를 찾는 과정은 다음과 같다.
```
1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
  - InnoDB 어댑티브 해시 인덱스를 이용해 페이지를 검색한다.
  - 해당 테이블의 인덱스(B-Tree)를 이용해 버퍼 풀에서 페이지를 검색한다.
  - 버퍼 풀에 이미 데이터 페이지가 있다면 해당 페이지의 포인터를 MRU 방향으로 승급한다.
2. 버퍼 풀에 없다면 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
3. 이후 캐시 히트가 발생하면 해당 페이지를 MRU 헤더 부분으로 이동
4. 데이터 페이지는 나이(Age)가 부여되어 오랫동안 참조되지 않으면 LRU 끝으로 밀려나다가 결국 버퍼 풀에서 제거
5. 필요한 데이터가 자주 참조된다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가
```

### 플러시 리스트

플러시 리스트는 디스크로 동기화되지 않은 더티 페이지의 변경 시점 기준의 페이지 목록을 관리한다. 일단 한 번 데이터 변경이 가해지면 해당 데이터 페이지는 플러시 리스트에 관리되고 특정 시점이 되면 디스크로 기록된다.
  
데이터가 변경되면 InnoDB는 변경 내용을 `리두 로그`에 기록하고 `버퍼 풀의 데이터 페이지`에도 변경 내용을 반영한다. 그래서 리두 로그의 각 엔트리는 특정 데이터 페이지와 연결된다.
  
리두 로그가 디스크로 기록됐다고 해서 데이터 페이지가 디스크로 기록됐다는 것을 항상 보장하지는 않고, InnoDB 스토리지 엔진은 체크포인트를 발생시켜 디스크의 `리두 로그`와 `데이터 페이지`의 상태를 `동기화`한다.
해당 체크포인트는 MySQL 서버가 시작될 때 InnoDB 스토리지 엔진이 리두 로그의 어느 부분부터 복구를 실행해야 할지 판단하는 기준점을 만드는 역할을 하게된다.

## 버퍼 풀과 리두 로그

InnoDB의 버퍼 풀 크기는 크게 설정하면 할수록 쿼리의 성능이 빨라지는데, 단순히 메모리 공간을 늘리는 것은 데이터 캐시 기능만 향상시키는 것이다. InnoDB의 버퍼링 기능까지 향상시키기 위해서는 버퍼 풀과 리두 로그의 관계를 이해해야한다.

InnoDB 버퍼 풀은 디스크로 읽은 후 데이터가 전혀 변경되지 않은 `클린 페이지`, 변경된 데이터를 가진 `더티 페이지`를 모두 가지고 있다. 더티 페이지는 버퍼 풀과 디스크의 데이터 상태가 다르기 때문에 언젠가는 디스크로 기록되어야 한다.
하지만 더티 페이지는 버퍼 풀에 무한정 머무를 수 없다.
  
리두 로그는 1개 이상의 고정 크기 파일을 연결해서 순환 고리 처럼 사용한다. 이 말은 데이터 변경이 계속해서 일어나면 기존 리두 로그 파일에 기록됐던 엔트리가 새로운 로그 엔트리로 덮어 씌워질 수 있음을 뜻한다.
그래서 InnoDB 스토리지 엔진은 전체 리두 로그 파일에서 재사용 불가능한 공간인 `활성 리두 로그`를 재사용 가능한 공간과 구분해서 관리한다. 
> 여기서 `재사용 불가`능하다는 뜻은 해당 리두 로그 공간에 데이터 변경 내용이 기록되어 새로운 로그 엔트리가 기록되면 안된다는 의미를 말한다.

InnoDB 스토리지 엔진은 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화하는데, 발생한 체크포인트 중 가장 최근 체크포인트 지점의 `LSN(Log Sequence Number)`가 활성 리두 로그 공간의 시작점이 된다.
그리고 가장 최근 체크포인트의 LSN과 마지막 리두 로그 엔트리의 LSN의 차이를 `체크포인트 에이지`라고 한다. 즉 체크포인트 에이지는 활성 리두 로그 공간의 크기를 뜻한다.
  
체크포인트가 발생하면 체크포인트 LSN보다 작은 리두 로그 엔트리와 관련된 더티 페이지는 모두 디스크로 동기화돼야 한다. 물론 당연히 체크포인트 LSN보다 작은 LSN 값을 가진 리두 로그 엔트리도 디스크로 동기화돼야 한다.
즉 버퍼 풀의 더티 페이지, 리두 로그 모두 다 디스크로 동기화돼야 한다.

그래서 실제 쓰기 버퍼링의 성능을 향상시키기 위해서는 리두 로그 파일의 크기를 적절히 선택하는게 중요하다. 버퍼 풀의 크기가 100GB 이하의 MySQL 서버에서는 리두 로그 파일의 전체 크기를 대략 5~10GB 수준으로 선택하고
필요할 때마다 조금씩 늘려가면서 최적값을 선택하는게 좋다.

## 버퍼 풀 플러시

InnoDB 스토리지 엔진은 버퍼 풀의 더티 페이지들을 성능 상 악영향 없이 디스크에 동기화하기 위해 다음과 같이 2개의 플러시 기능을 백그라운드로 실행한다.

- 플러시 리스트 플러시
- LRU 리스트 플러시

### 플러시 리스트 플러시

리두 공간을 재활용하려면 주기적으로 오래된 리두 로그 엔트리가 사용하는 공간을 비워줘야 한다. 그런데 이때 오래된 리두 공간을 지우기 전에 반드시 InnoDB 버퍼 풀의 더티 페이지가 먼저 디스크로 동기화되는 작업이 선행되어야 한다.
이를 위해서 InnoDB 스토리지 엔진은 주기적으로 `플러시 리스트 플러시` 함수를 호출해서 플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화 하는 작업을 수행한다.
  
이때 언제부터 얼마나 많은 더티 페이지를 디스크로 기록하느냐에 따라 사용자 쿼리가 악영향을 받지 않으면서 부드럽게 처리된다. 이와 관련해서 InnoDB 스토리지 엔진은 다양한 시스템 변수들을 제공한다.

- `innodb_page_cleaners`

해당 시스템 변수로 더티 페이지를 디스크로 동기화하는 `클리너 스레드`의 개수를 조절할 수 있다. 이 값이 버퍼 풀 인스턴스 개수보다 많은 경우, 각 클리너 스레드가 하나의 버퍼 풀 인스턴스를 처리하도록 자동으로 조절된다. 
반면에 이 값이 버퍼 풀 인스턴스 개수보다 적으면, 하나의 클리너 스레드가 여러 개의 버퍼 풀 인스턴스를 처리하게 된다.

- `innodb_max_dirty_pages_pct_lwm`

InnoDB 스토리지에 존재할 최소 더티 페이지 비율을 조절할 수 있다. 더티 페이지 비율은 현재 메모리에 있는 변경된 데이터 페이지 중 디스크로 동기화되지 않은 비율을 나타낸다. 이 값을 기준으로 InnoDB는 클리너 스레드가 작동하는 빈도를 조절하게 된다.
  
기본 값은 10% 수준인데 만약 더티 페이지의 비율이 얼마 되지 않은 상태에서 디스크 쓰기가 많이 발생하고 더티 페이지의 비율이 너무 낮은 상태로 머물러 있다면 시스템 변수를 조금 더 높은 값으로 조정해서 디스크 쓰기 횟수를 줄이는 효과를 얻을 수 있다.

- `innodb_max_dirty_pages_pct` 

InnoDB 스토리지에 존재할 최대 더티 페이지 비율을 조절할 수 있다. 일반적으로 InnoDB 버퍼 풀은 더티 페이지를 많이 가지고 있을수록 디스크 쓰기 작업을 버퍼링함으로써 여러 번의 디스크 쓰기를 한 번으로 줄이는 효과를 극대화할 수 있다.
해당 시스템 설정은 가능하면 기본 값을 유지하는 것이 좋다.

- `innodb_io_capacity`, `innodb_io_capacity_max`

각 데이터베이스 서버에서 어느 정도의 디스크 읽고 쓰기가 가능한지를 설정하는 값이다. `innodb_io_capacity`는 일반적인 상황에서 디스크가 적절히 처리할 수 있는 수준의 값을 설정하며 `innodb_io_capacity_max` 시스템 변수는 디스크가 최대 성능을 발휘할 때
어느 정도의 디스크 읽고 쓰기가 가능한지를 설정한다. 여기서 언급하는 디스크 읽고 쓰기란 백그라운드 스레드가 수행하는 디스크 작업을 의미하는데 대부분 InnoDB 버퍼 풀의 더티 페이지 쓰기가 이에 해당한다.

하지만 InnoDB 스토리지 엔진은 사용자의 쿼리를 처리하기 위해 디스크 읽기도 해야한다. 그러므로 현재 장착된 디스크가 초당 1000IOPS를 처리할 수 있다고 해서 이 값을 그대로 위 두 시스템 변수에 설정해서는 안된다.

- `innodb_adaptive_flushing`, `innodb_adaptive_flushing_lwm`

관리해야 할 MySQL 서버가 많은 경우 서버의 트래픽을 모두 봐가면서 capacity 시스템 변수를 설정하는 것은 상당히 번거롭다. 그래서 InnoDB 스토리지 엔진은 `어댑티브 플러시`라는 기능을 제공한다.

`어댑티브 플러시`는 `innodb_adaptive_flushing` 시스템 변수로 켜고 끌 수 있고 기본 값은 활성화이다. 어댑티브 플러시 기능을 활성화하면 InnoDB 스토리지 엔진은 단순히 버퍼 풀의 더티 페이지 비율이나 `innodb_io_capacity`, `innodb_io_capacity_max`
설정값에 의존하지 않고 새로운 알고리즘을 사용한다.
  
어댑티브 플러시 알고리즘은 리두 로그의 증가 속도를 분석해서 적절한 수준의 더티 페이지가 버퍼 풀에 유지될 수 있도록 디스크 쓰기를 실행한다. `innodb_adaptive_flushing_lwm` 시스템 변수의 기본 값은 10%이며, 
전체 리두 로그 공간에서 활성 리두 로그의 공간이 10% 넘어설 때 부터 어댑티브 플러시 알고리즘이 작동하게 된다.

- `innodb_flush_neighbors`

해당 시스템 변수는 더티 페이지를 디스크에 기록할 때 근접한 페이지 중 더티 페이지가 존재하면 InnoDB 스토리지 엔진이 함께 묶어 디스크로 기록하게 하는 기능이다.
  
HDD의 경우 디스크 읽고 쓰기는 매우 고비용의 작업이어서, 과거 많은 데이터베이스 서버들은 한 번이라도 디스크 읽고 쓰는 작업을 줄이고자 많은 노력을 기울였다.
데이터 저장을 HDD로 하고 있다면 위 시스템 변수를 1 또는 2로 설정해서 활성화하는 것이 좋다.

요즘은 대부분 SDD(솔리드 스테이트 드라이브)를 사용하고, 기존의 하드 디스크보다 훨씬 빠른 읽기 및 쓰기 속도를 가진다. 
하드 디스크와 달리 SSD는 읽기/쓰기 지연 시간이 없거나 매우 낮기 때문에 주변 페이지를 같이 플러시하는 것 보다 순차적으로 플러시하는 것이 효율적이다. 또한 불필요한 SSD의 수명 단축을 예방할 수 있다. 따라서 기본값인 비활성 모드로 유지하는 것이 좋다.

### LRU 리스트 플러시

InnoDB 스토리지 엔진은 LRU 리스트에서 사용 빈도가 낮은 페이지들을 제거해서 새로운 페이지들을 읽어올 공간을 만들기 위해, `LRU 리스트 플러시` 함수를 사용한다. LRU 리스트의 끝부분부터 시작해서
최대 `innodb_lru_scan_depth` 시스템 변수에 설정된 개수만큼 페이지들을 스캔한다.
  
스캔하면서 더티 페이지는 디스크에 동기화하고, 클린 페이지는 즉시 프리 리스트로 페이지를 옮긴다. InnoDB 스토리지 엔진은 InnoDB 버퍼 풀 인스턴스 별로 최대 `innodb_lru_scan_depth` 개수만큼 스캔하기 때문에
실질적인 LRU 리스트 스캔은 `innodb_buffer_pool_instances` * `innodb_lru_scan_depth` 수만큼 수행한다.

## 버퍼 풀 상태 백업 및 복구

MySQL 5.6 버전부터 버퍼 풀 덤프 및 적재 기능이 도입되었다. 이전에는 서버를 셧다운했다가 다시 시작하고 서비스를 시작하면 쿼리 처리 성능이 평소보다 매우 떨어지는 경우가 대부분이었다. 
셧다운시 버퍼 풀에 미리 준비돼 있던 쿼리들이 사용할 데이터가 사라져서, 서비스를 오픈하기 전에 강제 워밍업을 위해 주요 테이블과 인덱스에 대해 풀 스캔을 한 번씩 실행하고 서비스를 오픈해야했다.
  
MySQL 서버를 셧다운 하기 전에 `innodb_buffer_pool_dump_now` 시스템 변수를 이용해서 현재 InnoDB 버퍼 풀의 상태를 백업하고 `innodb_buffer_pool_load_now` 시스템 변수로 백업된 버퍼 풀의 상태를 다시 복구할 수 있다.
  
버퍼 풀의 백업은 매우 빨리 완료되는 반면, 백업된 버퍼 풀의 내용을 다시 버퍼 풀로 복구하는 과정은 InnoDB 버퍼 풀의 크기에 따라 상당한 시간이 걸릴 수 있다. 그래서 InnoDB 스토리지 엔진은 복구하는 과정의 진행 상황을 확인할 수 있게 상태 값을 제공하고,
버퍼 풀 적재 작업이 너무 오래걸리면 멈출 수 있도록 `innodb_buffer_pool_load_abort` 시스템 변수를 제공한다.

## Reference 

**위 글은 책 RealMySQL 8.0을 구입하여 읽고 정리한 내용입니다.**
- [도서 홈페이지 https://wikibook.co.kr/realmysql801/](https://wikibook.co.kr/realmysql801/)
