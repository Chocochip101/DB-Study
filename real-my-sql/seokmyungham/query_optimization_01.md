# 쿼리 작성 및 최적화

SQL은 어떤 데이터를 요청하기 위한 언어일 뿐, 어떻게 데이터를 읽을지 표현하는 언어가 아니다.
그래서 쿼리가 빠르게 수행되게 하려면 데이터베이스 서버에서 쿼리가 어떻게 요청을 처리하는지 예측할 수 있어야 한다.

## MySQL 연산자와 내장 함수

### 리터럴 표기법 문자열

#### 숫자

```sql
SELECT * FROM tab_test WHERE number_column='10001';
SELECT * FROM tab_test WHERE string_column=10001;
```

위 쿼리와 같이 두 비교 대상이 문자열과 숫자 타입으로 다를 때는 자동으로 타입 변환이 발생한다.
MySQL은 숫자 타입과 문자열 타입 간의 비교에서 숫자 타입을 우선시하므로 문자열 값을 숫자 값으로 변환한 후 비교를 수행한다.
  
따라서 첫 번째 쿼리는 주어진 상숫값을 숫자로 변환하는데 성능과 관련된 문제가 발생하지 않는다.  
  
반면 두 번째 쿼리는 주어진 상숫값이 숫자 값인데, 비교되는 칼럼은 문자열 칼럼이다. 이때 MySQL은 문자열 칼럼을 숫자로 변환해서 비교한다.
즉, `string_column` 칼럼의 모든 문자열 값을 숫자로 변환해서 비교를 수행해야 하므로 `string_column`에 인덱스가 있더라도 이를 활용하지 못한다.
`string_column`에 알파벳과 같은 문자가 포함된 경우에는 숫자 값으로 변환할 수 없으므로 쿼리 자체가 실패할 수도 있다.
  
원천적으로 이러한 문제점을 제거하려면 숫자 값은 숫자 타입의 칼럼에만 저장해야 한다.  
주로 코드나 타입과 같은 값을 저장하는 칼럼에서 이 같은 현상이 자주 발생하므로 주의해야 한다.

#### 날짜

MySQL 에서는 정해진 형태의 날짜 포맷으로 표기하면 MySQL 서버가 자동으로 `DATE`나 `DATETIME` 값으로 변환하기 때문에 복잡하게
`STR_TO_DATE()` 같은 함수를 사용하지 않아도 된다.

```sql
SELECT * FROM dept_emp WHERE from_date='2011-04-29';
# SELECT * FROM dept_emp WHERE from_date=STR_TO_DATE('2011-04-29', '%Y-%m-%d');
```

위 두 쿼리의 차이점은 없다.  
첫 번째 쿼리와 같이 비교한다고 해서 from_date 칼럼의 값을 문자열로 변환하지 않기 때문에 from_date 칼럼으로 생성된 인덱스를 이용하는 데 문제가 없다.


### MySQL 연산자

#### 동등 비교

MySQL에서는 동등 비교를 위해 `<=>` 연산자도 제공한다.  
`<=>` 연산자는 `=` 연산자와 같으며, 부가적으로 `NULL` 값에 대한 비교까지 수행한다. 이 연산자를 `NULL-Safe` 비교 연산자라고 한다.

```sql
mysql> SELECT 1 = 1, NULL = NULL, 1 = NULL;
+-------+-------------+----------+
| 1 = 1 | NULL = NULL | 1 = NULL |
+-------+-------------+----------+
|     1 |        NULL |     NULL |
+-------+-------------+----------+

mysql> SELECT 1 <=> 1, NULL <=> NULL, 1 <=> NULL;
+---------+---------------+------------+
| 1 <=> 1 | NULL <=> NULL | 1 <=> NULL |
+---------+---------------+------------+
|       1 |             1 |          0 |
+---------+---------------+------------+
```

#### REGEXP 연산자 (RLIKE)

문자열 값이 어떤 패턴을 만족하는지 확인하는 연산자이다.  
`REGEXP` 연산자를 사용하려면 다음 예제와 같이 `REGEXP` 연산자의 좌측에 비교 대상 문자열 값 또는 문자열 칼럼을, 우측에 검증하고자 하는 정규 표현식을 사용하면 된다.

```sql
mysql> SELECT 'abc' REGEXP '^[x-z]';
+-----------------------+
| 'abc' REGEXP '^[x-z]' |
+-----------------------+
|                     0 |
+-----------------------+
```

`REGEXP` 연산자를 문자열 칼럼에 비교할 때 `REGEXP` 조건의 비교는 인덱스 레인지 스캔을 사용할 수 없다. 
따라서 WHERE 조건절에 `REGEXP` 연산자를 사용한 조건을 단독으로 사용하는 것은 성능상 좋지 않다.
가능하다면 데이터 조회 범위를 줄일 수 있는 조건과 함께 `REGEXP` 연산자를 사용하길 권장한다.

#### LIKE 연산자

REGEXP 연산자 보다는 훨씬 단순한 문자열 패턴 비교 연산자이지만 DBMS에서는 LIKE 연산자를 더 많이 사용한다.
LIKE 연산자는 인덱스를 사용할 수 있고, 정규 표현식을 검사하는 것이 아니라 어떤 상수 문자열이 있는지 없는지 정도를 판단하는 연산자다.

```sql
mysql> SELECT 'a%' LIKE 'a%';
+----------------+
| 'a%' LIKE 'a%' |
+----------------+
|              1 |
+----------------+

mysql> SELECT 'a%' LIKE 'a/%' ESCAPE '/';
+----------------------------+
| 'a%' LIKE 'a/%' ESCAPE '/' |
+----------------------------+
|                          1 |
+----------------------------+
```

와일드카드 문자인 '%'나 '_' 문자 자체를 비교한다면 ESCAPE 절을 LIKE 조건 뒤에 추가해 이스케이프 문자를 설정할 수 있다.
  
LIKE 연산자는 와일드카드 문자인 (%, _)가 검색어의 뒤쪽에 있다면 인덱스 레인지 스캔으로 사용할 수 있지만 와일드카드가
검색어의 앞족에 있다면 인덱스 레인지 스캔을 사용할 수 없으므로 주의해서 사용해야 한다.

```sql
mysql> EXPLAIN
    -> SELECT COUNT(*)
    -> FROM employees
    -> WHERE first_name LIKE 'Christ%';
+----+-----------+-------+--------------+------+--------------------------+
| id | table     | type  | key          | rows | Extra                    |
+----+-----------+-------+--------------+------+--------------------------+
|  1 | employees | range | ix_firstname | 1157 | Using where; Using index |
+----+-----------+-------+--------------+------+--------------------------+
```
`Christ`로 시작하는 이름을 검색하려면 다음과 같이 인덱스 레인지 스캔을 이용해 검색할 수 있다.

```sql
mysql> EXPLAIN
    -> SELECT COUNT(*)
    -> FROM employees
    -> WHERE first_name LIKE '%rist';
+----+-----------+-------+--------------+--------+--------------------------+
| id | table     | type  | key          | rows   | Extra                    |
+----+-----------+-------+--------------+--------+--------------------------+
|  1 | employees | index | ix_firstname | 299477 | Using where; Using index |
+----+-----------+-------+--------------+--------+--------------------------+
```
하지만 `rist`로 끝나는 이름을 검색할 때는 와일드카드가 검색어 앞쪽에 있게 되는데, 이 경우 인덱스 레인지 스캔을 사용하지 못하고
인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔 방식으로 쿼리가 처리된다.

#### BETWEEN 연산자

BETWEEN 연산자는 `크거나 같다`와 `작거나 같다`라는 두 개의 연산자를 하나로 합친 연산자다.

```sql
SELECT * FROM dept_emp
WHERE dept_no='d003' AND emp_no=10001;
```

```
SELECT * FROM dept_emp
WHERE dept_np BETWEEN `d003` AND `d005` AND emp_no=10001;
```

dept_emp 테이블에는 현재 `(dept_no, emp_no)` 칼럼으로 구성된 프라이머리 키가 존재한다.  
그래서 첫 번째 쿼리는 `dept_no`와 `emp_no`조건 모두 인덱스를 이용해 범위를 줄여주는 방법으로 사용할 수 있다.
하지만 두 번째 쿼리에서 사용한 `BETWEEN`은 < 또는 > 연산자와 같이 범위를 읽어야하는 연산자라서 `dept_no` 가
`d003`보다 크거나 같고 `d005`보다 작거나 같은 모든 인덱스의 범위를 검색해야만 한다. 결국 두 번째 쿼리에서 `BETWEEN` 때문에 `emp_no=10001` 조건이 비교 범위를 줄이는 역할을 하지 못한다.
  
`BETWWEN`은 크다 작다 비교를 하나로 묶어 둔 것에 가깝고, `IN` 연산자의 처리 방법은 `동등 비교(=)` 연산자와 비슷하다. `BETWEEN`을 사용하는 위 쿼리는 dept_emp 테이블의 (dept_no, emp_no) 인덱스의 상당히 많은 레코드를 읽는다. 하지만 실제로 가져오는 데이터는 1건밖에 안된다. 결국 이 쿼리는 10만건을 읽어서 1건 반환하는 것이다.
  
하지만 이 쿼리를 다음과 같은 형태로 바꾸면 `emp_no=10001` 조건도 작업 범위를 줄이는 용도로 인덱스를 이용할 수 있게 된다.

```sql
SELECT * FROM dept_emp
WHERE dept_no IN ('d003', 'd004', 'd005')
AND emp_no = 10001;
```

`BETWEEN`이 선형으로 인덱스를 검색해야 하는 것과는 달리 `IN`은 동등 비교를 여러번 수행하는 것과 같은 효과가 있기 때문에 dept_emp 테이블의 인덱스를 최적으로 사용할 수 있는 것이다.
  
이 예제처럼 여러 칼럼으로 인덱스가 만들어져 있는데, 인덱스 앞쪽에 있는 칼럼의 선택도가 떨어질 때는 IN으로 변경하는 방법으로 쿼리의 성능을 개선할 수도 있다. `BETWEEN`을 사용한 쿼리와 `IN`을 사용한 쿼리 둘 다 인덱스 레인지 스캔을 하지만 실행 계획의 rows 칼럼에 표시된 레코드 건수는 매우 큰 차이가 있음을 알 수 있다. (165571 vs 3)
  
BETWEEN 비교를 사용한 쿼리에서는 부서 번호가 'd003'인 레코드부터 'd005'인 레코드의 전체 범위를 다 비교해야 하지만 IN을 사용한 쿼리에서는 사원 번호가 (('d003', 10001), ('d004', 10001), ('d005', 1000)) 조합인 레코드만 비교해 보면 되기 때문이다.
  
8.0 버전부터는 다음과 같이 `IN (subquery)` 형태로 작성하면 옵티마이저가 세미 조인 최적화를 이용해 더 빠른 쿼리로 변환해서 실행한다.

```sql
mysql> SELECT *
    -> FROM dept_emp USE INDEX(PRIMARY)
    -> WHERE dept_no IN (
            -> SELECT dept_no
            -> FROM departments
            -> WHERE dept_no BETWEEN 'd003' AND 'd005')
    -> AND emp_no=10001;
```

그런데 departments 테이블에서 dept_no 칼럼은 PK이기 때문에 이 결과는 항상 유니크한 결과를 반환한다.
그래서 사실 이 예제 쿼리는 다음과 같이 단순한 조인으로 변경해서 실행할 수도 있다.

```
SELECT *
FROM departments d INNER JOIN dept_emp de USE INDEX(PRIMARY)
ON de.dept_no=d.dept_no AND de.emp_no=10001
WHERE d.dept_no BETWEEN 'd003' AND 'd005';
```
8.0 버전의 세미 조인 최적화 기능은 상당히 많이 안정화됐다.  
그래서 실제로는 위의 IN (subquery) 조인을 실행해도 옵티마이저는 JOIN 쿼리로 재작성해서 쿼리를 최적화한다.

#### IN 연산자

IN은 여러 개의 값에 대해 동등 비교 연산을 수행하는 연산자다. 여러 개의 값이 비교되지만 범위로 검색하는 것이 아니라 여러 번의 동등 비교로 실행하기 때문에 일반적으로 빠르게 처리된다.
  
8.0 버전 이전 까지는 IN절에 `튜플(레코드)`을 사용하면 항상 풀 테이블 스캔을 했었는데 8.0 버전부터는 IN 절에 튜플을 그대로 나열해도 인덱스를 최적으로 사용할 수 있게 개선됐다. 
  
IN (subquery) 형태의 조건이 사용된 쿼리는 최적화가 매우 까다로운데 8.0 버전부터는 IN (subquery) 같은 세미 조인의 최적화가 많이 안정됐다.
  
NOT IN의 실행 계획은 인덱스 풀 스캔으로 표시되는데, 동등이 아닌 부정형 비교여서 인덱스를 이용해 처리 범위를 줄이는 조건으로는 사용할 수 없기 때문이다. NOT IN 연산자가 프라이머리 키와 비교될 때 가끔 쿼리의 실행계획에 인덱스 레인지 스캔이 표시되는 경우가 있다. 하지만 이는 InnoDB 테이블에서 프라이머리 키가 클러스터링 키이기 때문일 뿐 실제 IN과 같이 효율적으로 실행된다는 것을 의미하지는 않는다.

### MySQL 내장 함수

#### 문자열 처리(RPAD, LPAD / RTRIM, LTRIM, TRIM)

RPAD()와 LAPD() 함수는 문자열의 좌측 또는 우측에 문자를 붙여서 지정된 길이의 문자열로 만드는 함수다.
  
RTRIM() 함수와 LTRIM() 함수는 문자열의 우측 또는 좌측에 연속된 공백 문자를 제거하는 함수다.  
TRIM() 함수는 LTRIM()과 RTRIM()을 동시에 수행하는 함수다.

#### GROUP BY 문자열 결합(GROUP_CONTCAT)

`COUNT()`, `MAX()`, `MIN()`, `AVG()` 등과 같은 그룹 함수중 하나다. 주로 GROUP BY와 함께 사용하며 GROUP BY 가 없는 SQL에서 사용하면 단 하나의 결과값만 만들어낸다. `GROUP_CONCAT()` 함수는 값들을 먼저 정렬한 후 연결하거나 각 값의 구분자 설정도 가능하며 여러 값 중에서 중복을 제거하고 연결하는 것도 가능하므로 상당히 유용하게 사용된다.

```sql
mysql> SELECT GROUP_CONCAT(dept_no) FROM departments;
+----------------------------------------------+
| GROUP_CONCAT(dept_no)                        |
+----------------------------------------------+
| d009,d005,d002,d003,d001,d004,d006,d008,d007 |
+----------------------------------------------+

mysql> SELECT GROUP_CONCAT(dept_no SEPARATOR '|') FROM departments;
+----------------------------------------------+
| GROUP_CONCAT(dept_no SEPARATOR '|')          |
+----------------------------------------------+
| d009|d005|d002|d003|d001|d004|d006|d008|d007 |
+----------------------------------------------+
```
 
`GROUP_CONCAT()` 함수는 지정한 칼럼의 값들을 연결하기 위해 제한적인 메모리 버퍼 공간을 사용한다. 어떤 쿼라에서 `GROUP_CONCAT()` 함수의 결과가 시스템 변수에 지정된 크기를 초과하면 경고 메시지가 발생한다. `GROUP_CONCAT()` 함수가 JDBC로 실행될 때는 경고가 아니라 에러로 취급되어 쿼리가 실패하기 때문에 `GROUP_CONCAT()` 결과가 지정된 버퍼 크기를 초과하지 않게 주의해야 한다.
  
`GROUP_CONCAT()` 함수가 사용하는 메모리 버퍼 크기는 group_concat_max_len 시스템 변수로 조정할 수 있다.

## Reference 

**위 글은 책 RealMySQL 8.0 2권을 구입하여 읽고 정리한 내용입니다.**
- [도서 홈페이지 https://wikibook.co.kr/realmysql802/](https://wikibook.co.kr/realmysql802/)

