# 테이블 파티셔닝

`테이블 파티셔닝`이란 하나의 테이블을 물리적으로 여러 테이블로 분할해서 데이터를 저장하는 기법을 말한다.  
  
테이블이 파티셔닝되면 내부적으로 여러 테이블로 분할되고, 실제 데이터와 인덱스도 나눠서 저장된다.  
분할된 테이블을 각각 `파티션`이라고 부르며, 사용자 입장에서는 기존처럼 하나의 테이블로 인식해서 사용하게 된다.
  
테이블을 파티셔닝하는 기준은 특정 컬럼이나, 계산식을 기준으로 `날짜/숫자 범위`나 `리스트`, `해시값` 형태가 있다. 

## 테이블 파티셔닝을 사용하는 목적

### 단일 INSERT와 단일 또는 범위 SELECT의 빠른 처리

UPDATE와 DELECT 쿼리 처리를 위해 대상 레코드를 검색하려면 인덱스가 필수적이다. 하지만 인덱스가 커지면 커질수록 SELECT, INSERT, DELETE, UPDATE 작업도 함께 느려지는 단점이 있다. 특히 한 테이블의 인덱스 크기가 물리적으로 MySQL이 사용 가능한 메모리 공간보다 크다면 그 영향은 심각해진다. 파티션은 데이터와 인덱스를 조각화해서 물리적 메모리를 효율적으로 사용할 수 있게 만들어준다.

### 삭제 가능한 이력 데이터를 효율적으로 관리

로그성 데이터들이 저장되는 테이블에 파티셔닝을 적용하는 경우, 보관 기간에 따라 일정 기간 지난 데이터들을 제거할 때 데이터를 직접 삭제하는 것이 아닌 `파티션 드랍`으로 간단히 처리하는 것이 가능하다.  
  
파티션 드랍의 경우 테이블을 드랍하는 것처럼 디스크 공간을 완전히 반납하게 되어 서버 자원도 효율적으로 관리할 수 있다.

### 자원 사용 효율 증가 및 쿼리 성능 향상

데이터 접근 패턴이 특정 범위에 집중되는 경우 테이블 파티셔닝을 적용하면 자원을 효율적으로 사용할 수 있고 쿼리의 성능을 향상시킬 수 있다.
  
게시판처럼 최근에 저장된 데이터들을 위주로 조회하는 경우(게시판 1페이지) 날짜 범위로 파티셔닝하여 각 파티션이 특정 기간의 데이터만을 보유하도록 설정할 수 있다.
  
이 때 쿼리가 특정 날짜 범위의 데이터를 요청할 때, MySQL은 조건 범위에 해당하지 않는 파티션은 쿼리 처리에서 제외시킨다. 
이러한 작업을 `파티션 프루닝(Partition Pruning)`이라 부르는데, 특정 파티션의 인덱스 데이터만 탐색하게 되므로 물리 메모리를 효율적으로 사용할 수 있어
쿼리 성능을 향상시킬 수 있다.
  
이처럼 적절히 테이블을 파티셔닝해서 사용할 수 있다면, DB 서버의 자원 사용량을 최적화하는 것과 더불어 쿼리 응답 시간을 단축시켜 애플리케이션 서비스의 품질을 향상시킬 수 있다.

## MySQL 파티션의 내부 처리

```sql
CREATE TABLE tb_article (
  article_id INT NOT NULL,
  reg_date DATETIME NOT NULL,
  ...
  PRIMARY KEY(article_id, reg_date)
) PARTITION BY RANGE ( YEAR(reg_date) ) (
    PARTITION p2009 VALUES LESS THAN (2010),
    PARTITION p2010 VALUES LESS THAN (2011),
    PARTITION p2011 VALUES LESS THAN (2012),
    PARTITION p9999 VALUES LESS THAN MAXVALUE
);
```

### INSERT

INSERT 쿼리가 실행되면 MySQL 서버는 INSERT되는 칼럼 값 중에서 `파티션 키인 reg_date`를 이용해 파티션 표현식을 평가하고 레코드가 저장될 적절한 파티션을 결정한다. 새로 INSERT되는 레코드를 위한 파티션이 결정되면 나머지 과정은 파티션되지 않은 일반 테이블과 동일하게 처리된다.

### UPDATE

UPDATE 쿼리를 실행하려면 변경 대상이 어느 파티션에 저장돼 있는지 찾아야 한다. 이때 UPDATE 쿼리의 WHERE 조건에 파티션 키 칼럼이 조건으로 존재하면 레코드가 저장된 파티션에서 빠르게 대상 레코드를 검색할 수 있다. 하지만 WHERE 조건에 파티션 키 칼럼이 명시되어 있지 않다면 MySQL 서버는 변경 대상 레코드를 찾기 위해 `모든 파티션을 검색`해야 한다.

- 파티션 키 이외의 칼럼만 변경될 때는 파티션이 적용되지 않은 일반 테이블과 마찬가지로 칼럼 값만 변경한다.
- 파티션 키 칼럼이 변경될 때는 기존의 레코드가 저장된 파티션에서 해당 레코드를 삭제한다. 그리고 변경되는 파티션 키 칼럼의 표현식을 평가하고, 그 결과를 이용해 레코드를 이동시킬 새로운 파티션을 결정해서 레코드를 새로 저장한다.

### 파티션 테이블 검색

- WHERE 절의 조건으로 검색해야 할 파티션을 선택할 수 있는가?
- WHERE 절의 조건이 `인덱스를 효율적으로 사용`할 수 있는가? (인덱스 레인지 스캔)

파티션 테이블을 검색할 때 성능에 크게 영향을 미치는 조건들이다. WHERE 절의 조건으로 검색해야 할 파티션을 선택할 수 있는지에 따라 인덱스를 효율적으로 사용할 수 있는지에도 영향을 끼친다.

- 파티션 선택 가능 + 인덱스 효율적 사용 가능
  - 쿼리가 가장 효율적으로 처리될 수 있는 상황. 이때는 파티션의 개수와 관계없이 검색을 위해 꼭 필요한 파티션의 인덱스만 레인지 스캔한다.
- 파티션 선택 불가 + 인덱스 효율적 사용 가능
  - 모든 파티션에 대해 인덱스 레인지 스캔을 하게된다.
- 파티션 선택 가능 + 인덱스 효율적 사용 불가
  - 필요한 파티션만 읽을 수 있지만 풀 테이블 스캔을 하게 된다.
- 파티션 선택 불가 + 인덱스 효율적 사용 불가
  - 모든 파티션을 검색해야하고, 풀 테이블 스캔을 해야 한다.  

가능하면 세 번째와 네 번째 방식은 피하는 것이 좋다. 두 번쨰 또한 하나의 테이블에 파티션이 많을 경우 MySQL 서버의 부하가 높아지고 처리 시간도 많이 느려지므로 주의하는 것이 좋다.

### 파티션 테이블의 인덱스 스캔 및 정렬

![image](https://github.com/user-attachments/assets/ee396f5e-8f02-4f9f-833c-5c756877a33a)

MySQL 파티션 테이블에서 인덱스는 모두 로컬 인덱스에 해당한다. 모든 인덱스는 파티션 단위로 생성되며, 테이블 전체 단위의 글로벌 인덱스는 지원하지 않는다.

```SQL
SELECT *
FROM tb_article
WHERE reg_userid BETWEEN 'brew' AND 'toto'
AND reg_date BETWEEN '2009-01-01' AND '2010-12-31'
ORDER BY reg_userid;
```
  
예상을 해보면 각 파티션으로부터 WHERE 조건에 일치하는 레코드를 가져온 후, 각 파티션의 결과를 병합하고 ORDER BY 절을 수행하기 위해 reg_userid 칼럼 값으로 다시 한 번 정렬해야 할 것 같지만 실행 계획을 살펴보면 별도의 정렬을 수행했다는 메시지는 표시되지 않는다. =`Using filesort`
  
실제 MySQL 서버는 여러 파티션에 대해 인덱스 스캔을 수행할 때 각 파티션으로부터 레코드를 정렬된 순서대로 읽으면서 우선순위 큐에 임시로 저장한다. 그리고 우선순위 큐에서 다시 필요한 순서대로 데이터를 가져간다.
  
결론적으로 파티션 테이블에서 인덱스 스캔을 통해 레코드를 읽을 떄 MySQL 서버가 별도의 정렬 작업을 수행하지는 않는다. 하지만 일반 테이블의 인덱스 스캔처럼 결과를 바로 반환하지는 못하고 내부적으로 큐 처리가 한 번 필요하게 된다. 
  
또한 옵티마이저는 일부 파티션만 읽어도 된다고 판단되면 불필요한 파티션에는 전혀 접근하지 않는다. 이렇게 최적화 단계에서 필요한 파티션만 골라내고 불필요한 것들은 배제하는 것을 `파티션 프루닝`이라고 한다. 실행계획의 partitions 칼럼을 통해 통해 옵티마이저가 어떤 파티션만 접근하는 지 알 수 있다. 

## 주의 사항

### 파티션 제약 사항

MySQL 파티션은 5.1 버전부터 도입되어 많은 발전이 있었지만 파티션의 태생적인 한계 떄문에 아직도 많은 제약을 지니고 있다.


```sql
CREATE TABLE tb_article (
  article_id INT NOT NULL,
  reg_date DATETIME NOT NULL,
  ...
  PRIMARY KEY(article_id, reg_date)
) PARTITION BY RANGE ( YEAR(reg_date) ) (
    PARTITION p2009 VALUES LESS THAN (2010),
    PARTITION p2010 VALUES LESS THAN (2011),
    PARTITION p2011 VALUES LESS THAN (2012),
    PARTITION p9999 VALUES LESS THAN MAXVALUE
);
```

대표적으로

- PK를 포함해서 테이블의 모든 유니크 인덱스는 파티션 키 칼럼을 포함해야 한다.
- 파티션된 테이블의 인덱스는 모두 로컬 인덱스이며, 동일 테이블에 소속된 모든 파티션은 같은 구조의 인덱스만 가질 수 있다. 파티션 개별로 인덱스를 변경하거나 추가할 수 없다.
- 최대 8192개의 파티션을 가질 수 있다.
- 파티션 테이블에서는 외래키를 사용할 수 없다.
- 파티션 테이블은 전문 검색 인덱스 생성이나 전문 검색 쿼리를 사용할 수 없다.

일반적으로 가장 크게 미치는 제약 사항은 모든 유니크 인덱스에 파티션 키 칼럼이 포함돼야 한다는 것이다. 위 sql에서도 article_id가 AUTO_INCREMENT를 사용하기 떄문에 article_id로만 PK를 구성해도 충분할 것 같지만 (article_id, reg_date) 칼럼 조합으로 pk를 선정했다. 실제 article_id만으로 유니크한 값을 가지기 떄문에 reg_date 칼럼을 pk에 추가하는 것은 아무런 의미가 없지만 reg_date 칼럼으로 파티션을 적용하기 위해서는 이 방법밖에 없는 것이다.
  
또한 파티션 표현식에는 기본 산술 연산자와 내장 함수를 사용할 수 있지만 모든 내장 함수가 파티션 프루닝을 지원하는 것은 아니므로 주의해야 한다.

### 파티션 사용 시 주의 사항

파티션 테이블의 경우 `유니크 키(PK 포함)`에 대해 상당히 골치아픈 제약 사항이 있다. 파티션의 목적은 작업의 범위를 좁히는 것인데, 유니크 인덱스는 중복 레코드에 대한 체크 작업 때문에 범위가 좁혀지지 않는다는 점이다. 

또한 MySQL의 파티션은 일반 테이블과 같이 별도의 파일로 관리되기 떄문에, MySQL 서버에서 동시에 오픈된 파일의 개수가 상당히 많아질 수 있다. 이를 제한하기 위해 open_files_limit 시스템 변수에 동시에 오픈할 수 있는 적절한 파일의 개수를 설정할 수 있다. 파티션되지 않은 일반 테이블은 테이블 1개당 오픈된 파일의 개수가 2~3개 수준이지만 파티션 테이블에서는 (파티션의 개수 * 2~3) 개가 된다. 쿼리가 적절히 파티션프루닝에 최적화 되어 있다고 하더라도 일단 동시에 모든 파티션의 데이터 파일을 오픈해야 하므로 시스템 변수를 적절히 높은 값으로 다시 설정해 줄 필요가 있다.

## MySQL 파티션 종류

### 레인지 파티션

파티션 키의 연속된 범위의 파티션을 정의하는 방법으로, 가장 일반적으로 사용되는 파티션 방법 중 하나

다음과 같은 성격을 지닌 테이블에서는 레인지 파티션을 사용하는 것이 좋다.

- 날짜를 기반으로 데이터가 누적되고 연도나 월, 또는 일 단위로 분석하고 삭제해야 할 때
- 범위 기반으로 데이터를 여러 파티션에 균등하게 나눌 수 있을 때
- 파티션 키 위주로 검색이 자주 사용될 때

데이터베이스에서 파티션의 장점은 `큰 테이블을 작은 크기의 파티션으로 분리하는 것`과 `읽기 쓰기 모두 필요한 파티션만 접근`하는 것이다. 그런데 문제는 파티션을 적용하면서 두 번째 장점은 취하지 못하고 첫 번째 장점에 장점에만 집중하다 보니 문제가 되는 데, 이력을 저장하는 테이블에서 레인지 파티션은 이 두 가지 장점을 모두 어렵지 않게 취할 수 있다.
  
> MySQL 저자가 경험했던 많은 응용 프로그램에서 사용했던 파티션은 대부분 이력을 저장하는 로그 테이블에 레인지 파티션을 적용한 경우였다.

입사 연도별로 파티션 테이블 예시

```SQL
CREATE TABLE employees (
  id INT NOT NULL,
  first_name VARCHAR(30)
  last_name VARCHAR(30)
  hired DATE NOT NULL DEFAULT '1970-01-01',
  ...
) PARTITION BY RANGE ( YEAR(hired) ) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1996),
    PARTITION p2 VALUES LESS THAN (2001),
    PARTITION p3 VALUES LESS THAN MAXVALUE
);
```

#### 레인지 파티션의 분리와 병합

```sql
ALTER TABLE employees
ADD PARTITION (PARTITION p4 VALUES LESS THAN (2011));
```

현재 employees 테이블에는 LESS THAN MAXVALUE 파티션이 있으므로 새로운 파티션을 추가하기 위해 위 쿼리를 실행하면 에러가 발생한다. 그리고 이미 MAXVALUE 파티션이 2001년 이후의 모든 레코드를 가지고 있는 상태에서 2011년 파티션이 추가되면 2011년 레코드는 2개 파티션에 나뉘어 저장되는 결과를 만들어낸다. 
  
그래서 이 경우에는 반드시 다음과 같이 `ALTER TABLE ... REORGANIZE PARTITION` 명령을 사용해야 한다.

```SQL
ALTER TABLE employees ALGORITHM=INPLACE, LOCK=SHARED,
  REORGANIZE PARTITION p3 INTO (
    PARTITION p3 VALUES LESS THAN (2011),
    PARTITION p4 VALUES LESS THAN MAXVALUE
);
```

위 명령어를 사용해서 하나의 파티션을 두 개의 파티션으로 분리할 수 있다. 기존 파티션의 레코드 건수에 따라 시간이 오래 걸릴 수도 있으며 기존 파티션의 레코드가 많다면 온라인 DDL로 실행할 수 있게 ALGORITHM과 LOCK절을 사용하자. 하지만 파티션 재구성 명령은 INPLACE 알고리즘을 사용할 수 있지만 최소한 읽기 잠금(SHARED LOCK)이 필요하기 때문에 파티션이 재구성되는 동안 쓰기가 불가능하므로 새벽이나 서비스 점검 시간대에 하는 것이 좋다.

반면에 레인지 파티션에는 일반적으로 `LESS THAN MAXVALUE` 절을 사용하는 파티션은 추가하지 않고, 미래에 사용될 파티션을 미리 2~3개 더 만들어 두는 형태로 테이블을 생성하기도 한다. 그리고 배치 스크립트를 이용해 주기적으로 파티션 테이블의 여유 기간을 판단해서 파티션을 자동으로 추가하는 방법을 사용한다.

```SQL
ALTER TABLE employees DROP PARTITION p0;
```

파티션 드랍

### 리스트 파티션

리스트 파티션은 레인지 파티션과 흡사하게 동작하고 둘의 가장 큰 차이점은 레인지 파티션은 키 값의 범위로 파티션을 구성할 수 있지만 리스트 파티션은 파티션 키 값 하나하나를 리스트로 나열해야 한다는 점이다. 또한 MAXVALUE 파티션을 정의할 수 ㅇ벗다.

- 파티션 키 값이 코드 값이나 카테고리와 같이 고정적일 때
- 키 값이 연속되지 않고 정렬 순서와 관계없이 파티션을 검색해야 할 때
- 파티션 키 값을 기준으로 레코드 건수가 균일하고 검색 조건에 파티션 키가 자주 사용될 때

```SQL
CREATE TABLE product(
  id INT NOT NULL,
  name VARCHAR(30),
  categor_id VARCHAR(20) NOT NULL,
  ...
) PARTITION BY LIST ( category_id ) (
    PARTITION p_appliance VALUES IN ('TV'),
    PARTITION p_computer VALUES IN ('Notebook', 'Desktop'),
    PARTITION p_sports VALUES IN ('Tennis', 'Soccer'),
    PARTITION p_etc VALUES IN ('Magazine', 'Socks', NULL)
);
```

### 해시 파티션

해시 파티션은 MySQL에서 정의한 해시 함수에 의해 레코드가 저장될 파티션을 결정하는 방법이다. MySQL 에서 정의한 해시 함수는 파티션 표현식의 결괏값을 파티션의 개수로 나눈 나머지로 저장될 파티션을 결정하는 방식이다. 

- 레인지 파티션이나 리스트 파티션으로 데이터를 균등하게 나누는 것이 어려울 때
- 테이블의 모든 레코드가 비슷한 사용 빈도를 보이지만 테이블이 너무 커서 파티션을 적용해야 할 때

해시 파티션이나 키 파티션의 대표적인 용도로는 회원 테이블을 들 수 있다. 회원 정보는 가입 일자에 따라 더 많이 사용되고 더 적게 사용되지 않기 때문에 전체적으로 비슷한 사용 빈도를 보인다.

```sql
CREATE TABLE employees (
  id INT NOT NULL,
  first_name VARCHAR(30),
  last_name VARCHAR(30),
  hired DATE NOT NULL DEFAULT '1970-01-01',
  ...
) PARTITION BY HASH(id) PARTITIONS 4;
```

해시 파티션에서 분리와 병합은 대상 테이블의 모든 파티션에 저장된 레코드를 재분배하는 작업이 필요하다. 전체 파티션이 영향을 받는다.

### 해시 파티션 추가

해시 파티션은 특정 파티션의 키 값을 테이블의 파티션 개수로 MOD 연산한 결괏값에 의해 각 레코드가 저장될 파티션을 결정한다. 즉 해시 파티션은 테이블에 존재하는 파티션의 개수에 의해 파티션 알고리즘이 변하는 것이다. 따라서 새로운 파티션이 추가된다면 기존의 각 파티션에 저장된 모든 레코드가 재배치돼야 한다. 따라서 INPLCAE 알고리즘으로 실행된다고 하더라도 레코드 리빌드 작업이 필요하며 테이블에 대한 읽기 잠금이 필요하다. 그래서 해시 파티션에서 파티션을 추가하거나 생성하는 작업은 많은 부하를 발생시킨다.

### 해시 파티션 삭제

해시나 키 파티션은 파티션 단위로 레코드를 삭제하는 방법이 없다. 해시나 키 파티션을 사용하는 테이블에서 특정 파티션을 삭제하려고 하면 에러 메시지가 발생하면서 종료할 것이다.
  
MySQL 서버가 지정한 파티션 키 값을 가공해서 데이터를 각 파티션으로 분산한 것이므로 각 파티션에 저장된 레코드가 어떤 부류의 데이터인지 사용자가 예측할 수 없다. 결국 해시 파티션이나 키 파티션을 사용한 테이블에서 파티션 단위로 데이터를 삭제하는 작업은 의미도 없으며 해서도 안 될 작업이다.

### 해시 파티션 분할

해시 파티션이나 키 파티션에서 특정 파티션을 두 개 이상의 파티션으로 분할하는 기능은 없으며, 테이블 전체적으로 파티션의 개수를 늘리는 것만 가능하다.

### 해시 파티션 병합

해시나 키 파티션은 2개 이상의 파티션을 하나의 파티션으로 통합하는 기능을 제공하지 않는다. 단지 파티션의 개수를 줄이는 것만 가능하다. 이 때 삭제되는 파티션에 저장돼 있던 레코드가 남은 3개의 파티션으로 복사되는 것이 아니라 테이블의 모든 레코드가 재배치되는 작업이 수행돼야 한다. 재배치 = 리빌드 = 다른 트랜잭션의 변경이 허용되지 않는다.

> 해시 파티션은 레인지 파티션이나 리스트 파티션과는 상당히 다른 방식으로 관리하기 때문에 해시 파티션이 용도에 적합한 해결책인지 확인이 필요하다.
  
### 키 파티션

키 파티션은 해시 파티션과 사용법과 특성이 거의 같다. 해시 파티션은 MySQL 서버가 최종적으로 MOD 연산을 하여 파티션을 결정하긴 하지만, 해시 값을 계산하는 방법을 파티션 키나 표현식에 사용자가 명시한다. 하지만 키 파티션에서는 해시 값의 계산도 MySQL 서버가 수행한다. MySQL 서버는 선정된 파티션의 키 값을 MD5() 함수를 이용해 값을 계산하고, 그 값을 MOD 연산해서 데이터를 각 파티션에 분배한다. 이것이 유일한 차이점이다.

### 리니어 해시 파티션/리니어 키 파티션

해시 파티션이나 키 파티션은 파티션을 추가하거나 파티션을 통합해서 개수를 줄일 때 대상 파티션 뿐만 아니라 테이블 전체 파티션에 재분배 작업이 일어난다. 이러한 단점을 최소화하기 위해 리니어 해시 파티션/리니어 키 파티션 알고리즘이 고안됐다. 리니어 파티션은 각 레코드 분배를 위해 2의 승수(Power-of-two) 알고리즘을 사용하며, 이 알고리즘은 파티션의 추가나 통합 시 다른 파티션에 미치는 영향을 최소화해준다.

### 리니어 해시 파티션/리니어 키 파티션

리니어 해시 파티션이나 리니어 키 파티션의 경우 단순히 나머지 연산으로 레코드가 저장될 파티션을 결정하는 것이 아니라 `Power-of-two` 분배 방식을 사용하기 때문에 파티션의 추가나 통합 시 특정 파티션의 데이터에 대해서만 이동 작업을 하면 된다. 그래서 나머지 파티션의 데이터는 재분배 대상이 되지 않는다.

### 리니어 해시 파티션/리니어 키 파티션 주의 사항

일반 해시 파티션이나 키 파티션은 데이터 레코드 배치를 위해 해시 값의 결과를 파티션 수로 나눈 나머지 값으로 배치하는 데 비해 리니어 파티션은 특정 알고리즘을 사용하기 떄문에 각 파티션이 가지는 레코드의 건수가 비교적 덜 균등해질 수 있다.
  
따라서 새로운 파티션을 추가하거나 삭제해야 할 경우가 많다면 리니어 파티션을 사용하는 것이 좋고, 아니라면 일반 해시, 키 파티션을 사용하는 것이 좋다.

## 파티션 테이블의 쿼리 성능

파티션 테이블에 쿼리가 실행될 때 테이블의 모든 파티션을 읽을지 아니면 일부 파티션만 읽을지는 성능에 아주 큰 영향을 미친다. 쿼리의 실행 계획이 수립될 때 불필요한 파티션은 모두 배제하고 꼭 필요한 파티션만을 걸러내는 과정을 `파티션 프루닝`이라고 한다. 쿼리의 성능은 테이블에서 얼마나 많은 파티션을 프루닝할 수 있는지가 관건이다. 이는 실행계획으로 확인할 수 있다.
  
일반적으로 레인지 파티션이나 리스트 파티션을 사용하는 테이블은 개별 파티현을 명시해야 한다. 그래서 일반적으로 레인지 파티션이나 리스트 파티션이 사용되는 테이블의 파티션의 개수는 10~20개 내외로 적은 편이다. 하지만 해시나 키 파티션의 경우 단순히 파티션의 개수만 지정하면 되기 댸문에 많은 파티션을 가진 테이블도 쉽게 생성할 수 있게된다.
  
```SQL
CREATE TABLE user (
  user_id BIGINT NOT NULL,
  name VARCHAR(20)
  ...
  INDEX ix_name (name)
) PARTITION BY KEY() PARTITIONS 1024;
```

위 테이블에 대해 `SELECT * FROM user WHERE name='toto';` 쿼리를 날린다고 가정해보면
  
user 테이블이 별도로 파티션되지 않았다면 B-Tree를 단순히 한 번만 룩업해서 name='toto'인 레코드만 스캔해서 읽으면 되므로 이 쿼리는 매우 효율적인 쿼리가 된다. 하지만 지금 예제에서는 테이블이 1024개의 파티션으로 쪼개져 있기 때문에 name='toto'인 레코드를 찾는 작업을 1024번 해야 한다. 물론 파티션된 개별 인덱스의 크기가 작다면 크게 부담되지 않을 수도 있다. 그런데 테이블이 작아서 부담되지 않는다면 오히려 파티션을 구성하지 않는 것도 하나의 방법일 수 있다.

테이블을 10개로 파티션해서 10개의 파티션중에서 주로 1~3개의 정도의 파티션만 읽고 쓴다면 파티션 기능이 성능 향상에 도움이 될 것이다. 그런데 10개로 파티션하고 파티션된 10개를 아주 균등하게 사용해버린다면 이는 성능 향상보다 오히려 오버헤드만 심해지는 결과를 만든다. 오히려 대용량 테이블을 10개로 쪼개서 서로 다른 MySQL 서버에 샤딩하는게 매우 효율적일 것이다. 하지만 MySQL 서버의 파티션은 샤딩이 아니고, 파티션을 사용할 때는 파티션 프루닝을 얼마나 효율적으로 사용할 수 있을지 먼저 예측하는 것이 중요하다. 레인지 파티션 이외의 파티션을 적용할 때는 파티션 프루닝을 더 많이 고려해보고 적용하는 것이 권장된다.


## Reference 


**위 글은 책 RealMySQL 8.0을 구입하여 읽고 정리한 내용입니다.**
- [도서 홈페이지 https://wikibook.co.kr/realmysql801/](https://wikibook.co.kr/realmysql801/)
- [Real MySQL 시즌 1 - Part 2](https://www.inflearn.com/course/real-mysql-part-2/dashboard)
