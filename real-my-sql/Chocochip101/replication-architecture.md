데이터베이스를 사용하고 운영할 때 가장 중요한 두 가지 요소를 꼽으라면 바로 확장성(Scalability)과 가용성(Availability)이다. 서비스에서 발생하는 대용량 트래픽을 안정적으로 처리하고 위해서는 데이터베이스 서버의 확장이 필수적이며, 사용자가 언제든지 안정적인 서비스를 이용할 수 있게 하려면 DBMS 서버를 포함한 하위 시스템들의 가용성이 반드시 뒷받침돼야 한다. 이 두 요소를 위해 가장 일반적으로 사용되는 기술이 바로 `복제(replication)`다. MySQL에서 제공하는 복제는 어떤 것이 있고, 어떻게 구현 및 작동하는지 알아보자.


복제는 한 서버에서 다른 서버로 데이터가 동기화되는 것을 말하며, **원본 데이터를 가진 서버를 소스(Source) 서버**, **복제된 데이터를 가지는 서버를 레플리카(Replica) 서버**라고 부른다. 소스 서버에서 데이터 및 스키마에 대한 변경이 최초로 발생하며, 레플리카 서버에서는 이러한 **변경 내역을 소스 서버로부터 전달받아** 자신이 가지고 있는 데이터에 반영함으로써 소스 서버에 저장된 데이터와 동기화시킨다.

# 목적
대부분의 DBMS에서 복제 기능을 제공하며, 일반적으로 서비스에서 사용될 DB 서버를 구축할 때는 메인으로 사용될 소스 서버 한 대와 복제를 통해 소스 서버와 동일한 데이터를 가진 레플리카 서버를 한 대 이상 함께 구축한다. 이는 서비스의 메인 DB 서버인 소스 서버에 문제가 생겼을 때를 대비하려는 목적이 제일 크지만, 그 외에도 레플리카 서버를 구축하는 데는 여러 가지 목적이 있다. 

## 스케일 아웃(Scale-out) 
서비스를 운영하다 보면 사용자가 늘어나고, 이에 따라 DB 서버로 유입되는 트래픽도 자연히 증가해 DB 서버의 부하가 높아진다. 현재 서비스에서 사용되는 DB 서버가 한 대라고 가정해보자. 트래픽이 증가해 DB 서버의 부하가 높아지면 여러 가지 조치를 취할 수 있겠지만 하나의 해결 방법으로 서버의 사양을 업그레이드하기도 한다. 이를 스케 일 업(Scale-up)이라고 한다. 이 방법은 애플리케이션 단의 큰 변화 없이 늘어난 트래픽을 처리할 수 있다는 장점이 있지만 일시적이라는 단점도 있다. 서버의 사양을 업그레이드한다 하더라도 한 대에서 처리할 수 있는 양에는 한계가 있기 때문이다. 

만약 동일한 데이터를 가진 DB 서버를 한 대 이상 더 사용할 수 있다면 애플리케이션으로부터 실행되는 쿼리들을 분산시킬 수 있을 것이다. 이 같은 방법을 스케일 아웃(Scale-out)이라고 하며, 스케일 아웃은 스케일 업 방식보다 갑자기 늘어나는 트래픽을 대응하는 데 훨씬 더 유연한 구조다. 복제를 사용해 DB 서버를 스케일 아웃할 수 있으며, 이를 통해 서비스를 좀 더 안정적으로 운영할 수 있다.

## 데이터 백업 
DB 서버에는 다양한 종류의 데이터가 저장되는데, 사용자의 실수로 데이터가 삭제되면 서비스 운영에 치명적인 영항을 줄 수 있다. 이러한 경우에 대비하기 위해서는 DB 서버에 저장된 **데이터들을 주기적으로 백업**하는 것이 필수적이다. 백업에 사용되는 툴들은 DBMS마다 종류와 방식이 다르지만 보통은 데이터가 저장돼 있는 DB 서버에서 백업 프로그램이 실행되어 백업을 진행한다. 이처럼 동일한 서버 내에서 백업이 실행되는 경우 백업 프로그램과 DBMS가 서버의 자원을 공유해서 사용하기 때문에 백업으로 인해 DBMS에서 실행 중인 쿼리들이 영향을 받을 수 있으며, 심각한 경우에는 쿼리의 처리 속도가 느려져 서비스에 문제가 발생할 수도 있다. 이 같은 문제를 방지하기 위해 주로 복제를 사용해 레플리카 서버를 구축하고, 데이터 백업은 레플리카 서버에서 실행한다. 이렇게 구축된 백 업용 레플리카 서버는 소스 서버가 문제 생겼을 때를 대비한 대체 서버의 역할을 하기도 한다. 

## 데이터 분석 

DB 서버에서는 기본적으로 서비스에서 사용되는 쿼리들이 실행되지만 비즈니스 모델을 발굴하기 위해서나 서비스를 좀 더 발전시킬 수 있는 인사이트를 얻기 위해 분석용 쿼리들을 실행하기도 한다. 이러한 **분석용 쿼리는 대량의 데이터를 조회하는 경우가 많고, 또 집계 연산을 하는 등 쿼리 자체가 굉장히 복잡하고 무거운 경우가 대부분이라서 쿼리를 실행할 때 서버의 리소스를 많이 사용하게 된다.** 이로 인해 서비스에서 직접적으로 사용되는 다른 쿼리들이 영향을 받을 수 있으므로 복제를 사용해 여분의 레플리카 서버를 구축해 분석용 쿼리만 전용으로 실행될 수 있는 환경을 만드는 것이 좋다. 

## 데이터의 지리적 분산 
서비스에서 사용되는 애플리케이션 서버와 DB 서버는 지리적으로 근접한 위치에 존재할 수도 있고, 혹은 장거리로 떨어져 있을 수도 있다. DB 서버와 애플리케이션 서버가 서로 떨어져 있는 경우 두 서버 간의 통신 시간은 떨어진 거리만큼 비례해서 늘어난다. 서비스의 응답 속도는 애플리케이션 서버의 처리 속도와 더불어 이러한 서버 간의 통신 속도에도 영향을 받으므로 사용자에게 빠른 응답 속도를 제공하려면 애플리케이션 서버와 DB 서버가 가깝게 위치하는 것이 좋다. 만약 떨어져 있는 DB 서버의 위치를 이동시키지 못한다면 **복제를 사용해 애플리케이션 서버가 위치한 곳에 기존 DB 서버에 대한 레플리카 서버를 새로 구축해 사용함으로써 응답 속도를 개선**할 수 있다. 

MySQL의 복제는 2000년도부터 제공되어 지금까지 꾸준하게 발전해온 기능으로, 그만큼 안정적이며 구축하는 방법 또한 쉽고 간단하다. 지금부터는 MySQL의 복제에 대해 자세히 살펴보자.

# 복제 아키텍처 
MySQL 서버에서 발생하는 **모든 변경 사항은 별도의 로그 파일에 순서대로 기록되는데, 이를 바이너리 로그(Binary Log)**라고 한다. 바이너리 로그에는 데이터의 변경 내역뿐만 아니라 데이터베이스나 테이블의 구조 변경과 계정이나 권한의 변경 정보까지 모두 저장된다. 바이너리 로그에 기록된 각 변경 정보들을 이벤트(Event)라고도 한다. 

MySQL의 복제는 이 바이너리 로그를 기반으로 구현됐는데, 소스 서버에서 생성된 바이너리 로그가 레플리카 서버로 전송되고 레플리카 서버에서는 해당 내용을 로컬 디스크에 저장한 뒤 자신이 가진 데이터에 반영함으로써 소스 서버와 레플리카 서버 간에 데이터 동기화가 이뤄진다. 레플리카 서버에서 소스 서버의 바이너리 로그를 읽어 들여 따로 로컬 디스크에 저장 해둔 파일을 릴레이 로그(Relay Log)라 한다. 아래 그림에서 MySQL에서 복제 동기화가 처리되는 전반적인 과정을 보여준다. 

![](https://velog.velcdn.com/images/chocochip/post/b47e3353-fddc-48be-b9ef-c561dcaa836b/image.png)



## 복제 스레드
MySQL의 복제는 세 개의 스레드에 의해 작동하는데, 이 세 스레드 중 하나는 소스 서버에 존재하며, 나머지 두 개의 스레드는 레플리카 서버에 존재한다. 

각 스레드의 역할은 다음과 같다.

- 바이너리 로그 덤프 스레드(Binary Log Dump Thread): 레플리카 서버는 데이터 동기화를 위해 소스 서버에 접속해 바이너리 로그 정보를 요청한다. 소스 서버에서는 레플리카 서버가 연결될 때 내부적으로 바이너리 로그 덤프 스레드를 생성해서 바이너리 로그의 내용을 레플리카 서버로 전송한다. 바이너리 로그 덤프 스레드는 레플리카 서버로 보낼 각 이벤트를 읽을 때 일시적으로 **바이너리 로그에 잠금**을 수행하며, 이벤트를 읽고난 후에는 바로 잠금을 해제한다. 이 스레드는 소스 서버에서 SHOW PROCESSLIST 명령을 통해 확인할 수 있다. 

- 레플리케이션 I/O 스레드(Replication I/O Thread): 복제가 시작(START REPLICA 또는 START SLAVE 명령)되면 레플리카 서버는 I/O 스레드를 생성하고, 복제가 멈추면(STOP REPLICA 또는 STOP SLAVE 명령) I/O 스레드는 종료된다. I/O 스레드는 소스 서버의 바이너리 로그 덤프 스레드로부터 바이너리 로그 이벤트를 가져와 로컬 서버의 파일 (릴레이 로그)로 저장하는 역할을 담당한다. 소스 서버의 바이너리 로그를 읽어서 파일로 쓰는 역할만 하기 때문에 "I/O" 스레드라고 명명된 것이다. 이 스레드의 상태는 MySQL의 복제 현황을 보여주는 SHOW REPLICA STATUS(또는 SHOW SLAVE STATUS) 명령의 결과에서 `Replica_IO_Running`(또는 `Slave_IO_running`) 칼럼에 표시된 값을 통 해 확인할 수 있다. 

- 레플리케이션 SQL 스레드(Replication SQL Thread): 레플리케이션 1/O 스레드가 소스 서버로부터 가져온 바이너리 로그 이벤트들을 로컬 파일로 기록하는 역할이라면, 레플리케이션 SQL 스레드는 I/O 스레드에 의해 작성된 릴레이 로그 파일의 이벤트들을 읽고 실행한다. SQL 스레드도 I/O 스레드와 마찬가지로 SHOW REPLICA STATUS(또는 SHOW SLAVE STATUS) 명령을 통해 스레드의 상태를 확인할 수 있으며, `Replica_SQL_Running`(또는 `Slave_SQL_running`) 칼럼에 SQL 스레드의 현재 상태가 표시된다. 


레플리카 서버에서 레플리케이션 I/O 스레드와 SQL 스레드는 **서로 독립적으로 동작**한다. 그러므로 만약 SQL 스레드에서 이벤트를 적용하는게 느리더라도 I/O 스레드는 그것과 무관하게 정상적으로 빠르게 소스 서버로부터 이벤트를 읽어올 수 있다. 또한 레플리카 서버에서 소스 서버의 변경 사항들이 적용되는 것은 소스 서버가 동작하는 것과는 별개로 진행되므로 레플리카 서버에 문제가 생기더라도 소스 서버는 전혀 영향을 받지 않는다. 그러나 소스 서버에 문제가 생겨 레플리카 서버의 I/O 스레드가 정상적으로 동작하지 않게 되면 복제는 에러를 발생시키고 바로 중단된다. 하지만 이는 레플리카 서버의 복제 기능만 중단된 것이므로 여전히 레플리카 서버가 쿼리를 처리하는 데는 아무런 문제가 없다. 다만 **레플리카 서버의 데이터는 소스 서버로부터 동기화되지 못하기 때문에 예전 상태의 데이터를 보게 된다**. 

## 복제 로그
복제가 시작되면 레플리카 서버는 앞에서 언급한 릴레이 로그를 비롯해 기본적으로 총 세 가지 유형의 복제 관련 데이터를 생성하고 관리한다.

- 릴레이 로그(Relay Log): 레플리케이션 I/O 스레드에 의해 작성되는 파일로, 소스 서버의 바이너리 로그에서 읽어온 **이벤트(트랜잭션) 정보가 저장**된다. 릴레이 로그는 바이너리 로그와 마찬가지로 현재 존재하는 릴레이 로그 파일들 의 목록이 담긴 인덱스 파일과 실제 이벤트 정보가 저장돼 있는 로그 파일들로 구성된다. 릴레이 로그에 저장된 트랜잭션 이벤트들은 레플리케이션 SQL 스레드에 의해 레플리카 서버에 적용된다. 

- 커넥션 메타데이터(Connection Metadata): 커넥션 메타데이터에는 레플리케이션 I/O 스레드에서 소스 서버에 연결할 때 사용하는 DB 계정 정보 및 현재 읽고 있는 소스 서버의 바이너리 파일명과 파일 내 위치 값 등이 담겨 있으며, 이러한 정보는 기본적으로 `mysql.slave_master_info` 테이블에 저장된다.

- 어플라이어 메타데이터(Applier Metadata): 레플리케이션 SQL 스레드에서 릴레이 로그에 저장된 소스 서버의 이벤트들을 레플리카 서버에 적용(Replay)하는 컴포넌트를 어플라이어(Applier)라고 한다. 어플라이어 메타데이터는 최근 적용된 이벤트에 대해 해당 이벤트가 저장돼 있는 릴레이 로그 파일명과 파일 내 위치 정보 등을 담고 있으며, 레플리케이션 SQL 스레드는 이 정보들을 바탕으로 레플리카 서버에 나머지 이벤트들을 적용한다. 이 정보는 기본적으로 `mysql.slave_relay_log_info` 테이블에 저장된다. 

커넥션 및 어플라이어 메타데이터는 MySQL의 시스템 변수인 `master_info_repository`와 `relay_log_info_repository`를 통해 어떤 형태로 데이터를 관리할지 설정할 수 있는데, 설정 가능한 값으로는 FILE 과 TABLE의 두 가지가 있다. 시스템 변수들의 값을 FILE로 설정하면 커넥션 메타데이터와 어플라이어 메타데이터는 각각 MySQL의 데이터 디렉터리에서 master.info와 relay-log.info라는 파일로 관리되며, 이 두 파일의 경로는 --master-info-file 옵션과 relay_log_info_file 시스템 변수를 이용해 사용자 가 원하는 경로의 파일로 지정할 수 있다. 시스템 변수들의 값을 TABLE로 설정하면 MySQL의 mysq1 데 이터베이스 내 slave_master_info와 slave_relay_log_info 테이블에 각각의 데이터가 저장된다. 

이 두 시스템 변수들은 MySQL 8.0.2 버전부터 기본값이 TABLE로 변경됐으며, FILE 타입은 향후 버전 에서 제거(Deprecated)될 예정이다. 

8.0.2 이전 버전에서는 두 변수의 기본값이 FILE이었는데, FILE로 설정하는 경우 레플리케이션 I/O 스레드와 SQL 스레드가 동작할 때 이 두 파일의 내용이 동기화되지 않는 경우가 빈번하게 발생했다. 예를 들어, 레플리카 서버가 비정상 종료되는 경우 실제 적용된 바이 너리 로그 위치와 파일에 저장된 위치가 일치하지 않거나 파일 자체가 손상되어 복제가 재시작되지 못 하는 경우가 발생하곤 했다. 두 변수 값을 TABLE로 설정할 수 있게 된 것은 MySQL 5.6 버전부터이며, TABLE로 설정하면 두 정보들이 모두 InnoDB 스토리지 엔진 기반의 테이블로 관리되고 특히 레플리케 이션 SQL 스레드가 트랜잭션을 적용할 때 `slave_relay_log_info` 테이블의 데이터도 같은 시점에 Atomic하게 업데이트되므로 예기치 않게 MySQL이 갑자기 종료됐다고 하더라도 다시 구동했을 때 문제없이 복제가 진행될 수 있다. 이를 크래시 세이프 복제(Crash-safe replication)라고 한다.

# 복제 타입 
MySQL의 복제는 소스 서버의 바이너리 로그에 기록된 변경 내역(바이너리 로그 이벤트)들을 식별하는 방식에 따라 **바이너리 로그 파일 위치 기반 복제**와 **글로벌 트랜잭션 ID 기반 복제**로 나뉜다.

## 바이너리 로그 파일 위치 기반 복제 
바이너리 로그 파일 위치 기반 복제는 MySQL에 복제 기능이 처음 도입됐을 때부터 제공된 방식으로, 레플리카 서버에서 소스 서버의 **바이너리 로그 파일명**과 **파일 내에서의 위치(Offset 또는 Position)**로 개별 바이너리 로그 이벤트를 식별해서 복제가 진행되는 형태를 말한다. 

일반적으로 복제를 처음 구축할 때 **레플리카 서버에 소스 서버의 어떤 이벤트부터 동기화를 수행할 것인가에 대한 정보를 설정**해야 한다. 또한 복제가 설정된 레플리카 서버는 소스 서버의 어느 이벤트까지 로컬 디스크로 가져왔고 또 적용했는지에 대한 정보를 관리하며, 소스 서버에 해당 정보를 전달해 그 이후의 바이너리 로그 이벤트들을 가져온다. 따라서 **소스 서버에서 발생한 각 이벤트에 대한 식별이 반드시 필요**하다. 

바이너리 로그 파일 위치 기반 복제에서는 이러한 이벤트 하나하나를 소스 서버의 바이너리 로그 파일 명과 파일 내에서의 위치 값(File Offset)의 조합으로 식별한다. 레플리카 서버에서는 이처럼 각 이벤트들을 식별하고 자신의 적용 내역을 추적함으로써 복제를 일시적으로 중단할 수 있으며 재개할 때도 자신이 마지막으로 적용했던 이벤트 이후의 이벤트들부터 다시 읽어올 수 있다. 

바이너리 로그 파일 위치 기반 복제에서 또 하나 중요한 부분은 바로 **복제에 참여한 MySQL 서버들이 모두 고유한 server_id 값을 가지고 있어야 한다**는 점이다. 바이너리 로그에는 각 이벤트별로 이 이벤트가 최초로 발생한 MySQL 서버를 식별하기 위해 부가적인 정보도 함께 저장되는데, 바로 MySQL 서버의 server_id 값이다. server_id는 MySQL 서버의 시스템 변수 중 하나로, 사용자가 MySQL 서버마다 원하는 값으로 설정할 수 있으며 기본값은 1이다. 

바이너리 로그 파일 위치 기반 복제에서는 바이너리 로그 파일에 기록된 이벤트가 레플리카 서버에 설정된 server_id 값과 동일한 server_id 값을 가지는 경우 레플리카 서버에서는 해당 이벤트를 적용하지 않고 무시하게 된다. 자신의 서버에서 발생한 이벤트로 간주해서 적용하지 않기 때문이다. 이러한 부분을 제대로 인지하고 사용하지 않으면 복제가 의도한 방향과는 다르게 동작할 수 있다. 그래서 사용자는 바이너리 로그 파일 위치 기반으로 복제를 구축할 때 이 점을 반드시 숙지해서 복제의 구성원이 되는 **모든 MySQL 서버가 고유한 server_id 값을 갖도록 설정해야 한다.** 

### 바이너리 로그 파일 위치 기반의 복제 구축 
MySQL 서버 간에 복제를 설정할 때는 각 서버에 데이터가 이미 존재하는지 여부와 복제를 어떻게 활용할 것인지 등에 따라 복제 설정 과정 및 구축 방법이 달라진다. 여기서는 한 대로 구성해서 사용하던 MySQL 서버에 새로운 레플리카 서버를 바이너리 로그 파일 위치 기반의 복제로 연결하는 과정을 살펴보자.

#### 설정 준비 
기본적으로 MySQL 복제를 사용하려면 소스 서버에서 반드시 바이너리 로그가 활성화돼 있어야 하며, 바이너리 로그 파일 위치 기반의 복제 설정을 위해서는 앞서 언급했던 것처럼 **복제 구성원이 되는 각 MYSQL 서버가 고유한 server_id 값을 가져야 한다.** MySQL 8.0에서는 바이너리 로그가 기본적으로 활성화돼 있어, 서버 시작 시 데이터 디렉터리 밑에 "binlog"라는 이름으로 바이너리 로그 파일이 자동으로 생성된다. server_id 값도 기본적으로 1로 설정되는데, MySQL 서버마다 고유한 값을 가져야 하므로 기본값이 아닌 다른 값으로 설정하는 것이 좋다. 결론적으로 소스 서버에서는 server_id 값만 적절하게 설정해도 복제는 가능하다고 할 수 있다. 

만약 바이너리 로그 파일 위치나 파일명을 따로 설정하고 싶다면 log_bin 시스템 변수를 통해 원하는 값으로 설정할 수 있다. 또한 추가적으로 필요에 따라 바이너리 로그 동기화 방식이나 바이너리 로그를 캐시하기 위한 메모리 크기, 바이너리 로그 파일 크기, 보관 주기 등도 지정할 수 있다. 
```bash
# 소스 서버 설정 
[mysqld] 
server_id=1 
log_bin=/binary-log-dir-poath/binary-log-name 
sync_binlog=1 
binlog_cache_size=5M 
max_binlog_size=512M 
binlog_expire_logs_sseconds=1209600 
...
```
소스 서버에서 바이너리 로그가 정상적으로 기록되고 있는지는 다음과 같이 소스 서버에 로그인해서 SHOW MASTER STATUS라는 명령을 실행해보면 된다. 
```bash
mysql> SHOW MASTER STATUS;
|File				|Position		|Binlog_Do_DB		|Binlog_Ignore_DB	|Executed_Gtid_Set	|
|binary_log.045214	|19423770		|					|					|
```
명령어 실행 예제에서 현재 사용(기록)되고 있는 바이너리 로그 파일의 이름은 "binary_log.845214"이며, 해당 파일에서 현재까지 기록된 **바이너리 로그의 위치**는 19423770이라는 것을 알 수 있다. 여기서 바이너리 로그의 위치는 실제 파일의 바이트 수를 의미하는 값으로, 크게 신경 쓰지 말고 그냥 위치 값 이라고 생각하면 된다. MySQL 서버가 트랜잭션을 계속 처리하고 있는 중이라면 이 값은 계속 증가할 것이다. 

레플리카 서버도 소스 서버와 마찬가지로 중복되지 않는 고유한 server_id만 설정해도 된다. 레플리카 서버에서 복제를 위해 생성하는 릴레이 로그 파일도 복제 설정 시 기본적으로 데이터 디렉터리 밑에 자동으로 생성된다. 릴레이 로그 파일 위치나 파일명을 따로 설정하려면 relay_log 시스템 변수를 사용해 원하는 값으로 지정하면 된다. 릴레이 로그에 기록된 이벤트는 레플리카 서버에 적용되면 더이상 필요하지 않게 되는데, 이렇게 필요 없어진 릴레이 로그 파일은 레플리카 서버가 자동으로 삭제한다. 만약 릴레이 로그 파일을 자동으로 삭제하지 않고 유지하고자 한다면 relay_log_purge 시스템 변수를 OFF 로 설정하면 된다. 하지만 relay_log_purge 시스템 변수를 OFF로 설정하는 경우 레플리카 서버의 디스크 여유 공간이 부족하지 않은지 모니터링하는 것이 좋다. 또한 레플리카 서버는 일반적으로 읽기 전용으로 사용되므로 read_only 설정도 함께 사용하는 편이 좋으며, 추후 소스 서버의 장애로 이 레플리카 서 버가 소스 서버로 승격될 수 있음을 고려하면 log_slave_updates 시스템 변수도 명시하는 것이 좋다. 기본적으로 레플리카 서버는 복제에 의한 데이터 변경 사항은 자신의 바이너리 로그에 기록하지 않는데. log_slave_updates 시스템 변수를 설정하면 복제에 의한 데이터 변경 내용도 자신의 바이너리 로그에 기록하게 된다. 
```bash
# 레플리카 서버 설정 
[mysqld] 
server_id=2 
relay_log_purge=ON
read_only 
log_slave_updates 
...
```
#### 복제 계정 준비 
레플리카 서버가 소스 서버로부터 바이너리 로그를 가져오려면 소스 서버에 접속해야 하므로 **접속 시 사용할 DB 계정이 필요**하다. 이때 레플리카 서버가 사용할 계정을 복제용 계정이라고 한다. 복제를 위해 특별히 새로운 계정을 만들 필요 없이 기존의 사용 중인 계정에 복제 관련 권한을 추가로 부여해도 되지만 **복제에서 사용되는 계정의 비밀번호는 레플리카 서버의 커넥션 메타데이터에 평문으로 저장되므로 보안 측면을 고려해서 복제에 사용되는 권한만 주어진 별도의 계정을 생성해 사용하는 것이 좋다.** 복제용 계정은 복제를 시작하기 전 소스 서버에 미리 준비돼 있어야 하며, 이 계정은 반드시 "REPLICATION SLAVE" 권한을 가지고 있어야 한다. 계정 생성을 위해 소스 서버에 아래 명령문을 실행 한다. 
```sql
CREATE USER 'repl_user'@'%' IDENTIFIED BY 'repl_user_password'; 
GRANT REPLICATION SLAVE ON * * TO 'repl_user'@'%'; 
```
> 주의 여기서는 설명의 편의를 위해 복제 계정의 호스트 제한을 "%"로 설정했지만 보안을 위해서 꼭 필요한 IP 대역에 서만 복제 연결이 가능하도록 호스트 제한에 "%" 대신 적절한 IP 대역을 설정하는 것이 좋다. 

#### 데이터 복사 

이제 소스 서버의 데이터를 레플리카 서버로 가져와서 적재해야 하는데, MySQL 엔터프라이즈 백업이나 mysqldump 등과 같은 툴을 이용해 소스 서버에서 데이터를 내려받아 레플리카 서버로 복사하면 된다. 일반적으로 데이터가 크지 않다면 mysqldump를 많이 사용하므로 mysqldump로 데이터를 복사하는 방법을 예제로 살펴보겠다. 


mysqldump를 사용해 소스 서버의 데이터를 덤프할 때는 "--single-transaction"과 "--master-data"라는 두 옵션을 반드시 사용해야 한다. 

- `--single-transaction` 옵션: 데이터를 덤프할 때 하나의 트랜잭션을 사용해 덤프가 진행되게 해서 mysqldump가 테이블이나 레코드에 잠금을 걸지 않고 InnoDB 테이블들에 대해 일관된 데이터를 덤프받을 수 있게 한다. 

- `--master-data` 옵션: 덤프 시작 시점의 소스 서버의 바이너리 로그 파일명과 위치 정보를 포함하는 복제 설정 구문(CHANGE REPLICATION SOURCE TO 또는 CHANGE MASTER TO)이 **덤프 파일 헤더에 기록될 수 있게 하는 옵션**으로, **복제 연결을 위해 반드시 필요한 옵션**이다. "--master-data" 옵션을 사용할 때 mysqldump는 MySQL 서버에서 "FLUSH TABLES WITH READ LOCK" 명령을 실행해 글로벌 락(모든 테이블에 대한 읽기 잠금)을 거는데, 이는 바이너리 로그의 위치를 순간적으로 고정시키기 위함이다. \
  - 옵션은 1 또는 2로 설정할 수 있으며, 옵션 값이 1로 설정되면 덤프 파일 내의 복제 설정 구문(CHANGE REPLICATION SOURCE TO 또는 CHANGE MASTER TO)이 실제 실행 가능한 형태로 기록되고, 2로 설정되면 해당 구문이 주석으로 처리되어 참조만 할 수 있는 형태로 기록된다. 


다음은 소스 서버의 로컬에서 mysqldump를 실행해 데이터를 덤프하는 명령어의 예다. 
```bash
linux> mysqldump -uroot -p --single-transaction --master-data=2 \
		--opt --routines --triggers --hex-blob --all-databases > source_data.sql 
```
데이터 덤프가 완료되면 source_data.sql 파일을 레플리카 서버로 옮겨 데이터 적재를 진행한다. 레플 리카 서버에 접속한 후 다음과 같이 명령어를 실행한다. 명령어 예제에서는 source_data.sql 파일이 레 플리카 서버의 /tmp 디렉터리에 준비돼 있다고 가정했다. 
```sql
// MySQL 서버에 직접 접속해 데이터 적재 명령을 실행 
mysql> SOURCE /tmp/master_data.sql 

## MySQL 서버에 로그인하지 않고 데이터 적재 명령을 실행 
## 다음 두 명령어 중 하나를 사용 
linux> mysql -uroot -p く /tmp/source_data.sql 
linux> cat /tmp/source_data.sql | mysql -uroot -p 
```

만약 mysqldump에 지정된 --master-data 옵션으로 소스 서버에 "FLUSH TABLES WITH READ LOCK" 명령이 실행되기 전에 MySQL 서버에 이미 장시간 동안 실행 중인 쿼리가 있다면 글로벌 락 명령어가 실행 중인 쿼리에서 참 조하고 있는 테이블들에 대한 잠금을 획득할 수 없어 완료되지 못하고 대기하게 된다. 이처럼 글로벌 락 명령어가 대기 하는 상황이 발생하면 그 뒤로 유입되는 다른 쿼리들도 연달아 대기해서 쿼리가 실행되지 못하고 적체될 수 있으며, 이 경우 서비스에 문제가 될 수 있으므로 mysqldump를 실행하기 전에 장시간 실행 중인 쿼리가 있는지 미리 확인하는 것 이 좋다. 그리고 mysqldump를 실행한 후에도 앞서 설명한 것과 같은 대기 현상이 발생하고 있지는 않은지 한번 더 확 인하는 것이 좋다.

#### 복제 시작 
복제를 시작하기 전에 지금 소스 서버와 레플리카 서버의 데이터 상태가 어떤지, 복제를 시작하면 어떻게 동기화가 진행되는지 그림으로 간단히 살펴보자.

![](https://velog.velcdn.com/images/chocochip/post/ce8b7bda-1710-46b9-8645-674e3d4dd24d/image.png)

위 그림을 보면서 "레플리카 서버 데이터 적재 완료" 시점에 소스 서버와 레플리카 서버의 데이터 상태가 어떻게 다른지, **소스 서버와 레플리카 서버의 데이터를 어떻게 동기화할지 한번 살펴보자.** 10:30에 mysqldump를 이용해 소스 서버의 데이터를 백업받아 11:20 쯤에 레플리카 서버에 모두 적재됐다. 레플리카 서버에 데이터 적재가 완료된 11:20 시점에서 보면 레플리카 서버의 데이터는 소스 서버의 데이터보다 **50분이 지연된 상태**라 할 수 있다. 

이제 다음으로 넘어가서 **소스 서버와 레플리카 서버 간의 복제**를 설정해보자. 복제를 설정하는 명령은 CHANGE REPLICATION SOURCE TO(또는 CHANGE MASTER TO) 명령으로, **mysqldump로 백업받은 파일의 헤더 부분에서 해당 명령어를 참조**할 수 있다. 백업받은 파일은 크기가 크기 때문에 vi 같은 텍스트 편집기 보다는 less 같은 페이지 단위의 뷰어를 이용해 파일을 여는 것이 좋다. less 명령으로 첫 번째 페이지만 참조하면 되기 때문에 바로 "q" 키를 눌러 less 명령을 종료하고 위에서부터 대략 24번째 줄에 있는 "CHANGE MASTER"로 시작하는 줄만 텍스트 편집기에 복사해둔다. 
```bash
linux> less/tmp/source_data.sql
... 
--
-- Position to start replication or point-in-time recovery from
---

---CHANGE MASTER TO MASTER_LOG_FILE='binary-log.000002', MASTER_LOG_POS=2708;
```
이제 편집기에 복사해 둔 내용에 소스 서버 MySQL 서버의 호스트명, 포트, 복제용 사용자 계정, 비밀 번호 등을 다음과 같이 추가해 복제 설정 명령을 준비한다. 

```bash
CHANGE REPLICATION SOURCE TO 
	SOURCE_HOST='source_server_host',
    SOURCE_PORT=3306, 
    SOURCE_USER='repl_user', 
    SOURCE_PASSWORD='repl_user_password',
    SOURCE_LOG_FILE='binary-log.00002', 
    SOURCE_LOG_POS=2708, 
    GET_SOURCE_PUBLIC_KEY=1;
```

- SOURCE_HOST: 레플리카 서버에서 복제 연결할 소스 서버를 의미하며, 소스 서버의 IP 혹은 도메인 정보를 넣으면 된다.
- SOURCE_PORT: 소스 서버에서 구동 중인 MySQL 서버의 포트 번호
- SOURCE_USER 및 SOURCE_PASSWORD: 복제용 계정 정보
- SOURCE_LOG_FILE, SOURCE_LOG_POS: 복제를 시작하고자 하는 바이너리 로그 파일명과 위치값
- GET_SOURCE_PUBLIC_KEY: RSA 키 기반 비밀번호 교환 방식의 통신을 위해 공개키(Public key)를 소스 서버에 요청할 것인지 여부

복제 설정 명령 예제처럼 복제 설정에 보안된 연결(SSL)과 관련된 옵션들을 명시하지 않아 레플리카 서버가 소스 서버와 암호화되지 않는 통신 방식으로 연결되는 경우 "GET_SOURCE_PUBLIC_KEY=1" 구문 없이 복제 설정 후 복제 를 시작했을 때 다음과 같은 에러가 발생할 수 있으므로 반드시 설정해야 한다.

```bash
Last_I0_Errno: 2061 
Last_I0_Error: error connecting to master 'repl_user@192.43.2.1:3306' - retry-time: 60 retries: Last_SQL_Error:  e 1 message: Authentication plugin 'caching_sha2_password' reported error: Authentication requires secure connection.
Last_SQL_Errno: 0
Last_SQL_Error:
```

> MySQL 버전 8.0.4부터 기본 인증 플러그인이 mysql_native_password에서 caching_sha2_password로 변경됐다. 이로 인해 사용자가 MySQL 서버에 계정을 생성할 때 별도로 인증 플러그인을 지정하지 않는 이상은 서버의 기본 인증 플러그인인 caching_sha2_password로 설정된다. 계정의 인증 플러그인이 caching_sha2_password로 설정되면 그 계정을 사용해 MySQL에 접속할 때는 반드시 보안된 연결을 사용하거나 RSA 키를 사용해 패스워드를 교환하는 방식의 비암호화된 연결을 사용해야 한다. 

이 명령을 그대로 레플리카 서버의 MySQL에 로그인해서 실행한 뒤 SHOW REPLICA STATUS(또는 SHOW SLAVE STATUS) 명령을 실행해 보면 복제 관련 정보가 레플리카 서버 MySQL에 등록돼 있는 것을 확인 할 수 있다. 하지만 Replica_IO_Running과 Replica_SQL_Running 칼럼값이 "No"로 돼 있는데, 이것은 복제 관련 정보가 등록만 된 것이지 동기화가 시작되지는 않았음을 나타낸다. 이 상태에서 **START REPLICA(또는 START SLAVE) 명령을 실행(START REPLICA 또는 START SLAVE 명령이 11:45에 실행된 것임)하면 위의 두 칼럼들이 "Yes "로 값이 바뀌면서 레플리카 서버는 가능한 한 빨리 10:30부터 11:45까지의 데이터 변경사항들을 소스 서버로부터 가져와 적용**하게 된다.

```bash
mysql> SHOW REPLICA STATUS \G
********* 1. row *********
Replica_IO_State: Waiting for master to send event Source_Host: source_server 
Source_User: repl_user 
Source_Port: 3306 
Connect_Retry: 60 
Source_Log_File: binary_log.000002 
Read_Source_Log_Pos:2708
...
Replica_IO_Running: Yes 
Replica_SQL_Running: Yes 
...
```
소스 서버에서 10:30부터 11:45까지 변경된 데이터가 그리 많지 않다면 동기화는 몇 분 내에 완료되지만 데이터가 많다면 생각보다 시간이 걸릴 수도 있다. SHOW REPLICA STATUS(또는 SHOW SLAVE STATUS) 명령의 결과에 나타나는 **Seconds_Behind_Source의 값이 0이 되면 소스 서버와 레플리카 서버의 데이터가 완전히 동기화됐음을 의미**한다. 

만약 START REPLICA(또는 START SLAVE) 명령을 실행했는데도 Replica_IO_Running과 Replica_SQL_Running 칼럼의 값이 "Yes"로 변경되지 않는다면 소스 서버의 호스트명이나 MySQL의 포트 또는 레플리카 서버에서 사용하는 복제용 접속 계정과 비밀번호가 잘못 입력됐을 가능성이 상당히 높기 때문에 그 정보가 제대로 입력됐는지 확인하는 것이 좋다. 또한 소스 서버와 레플리카 서버 간에 네트워크상의 문제가 없는지도 확인해 보는 것이 좋다.

### 바이너리 로그 파일 위치 기반의 복제에서 트랜잭션 건너뛰기 
복제로 구성돼 있는 **MySQL 서버들을 운영하다 보면 종종 레플리카 서버에서 소스 서버로부터 넘어 온 트랜잭션이 제대로 실행되지 못하고 에러가 발생해 복제가 멈추는 현상이 발생**하기도 한다. 이는 MySQL 서버의 비정상 종료와 같이 실제로 정말 예기치 못한 문제가 있어 발생할 수도 있지만 대부분은 사용자의 실수로 인해 발생하는 경우가 많다. 대표적인 에러가 바로 다음과 같은 중복 키 에러다. 
```bash
Errno: 1062 
Error: 	Error 'Duplicate entry '87' for key 'tb1.PRIMARY'' on query. 
		Default database: 'test'. Query: 'insert into tb1 values (87)' 
```
만약 복제를 중단시킨 문제가 수동으로 복구가 불가능할 정도로 심각한 문제인 경우 레플리카 서버의 데이터를 모두 버리고 처음부터 다시 레플리카 서버를 구축한 뒤 복제를 다시 구성해야 할 수도 있지만, 경우에 따라 레플리카 서버에서 문제되는 소스 서버의 트랜잭션을 무시하고 넘어가도록 처리해도 괜찮을 때가 있다. 후자에 해당하는 경우 바이너리 로그 위치 기반 복제에서는 sql_slave_skip_counter 시스템 변수를 이용해 문제되는 트랜잭션을 건너뛸 수 있다.

바이너리 로그 위치 기반 복제가 설정된 레플리카 서버에서 다음과 같이 중복된 키로 인해 INSERT 쿼리 가 실패한 상태로 복제가 멈춰져 있다고 가정해보자. 
```sql

mysql_Replica> SHOW REPLICA STATUS \G
************ 1. row 
Replica_IO_State: Waiting for master to send event 
Source_Host: source_server 
Source_User: repl_user 
Source_Port: 3306 
Connect_Retry: 60 Source_Log_File: mysql-bin.000001 Read_Source_Log_Pos: 1499 Relay_Log_File: relay-bin.00004 Relay_Log_Pos: 324 Relay_Source_Log_File: mysql-bin.000001 
Replica_IO_Running: Yes 
Replica_SQL_Running: No 
...
Last_Errno: 1062 
Last_Error: Error 'Duplicate entry '15' for key 'tb1.PRIMARY'' on query. 
Default database: 'test'. Query: 'insert into tb1 values (15) 
...
```
다음과 같이 복제를 중단한 후 sql_slave_skip_counter 변수의 값을 1로 지정해 레플리케이션 SQL 스레드를 재시작하면 레플리카 서버는 에러가 발생한 INSERT 쿼리를 건너뛰고 정상적으로 복제를 재개하게 된다.

```bash
mysql_Replica> STOP REPLICA SQL_THREAD; 
mysql_Replica> SET GLOBAL sql_slave_skip_counter=1; 
mysql_Replica> START REPLICA SQL_THREAD; 
```
`sql_slave_skip_counter` 시스템 변수에는 적용하지 않고 건너뛸 바이너리 로그 이벤트 그룹 수를 지정 한다. 즉, **sql_slave_skip_counter 시스템 변수가 1로 설정되면 MySQL 서버에서는 실제로 DML 쿼리 문장 하나를 가진 바이너리 로그 이벤트 1개를 무시하는 것이 아니라 현재 이벤트를 포함한 이벤트 그룹을 무시하는 것**이다. 이벤트 그룹은 트랜잭션을 지원하는 테이블의 경우에는 트랜잭션이 하나의 이 벤트 그룹이 되며, 트랜잭션을 지원하지 않는 테이블에서는 DML 문장 하나하나가 이벤트 그룹이 된 다. 만약 앞의 예제에서 에러가 발생한 INSERT 문이 하나의 이벤트 그룹이었다면 INSERT 문 하나만 무시됐을 것이며, 여러 DML 쿼리가 함께 포함된 이벤트 그룹이었다면 같은 이벤트 그룹에 속한 DML 퀴리 들이 모두 무시됐을 것이다. 만약 MySQL 서버에서 실행되는 DML 쿼리들이 단순하게 하나의 트랜잭션에 DML 쿼리가 하나만 실 행되는 형태라면 `sql_slave_skip_counter` 시스템 변수에 지정한 개수가 곧 쿼리의 개수이므로 사용자는 레플리카 서버에서 적용이 무시되는 쿼리 개수를 명확하게 알 수 있으며 특정 쿼리만 무시하게 할 수도 있을 것이다. 그러나 하나의 트랜잭션에 여러 개의 DML 쿼리들이 포함되는 경우가 존재한다면 에러 가 발생한 쿼리 외에 다른 쿼리들이 예상치 못하게 함께 무시될 수 있으므로 사용자는 `sql_slave_skip_counter` 시스템 변수를 사용할 때 반드시 이와 같은 부분을 주의해서 사용해야 한다. 

## 글로벌 트랜잭션 아이디(GTID) 기반 복제 
MySQL 5.5 버전까지는 복제를 설정할 때 바이너리 로그 파일 위치 기반 복제 방식만 가능했다. 문제는 이 같은 식별이 바이너리 로그 파일이 저장돼 있는 소스 서버에서만 유효하다는 것이다. 

동일한 이벤트가 레플리카 서버에서도 동일한 파일명의 동일한 위치에 저장된다는 보장이 없다. **복제에 투입된 서버들마다 동일한 이벤트에 대해 서로 다른 식별 값을 갖게 되는 것**이다. 이렇게 복제를 구성하는 서버들이 서로 호환되지 않는 정보를 이용해 복제를 진행함으로써 복제의  폴로지를 변경하는 작업은 때로 거의 불가능할 때도 많았다. 

만약 소스 서버에서 발생한 각 이벤트들이 **복제에 참여한 모든 MySQL 서버들에서 동일한 고유 식별 값**을 가진다면 장애가 발생해도 좀 더 손쉽게 복제 토폴로지를 변경할 수 있으며, 장애 복구에 소요되는 시간도 줄어들 것이다. 이처럼 소스 서버에서만 유효한 고유 식별 값이 아닌 복제에 참여한 전체 MySQL 서버들에서 고유하도록 각 이벤트에 부여된 식별 값을 글로벌 트랜잭션 아이디(GTID)라고 하며, 이를 기반으로 복제가 진행되는 형태를 GTID 기반 복제라 한다. GTID는 MySQL 5.6 버전에서 처음 도입됐으며, 5.7 버전을 거쳐 8.0까지 계속 개선돼 오면서 그에 따른 신기능도 많이 추가됐다.

### GTID의 필요성 
하나의 소스 서버에 두 개의 레플리카 서버가 연결돼 있는 복제 토폴로지다. 이런 형태는 주로 레플리카 서버를 **읽기 부하 분산** 및 통계나 배치용으로 구성할 때 많이 사용한다. 
![](https://velog.velcdn.com/images/chocochip/post/af28e5da-0190-4ef3-a597-faa4ec639f79/image.png)


그림에서 현재 소스 서버 A의 바이너리 로그 위치는 "binary-log.060002:320"이며, 레플리카 서버 B 는 완전히 동기화되어 똑같이 "binary-log.000002:320" 바이너리 로그 이벤트까지 완전히 실행 완료된 상태다. B 서버는 SELECT 쿼리 분산용으로, C 서버는 배치나 통계용으로 사용되고 있었다. 레플리카 서버 C는 조금 지연이 발생해서 소스 서버의 "binary-log.000002:120" 위치까지만 복제가 동기화된 상태였다. 

그런데 이때 소스 서버인 A가 장애가 발생하면서 서버가 비정상적으로 종료됐다고 가정해보자. 그러면 레플리카 서버 B와 C 중에서 하나를 소스 서버로 승격하고, A 서버로 연결돼 있던 라이언트 커넥션을 새로 승격된 소스 서버로 교체하고자 할 것이다. 이때 당연히 완전히 동기화돼 있는 레플리카 서버 B를 소스 서버로 승격할 것이다. 이제 복제는 모두 끊어지고, **B 서버로 사용자 트래픽이 유입**되고 있다. 그러나 C 서버는 여전히 동기화되지 않은 상태여서 서비스에서 SELECT 용도로 사용할 수가 없는 상태다. **B 서버가 새로운 소스 서버로 승격되면서 클라이언트의 쿼리 요청이 B 서버로 들어오기 시작하는데, 이미 B 서버는 SELECT 쿼리의 부하 분산용이었기 때문에 분산 SELECT 쿼리 처리와 더불어 기존 소스 서버의 역할까지 겹치면서 과부하 상태**가 될 것이다. 그러면 기존 B 서버의 SELECT 쿼리를 C 서버로 옮겨서 실행하면 될 것이다. 하지만 안타깝게도 C 서버는 동기화가 되지 않은 상태에서 A 서버가 종료돼 버렸으므로 복제를 최종 시점까지 **동기화할 방법이 없다.**

![](https://velog.velcdn.com/images/chocochip/post/24fbc6df-aaf8-4172-b0c2-fd458016676a/image.png)


물론 완전히 불가능한 것은 아니다. 레플리카 서버 B의 릴레이 로그가 지워지지 않고 남아있었다면(릴 레이 로그에는 소스 서버의 바이너리 로그 위치가 함께 기록돼 있으므로) B 서버의 릴레이 로그를 가져와서 필요한 부분만 실행하면 복구가 가능하다. 하지만 **일반적으로 MySQL 서버의 릴레이 로그는 불필요한 시점에 자동으로 삭제**되므로 이 방법은 상당히 제한적이라고 볼 수 있다. 또한 수동으로 직접 확인해보는 방법도 있을 수 있다. 그런데 이게 말처럼 그렇게 간단한 문제가 아닐뿐더러 자동화는 더 어렵다.


![](https://velog.velcdn.com/images/chocochip/post/a5784d3e-c7ee-43b1-9d4a-6b8049278327/image.png)



그럼 GTID로 복제가 되는 상황을 한번 고려해보자. 글로벌 트랜잭션 아이디를 이용해 복제가 구성돼 있으며, 소스 서버의 현재 GTID는 "af995d89-939e-11eb-bb37-ba122a9a8ae3:120"이고, 레플리카 서버 B는 "af995d80-939e-11eb-bt37-ba122a9a8ae3:129"까지 완전히 동기화된 상태이며, 레플리카 서버 C는 "af995d80-939e-11eb-bb37-ba122a9a8ae3:98" GTID까지만 동기화된 상태다. 

이 상태에서 소스 서버인 A에 장애가 발생하면 B 서버를 C 서버의 소스 서버가 되도록 C 서버에서 "CHANGE REPLICATION SOURCE TO SOURCE_HOST='B', SOURCE_PORT=3306;" 명령을 실행한다. 이때 B 서버의 바이너리 로그 파일명이 무엇인지, 그리고 바이너리 로그 파일에서 어느 위치부터 이벤트를 가져와야 하는지 입력할 필요가 없다. A 서버에서 GTID가 "af995d80-9399e-11eb-bb37 ba122a9a8ae3:98"이었던 트랜잭션은 B 서버에서도 "af995d80-939e-11eb-tb37-ba122a9a8ae3:98"이며, C 서버에서도 "af995d80-939e-11eb-blp37-ba122a9a8ae3:98"이기 때문이다. 그래서 C 서버는 현재 "af995d80-939e-11eb-bb37-ba122a9a8ae3:98" 트랜잭션까지 실행했으므로 B 서버로 복제를 다시 연결할 때도 B 서버에서 "af995d80-939e-11eb-bb37-ba122a9a8ae3:98" 이후의 바이너리 로그 이벤트를 가져와서 동기화하면 되기 때문이다.


![](https://velog.velcdn.com/images/chocochip/post/1705f985-2fe4-42ec-8d53-7ed70ee1d1c2/image.png)
이렇게 레플리카 서버 C가 새로운 소스 서버인 B와 동기화할 수 있도록 준비되면 이제 클라이언트의 요청을 B 서버와 C서버로 나눠서 실행할 수 있게 하면된다.

사실 GTID의 개념은 기대했던 것보다 훨씬 단순하고 딱히 특별한 것 없이 보일 수도 있다. 하지만 **트랜잭션의 아이디를 글로벌하게 확장함으로써 복제 토폴로지 변경 시 동기화에 대한 문제가 아주 간단히 해결**돼 버렸다. 이런 단순함은 꼭 장애에 대응할 때만 활용할 수 있는 것은 아니다. MySQL 서버를 운영하다 보면 데이터베이스에 레플리카 서버 확장이나 축소 또는 통합과 같은 여러 요건들이 있을 수 있다. 이럴 때마다 복제 동기화 때문에 항상 관리자는 머리를 싸매야 하는데, 이러한 문제들도 함께 해 결될 수 있을 것이다.

### GTID
바이너리 로그 파일에 기록된 이벤트들을 바이너리 로그 파일명과 파일 내의 위치로 식별하는 것은 물리적인 방식이라고 할 수 있다. 반면 **GTID는 논리적인 의미로서 물리적인 파일의 이름이나 위치와는 전혀 무관하게 생성**된다. MySQL의 **GTID는 서버에서 커밋된 각 트랜잭션과 연결된 고유 식별자로, 해당 트랜잭션이 발생한 서버에서 고유할뿐만 아니라 그 서버가 속한 복제 토폴로지 내 모든 서버에서 고유**하다. GTID는 커밋되어 바이너리 로그에 기록된 트랜잭션에 한해서만 할당되며, **데이터 읽기만 수행하는 SELECT 쿼리나 혹은 sql_log_bin 설정이 비활성화돼 있는 상태에서 발생한 트랜잭션은 바이너리에 기록되지 않으므로 GTID가 할당**되지 않는다. GTID는 소스 아이디와 트랜잭션 아이디 값의 조합으로 생성되는데, 두 값은 다음과 같이 콜론 문자(:) 로 구분되어 표시된다.

```bash
GTID = [source_id]:[transaction_i]
```

소스 아이디는 트랜잭션이 발생된 **소스 서버를 식별**하기 위한 값으로, MySQL 서버의 server_uuid 시스템 변수 값을 사용한다. 트랜잭션 아이디는 서버에서 커밋된 트랜잭션 순서대로 부여되는 값으로 1부터 1씩 단조 증가하는 형태로 발급된다. server_uuid는 사용자가 별도로 설정하는 것이 아니라 MySQL 서버가 시작되면서 자동으로 부여되며, MySQL 서버를 시작할 때 데이터 디렉터리에 autocnf라는 파일이 생성되는데 그 안에 server_uuid 값이 저장돼 있다. auto.cnf 파일을 열어보면 `[auto]` 라는 섹션이 있으며, 그 하위에 현재 서버의 UUID 값이 표기돼 있다. auto.cnf 파일은 삭제되더라도 MySQL 서버를 재시작할 때 자동으로 다시 생성되며, 이미 생성돼 있는 auto.cnf 파일을 가져다가 사용할 수도 있다. auto.cnf 파일이 자동으로 생성된다고 하더라도 auto.cnf 파일에 저장돼 있는 UUID 값은 복제가 설정된 소스 서버와 레플리카 서버의 GTID 값에 사용되고 있는 값이므로 삭제되지 않도록 주의하자. 

MySQL의 엔터프라이즈 백업이나 Percona의 XtraBackup을 이용해서 백업해둔 소스 서버의 데이터 파일을 새로운 레플리카 서버 구축에 그대로 사용한다면 실수로 auto.cnf 파일까지 그대로 사용할 수 있다. 이 경우 레플리카 서버에서 복제 연결 시 에러가 발생할 수 있는데, 이때는 복제를 멈추고 MySQL을 종료한 뒤 auto.cnf 파일을 삭제한 후 다시 MySQL을 시작하면 새로운 UUID 값이 생성되므로 복제 재개 시 문제없이 다시 연결할 수 있다. 

### GTID 확인하기
현재 사용되고 있는 GTID 값을 확인하는 방법에는 여러 가지가 있는데, mysql 데이터베이스 내의 gtid_executed 테이블을 조회하거나 gtid_executed 시스템 변수를 통해 확인할 수 있다. 또한 SHOW MASTER STATUS 명령을 통해 GTID와 이에 상응하는 바이너리 로그 파일 및 위치 값을 같이 확인할 수도 있다.

### GTID Sets
GTID는 각각의 값이 하나씩 개별로 보여지거나 연속된 값들인 경우 범위로 보여질 수 있으며, 이 밖에도 다양한 형태로 값이 보여질 수 있다. 이렇게 **하나 이상의 GTID 값으로 구성돼 있는 것을 GTID 셋(GTID Sets)** 이라 한다. GTID 셋에서는 기본적으로 동일한 서버에서 생성된 연속하는 GTID 값은 축소시켜 범위로 보여지며, 범위 값과 단일 값이 하나의 표현식으로 나타날 수도 있다. 이 경우 범위 값과 단일 값은 콜론(:)으로 구분되어 표기된다. 

또한 GTID 셋에는 서로 다른 UUID를 가지는 GTID 값들도 포함될 수 있는데, 동일한 MySQL 서버에서 서버의 UUID 값이 기존과는 다른 값으로 변경됐거나 혹은 여러 서버에서 데이터를 복제해오는 경우 등이 이에 해당한다. 서로 다른 UUID를 가지는 각각의 GTID는 콤마(,)로 구분되어 표시된다.

앞서 언급했던 `mysql.gtid_executed` 테이블은 단순히 현재 실행된 GTID 값을 저장하는 것 이외에 MySQL 서버 내부적으로 중요한 역할을 하는데, 레플리카 서버에서 바이너리 로그가 비활성화돼 있는 상태에서 GTID 기반의 복제를 사용할 수 있게 하고, 예기치 못한 문제로 바이너리 로그가 손실됐을 때 GTID 값이 보존될 수 있게 한다. `mysql.gtid_executed` 테이블은 MySQL 5.7.5 버전에서 처음 도입됐으며 InnoDB 스토리지 엔진으로 설정돼 있다. MySQL 8.0.17 이상의 버전을 사용하는 경우에는 매 트랜잭션이 커밋될 때마다 `mysql.gtid_executed` 테이블에도 GTID 값이 바로 저장된다. 만약 MySQL 버전이 8.0.17 미만이거나 InnoDB가 아닌 다른 스토리지 엔진을 사용하는 경우 GTID 값은 바이너리 로그 파일이 로테이 션되거나 MySQL 서버가 종료될 때만 `mysql.gtid_executed` 테이블에 저장된다. 이렇게 `mysql.gtid_executed` 테이블에 매 트랜잭션이 커밋될 때가 아닌 특정한 시점에만 GTID 값이 저장되는 경우 `mysql.gtid_executed` 테이블에 최근까지 사용된 GTID 값이 반영되지 않으므로 마지막에 실행된 트랜잭션의 GTID 값을 조회할 때는 gtid_executed 시스템 변수 값을 확인해야 한다. `mysql.gtid_executed` 테이블에는 실행된 모든 트랜잭션들에 대해 GTID 값이 저장되므로 시간이 지남에 따라 많은 데이터가 쌓일 수 있다.


### GTID 압축
굳이 이 같은 방식으로 그동안 실행됐던 GTID들을 보존할 필요가 없기도 하고 불필요하게 디스크 공간만 차지하게 되므로 MySQL 서버는 주기적으로 `mysql.gtid_executed` 테이블에 대해 쌓여있는 전체 데이터를 하나의 데이터로 압축한다. 여기서 '압축'은 테이블의 데이터 파일을 압축하는 것이 아니라 `mysql.gtid_executed` 테이블에 여러 레코드로 저장된 interval_start와 interval_end를 연속된 것들끼리 모아서 1건의 레코드로 만드는 것을 의미한다.

```sql
mysql> SELECT * FROM mysql.gtid_executed; 
|source_uuid |interval_start |interval_end |
|ed22da00-e052-11ea-ae88-ee4baf89a396 | 87 | 99 |
```
mysql.gtid_executed 테이블에 대한 압축은 바이너리 로그 활성화 여부에 따라 압축을 수행하는 조건이 달라지는데, 바이너리 로그가 활성화돼 있는 경우 바이너리 로그 파일이 로테이션될 때 자동으로 압축이 수행된다. 바이너리 로그가 활성화돼 있지 않은 경우에는 "thread/sql/compress_gtid_table" 이라는 별도의 포그라운드 스레드에 의해 수행되는데, MySQL 서버에서 실행된 트랜잭션 수가 `gtid_executed_compression_period` 시스템 변수에 지정된 수까지 도달하면 스레드에서 압축을 수행하고, 그 후 다시 다 음 주기가 돌아올 때까지 슬립 모드를 유지한다. `gtid_executed_compression_period` 시스템 변수 값이 0 으로 설정되면 스레드는 계속 슬립 모드 상태를 유지되고 압축을 수행하지 않으며, 압축은 필요에 따라 자동으로 실행된다. 

### GTID 를 사용하고 있는 소스 서버에 글로벌 트랜잭션 아이디 기반의 복제 구축 
**MySQL 서버에서 GTID를 활성화하는 것과 GTID 기반의 복제를 사용하는 것은 별개**이며, GTID 활성화는 GTID 복제를 위한 하나의 조건이다. 즉 MySQL 서버의 GTID는 활성화돼 있다 하더라도 복제는 바이너리 로그 파일 위치 기반의 복제를 사용할 수도 있다. 그래서 소스 서버에서 GTID가 활성화 돼 있지 않다면 레플리카 서버를 구축하기에 앞서 소스 서버의 GTID를 활성화하는 과정이 필요하다. 물론 MySQL 서버에서 GTID가 비활성화돼 있다 하더라도 MySQL 서버의 재시작(서비스 중단) 없이 GTID를 활성화해서 GTID 기반의 복제를 적용할 수 있다. 여기서는 기존에 이미 GTID 를 사용하고 있는 소스 서버에 레플리카 서버를 GTID 기반 복제로 연결하는 과정을 살펴보겠다.

#### 설정 준비
GTID 기반의 복제를 사용하려면 복제에 참여하는 모든 MySQL 서버들이 GTID가 활성화돼 있어야하며, 각 서버의 server_id 및 server_uuid가 복제 그룹 내에서 고유해야 한다. 
```bash
# 소스 서버 설정 
[mysqld] 
gtid_mode=ON 
enforce_gtid_consistency=0 
server_id=111 
log_bin=/binary-log-dir-path/asnary-log-name 

# 레플리카 서버 설정 
[mysqld] 
gtid_mode=ON 
enforce_gtid_consistency=O 
server_id=222 
relay_log=/relay-log-dir-path/relay-log-name
relay_log_purge=ON 
read_only 
log_slave_updates
 ```
 설정 파일에는 반드시 "gtid_mode=ON"과 "enforce_gtid_consistency=ON"을 함께 명시해야 한다. 만약 gtid_mode만 ON으로 설정되고 enforce_gtid_consistency가 설정되지 않으면 다음과 같은 에러가 발생하 면서 MySQL 서버는 기동하지 않는다.
 ```bash
 2020-08-23T04:156:05.966219Z 0 [ERROR] [MY-010912] [Server] GTID_MODE = ON requires ENFORCE_ GTID_CONSISTENCY = ON. 2020-08-23T04:155:05.966590Z 0 [ERROR] [MY-010119] [Server] Aborting
```
#### 복제 계정 준비
복제에서 사용할 계정을 준비한다. 계정을 생성하기 위해 소스 서버에 다음 명령문을 실행한다. 

```sql
CREATE USER 'repl_user'@'%' IDENTIFIED BY 'repl_user_password'; 
GRANT REPLICATION SLAVE ON *.* TO 'repl_user'@'%';
```
#### 데이터 복사 
일반적으로 많이 사용되는 mysqldump를 사용해 소스 서버의 데이터를 덤프해서 레플리카 서버에 적재한다. 데이터 덤프를 위해 소스 서버에서 아래 mysqldump 명령을 실행한다.
```bash
linux> mysqldump -uroot -p --single-transaction --master-data=2 --set-gtid-purged=ON --opt --routines --triggers --hex-blob --all-databases > source_data.sql 
```

MySQL 서버는 GTID 복제와 관련해서 대표적으로 다음과 같이 2개의 시스템 변수를 가진다. GTID 가 활성화된 소스 서버에서 mysqldump로 데이터를 덤프받아 레플리카 서버를 구축하려는 경우, 덤프가 시작된 시점의 소스 서버 GTID 값을 레플리카 서버에서 다음 2개의 시스템 변수에 설정해야 복제를 시작할 수 있다. 

- gtid_executed: MySQL 서비에서 실행되어 바이너리 로그 파일에 기록된 모든 트랜잭션들의 GTID 셋을 나타낸다. 
- gtid_purged: 현재 MySQL 서버의 바이너리 로그 파일에 존재하지 않는 모든 트랜잭션들의 GTID 셋을 나타낸다. 

GTID 기반 복제에서 레플리카 서버는 gtid_executed 값을 기반으로 다음 복제 이벤트를 소스 서버로부터 가져온다. gtid_executed는 읽기 전용 변수로 사용자가 변경할 수 없으며, 사용자는 gtid_purged 변수 값만 수정할 수 있다. MySQL을 설치하고 처음 구동시키면 위 두 값은 비어있는데, 이때 사용자가 gtid_purged에 값을 설정하면 gtid_executed에도 자동으로 동일한 값이 설정된다. 따라서 복제를 시작하기 위해서는 소스 서버에서 데이터 덤프가 시작된 시점의 소스 서버의 GTID 값을 레플리카 서버의 gtid_purged 시스템 변수에 지정해 gtid_executed 시스템 변수에도 그 값이 설정되게 해야 한다. 

> gtid_purged와 gtid_executed 시스템 변수를 동일한 값으로 변경하려면 반드시 두 시스템 변수의 값이 비 어 있어야 한다. 만약 이미 값이 저장된 경우에는 RESET MASTER 명령을 실행해 두 변수의 값을 초기화한 후 gtid_ purged에 값을 설정하면 된다. 단 RESET MASTER 명령을 실행하면 그 서버가 가지고 있던 바이너리 로그 파일들이 모두 삭제되므로 바이너리 로그 파일이 필요한지 고려한 후 실행하는 것이 좋다. 
 
이를 위해 mysqldump에서는 --set-gtid-purged라는 옵션을 제공하며, 이 옵션이 활성화되면 덤프가 시 작된 시점의 GTID가 덤프 파일에 기록된다. 또한 sql_log_bin 시스템 변수를 비활성화하는 구문도 함 꼐 기록되는데. 이는 덤프 파일을 실행할 때 적용되는 트랜잭션들이 레플리카 서버에서 새로운 GTID 를 발급받는 것을 방지한다. 즉 레플리카 서버에서 덤프 파일을 적재하는 작업이 바이너리 로그에 기록 되지 않으므로 GTID가 생성되지 않는 것이다. --set-gtid-purged 옵션에는 다음과 같은 값들을 지정할 수 있으며, 사용자가 mysqldump를 실행할 때 명시적으로 이 옵션을 적지 않더라도 --set-gtid-purged 션은 AUTO 값으로 설정되어 동작한다.

- AUTO: 덤프를 받는 서버에서 GTID가 활성화돼 있으면 덤프를 시작하는 시점의 GTID 값 및 sql_log bin 비활성화 구문을 덤프 파일에 기록하며, 만약 GTID가 비활성상태인 서버의 경우 해당 내용들을 기록하지 않는다.

- OFF: 덤프 시작 시점의 GTID 값 및 `sql_log_bin` 비활성화 구문을 덤프 파일에 기록하지 않는다. 
- ON: 덤프 시작 시점의 GTID 값 및 sql_log_bin 비활성화 구문을 덤프 파일에 기록한다. 만약 GTID가 활성화돼 있 지 않은 서버에서 이 옵션값을 사용하는 경우 에러가 발생한다. 
- COMMENTED: MySQL 8.0.17 이상 버전부터 사용할 수 있는 값으로, 이 값이 설정되면 ON 값으로 설정됐을 때와 동일하게 동작 하되, 덤프 시작 시점의 GTID 값이 주석으로 처리되어 기록된다. 

`sql_log_bin` 비활성화 구문은 주석으로 처리 되지 않고 다른 경우와 동일하게 바로 적용 가능한 형태로 기록된다. 참고 만약 레플리카 서버 구축을 위해서가 아니라 단순히 다른 DB 서버로의 데이터 마이그레이션을 위해 mysqldump 를 사용하는 경우에는 mysqldump 실행 시 "--set-gtid-purged=OFF" 옵션을 명시하여 `sql_log_bin` 시스템 변수 를 비활성화하는 구문이 덤프 파일에 기록되지 않도록 해야 한다. 그렇지 않으면 데이터를 마이그레이션할 DB 서버에 서 덤프 파일 적용 시 `sql_log_bin` 시스템 변수를 비활성화하는 구문으로 인해 적재한 데이터가 바이너리 로그에 기 록되지 않아, 해당 DB 서버와 연결된 레플리카 서버에 데이터가 복제되지 않을 수 있기 때문이다. 위의 mysqldump 명령에 주어진 "--set-gtid-purged=ON" 옵션으로 인해 덤프된 파일의 최상단에는 다음 과 같은 내용이 기록된다. gtid_purged 시스템 변수 값을 지정하는 SET 명령에서 `+` 기호는 현재 gtid_ purged 시스템 변수에 설정돼 있는 값에 새로운 값을 덧붙이는 것을 의미한다. 


mysqldump로 백업받은 데이터 파일을 레플리카 서버로 옮겨 적재하면 레플리카 서버에서 gtid_executed 와 gtid_purged 시스템 변수 값이 자동으로 설정된다.

소스 서버에서 XtraBackup 툴을 사용해 데이터를 백업받아 레플리카 서버에 복구하는 경우 복구한 데 이터 디렉터리에 xtrabackup_binlog_info라는 파일이 생성된다. 이 파일에는 다음과 같이 백업이 완료 된 시점의 바이너리 로그 파일명과 위치, GTID 값이 함께 기록돼 있다. 

```bash
linux> cat xtrabackup_binlog_info mysql-bin.00003 8886 ed22da00-e052-11ea-ae88-ee4baf89a396:1-30
```
XtraBackup이나 MySQL 엔터프라이즈 백업 도구를 이용해 백업하거나 복구할 때는 mysql.gtid_ executed 테이블과 데이터까지 복구된다. 따라서 백업 복구가 완료되어 MySQL 서버가 시작되면 MySQL 서버는 자동으로 mysgl.gtid_executed 테이블의 GTID 값을 바탕으로 gtid_executed와 gtid_ purged 시스템 변수를 초기화한다. 또한 mysql.gtid_executed 테이블의 GTID 값은 xtrabackup_binlog_ info 파일에 표시되는 값과 동일한 GTID 값을 가진다. 

#### 복제 시작 
레플리카 서버의 초기 데이터가 모두 준비됐다. 하지만 레플리카 서버에 복구된 데이터는 소스 서버에서 백업을 실행했던 과거 시점의 데이터이며, **백업 시점 이후에 새롭게 변경된 데이터는 레플리카 서버 에 적용돼 있지 않은 상태이고, 아직 실시간으로 변경되는 데이터도 레플리카 서버로 복제되지 않는다**. 다음 명령은 소스 서버와 레플리카 서버 간의 복제를 시작하는 명령으로, 이 명령이 실행되면 레플리카 서버는 소스 서버에서 백업 시점부터 지금까지 변경된 데이터와 이후 변경될 데이터를 실시간으로 가져와 적용하게 된다. 

```sql
CHANGE REPLICATION SOURCE TO SOURCE_HOST=' source_server_host' SOURCE_PORT=3306, SOURCE_USER='repl_user' SOURCE_PASSWORD='reepl_user_password' SOURCE_AUTO_POSITION=1, GET_SOURCE_PUBLIC_KEY=1;
```
바이너리 로그 파일 위치 기반 복제와 다른 점은 CHANGE REPLICATION SOURCE 명령에 SOURCE_LOG_FILE과 SOURCE_LOG_POS 옵션이 아닌 SOURCE_AUTO_POSITION 옵션이 들어가 있다는 점인데, 이 옵션으로 인해 레플리카 서버는 자신의 gtid_executed 값을 참조해 해당 시점부터 소스 서버와 복제를 연결해서 데이터 를 동기화하게 된다. 

### 글로벌 트랜잭션 아이디 기반 복제에서 트랜잭션 건너뛰기 
레플리카 서버에서 소스 서버로부터 넘어온 트랜잭션이 제대로 실행되지 못하고 에러가 발생해 복제 가 멈췄을 때 바이너리 로그 위치 기반 복제에서는 sql_slave_skip_counter 시스템 변수를 이용해 문제 되는 이벤트 그룹만 건너뛰게 해서 다시 복제가 정상적으로 재개되도록 할 수 있었다. 하지만 GTID를 사용하는 복제 환경의 레플리카 서버에서는 더이상 sql_slave_skip_counter 시스템 변수를 사용할 수가 없다. GTID 기반 복제에서 레플리카 서버는 기본적으로 자신의 GTID 값과 소스 서버의 GTID 값을 비교 해서 소스 서버의 변경 이벤트를 가져온다. 그렇기 때문에 레플리카 서버가 소스 서버의 GTID 값보다 더 적거나 더 많은 GTID 값을 가진 채로 복제를 계속 유지시킬 수는 없다. 따라서 만약 레플리카 서버 에서 소스 서버로부터 넘어온 트랜잭션을 무시하고 싶다면 레플리카 서버에서 수동으로 빈 트랜잭션 (Empty Transaction 또는 Dummy Transaction이라고 함)을 생성해 GTID 값을 만들어야 한다.

GTID 기반의 복제가 설정된 레플리카 서버에서 다음과 같이 중복된 키로 인해 INSERT 쿼리가 실패한 상태로 복제가 멈춰져 있다고 가정해보자. SHOW REPLICA STATUS 결과에서 마지막의 Auto_Position 칼럼의 값이 1인 것으로 봐서 현재 복제는 GTID 기반으로 연결돼 있다는 것을 알 수 있다. 또한 복제는 중복 키 에러로 인해 현재 SQL 스레드가 멈춰 있으며, 하단의 Retrieved_Gtid_Set 칼럼의 값과 Executed_Gtid_Set 칼럼의 값을 통해 레플리카 서 버가 소스 서버로부터 "af995d80-939e-11eb-bb357-ba122a9a8ae3:3-7" GTID 셋(Set)을 가져왔고, 레플리 카 서버에서 실행된 GTID 셋은 "1-6"(1 번부터 6번까지)이라는 것을 알 수 있다.

여기서 "af995d80-939e-11eb-bb37-ba122a9a8ae3:7* 트랜잭션을 소스 서버에서 가져오긴 했지만 실제 실 행을 하지 못하고 에러가 난 상태라는 것을 확인할 수 있다. 이때 에러가 발생한 "af995d80-939e-11eb bb37-ba122a9a8ae3:7" 트랜잭션을 레플리카 서버에서 무시하려면 다음과 같이 복제를 멈추고 빈 트랜잭 션을 강제로 만들어서 바이너리 로그 스트림에 밀어넣으면 된다.

### Non-GTID 기반 복제에서 GTID 기반 복제로 온라인 변경 
MySQL 8.0에서는 서비스가 현재 동작하고 있는 상태에서 MySQL 서버가 GTID를 사용하도록 혹은 사용하지 않도록 GTID 모드를 온라인으로 전환할 수 있는 기능을 제공한다. 이 기능을 통해 **기존에 바이너리 로그 위치 기반의 복제를 GTID 기반의 복제로 변경할 수 있으며, 그 반대의 경우도 가능**하다. GTID 모드를 전환하는 작업은 간단하게 **GTID와 관련된 두 시스템 변수의 값만 순차적으로 변경**하면 되는데, 먼저 이 두 시스템 변수에 대해 자세히 알아보고 GTID를 사용하지 않는 모드에서 사용하는 모드로 변경하는 예시를 살펴보겠다. 

#### enforce_gtid_consistency 시스템 변수
GTID 모드를 전환할 때 사용되는 시스템 변수는 enforce.gtid_consistency와 gtid_mode로, 이 두 변수 모두 MySQL 서버를 재시작하는 과정 없이 동적으로 값 변경이 가능하다. 각 변수가 의미하는 바와 각 변수에 어떤 값들을 지정할 수 있는지 살펴보자. 

enforce_gtid_consistency는 GTID 기반의 복제에서 소스 서버와 레플리카 서버 간의 데이터 일관성을 해칠 수 있는 쿼리들이 MySQL 서버에서 실행되는 것을 허용할지를 제어하는 시스템 변수다. GTID를 사용하는 복제 환경에서는 다음과 같은 패턴의 쿼리들은 안전하지 않다.

- 트랜잭션을 지원하는 테이블과 지원하지 않는 테이블을 함께 변경하는 쿼리 혹은 트랜잭션 
- CREATE TABLE SELECT ... 구문 
- 트랜잭션 내에서 CREATE TEMPORARY TABLE, DROP TEMPORARY TABLE 구문 사용 

위 쿼리 패턴들의 공통적인 특징은 소스 서버에서 레플리카 서버로 복제되어 적용될 때 단일 트랜잭션 으로 처리되지 않을 수도 있다는 점이다. 이러한 점이 GTID 기반의 복제에서 문제가 되는 이유는 바로 GTID가 트랜잭션 단위로 올바르게 할당돼야 복제가 정상적으로 동작하기 때문이다. 만약 소스 서버 에서 단일 트랜잭션으로 처리된 쿼리들이 바이너리 로그에 기록되고 레플리카 서버로 복제되는 과정에 서 하나의 트랜잭션이 아닌 개별적인 이벤트로 분류되고 각각에 대해 GTID가 할당되면, 레플리카 서 버에서 해당 트랜잭션이 원자적으로 처리되지 못할 수 있다. 이 같은 가능성으로 인해 GTID 기반의 복 제에서는 위와 같은 패턴의 쿼리들이 문제가 될 수 있으며, 사용자는 enforce_gtid_consistency 설정을 통해 이러한 쿼리들의 실행 가능 여부를 제어할 수 있다. 

MySQL 8.0에서는 GTID를 사용하는 복제 환경에서 안전하지 않았던 일부 쿼리들이 안전하게 처리되도록 개선됐다. MySQL 8.0.13 버전부터는 서버의 바이너리 로그 포맷(binlog_format)이 ROW 또는 MIXED로 설정된 경우 트랜 잭션 내에서 CREATE TEMPORARY TABLE 및 DROP TEMPORARY TABLE 구문을 사용할 수 있다. 또한 MySQL 8.0.21 버 전부터는 Atomic DDL 기능을 지원하는 InnoDB 스토리지 엔진 테이블에 한해 CREATE TABLE SELECT 구문을 사용할 수 있게 됐다.

사용자가 enforce_gtid_consistency 시스템 변수에 지정할 수 있는 값은 다음과 같다. GTID가 활성화 된 경우에는 enforce_gtid_consistency는 반드시 ON 으로 설정돼야 한다. 

#### gtid_mode 시스템 변수
gtid_mode는 바이너리 로그에 트랜잭션들이 GTID 기반으로 로깅될 수 있는지 여부와 트랜잭션 유형별로 MySQL 서버에서의 처리 가능 여부를 제어한 다. 바이너리 로그에 기록되는 트랜잭션 유형에는 익명(Anonymous) 트랜잭션과 GTID 트랜잭션이 있는데, 익명 트랜잭션은 GTID가 부여되지 않은 트랜잭션으로 바이너리 로그 파일명과 위치로 식별되 며, GTID 트랜잭션은 고유한 식별값인 GTID가 부여된 트랜잭션을 지칭한다. 

사용자가 gtid_mode 시스템 변수에 지정할 수 있는 값은 다음과 같다. gtid_mode에 설정된 값에 따라 MySQL 서버에서 직접 실행된 신규 트랜잭션 및 복제로 넘어온 트랜잭션에 대한 처리 방식이 달라지 므로 각 설정 값별로 두 트랜잭션의 처리가 어떻게 달라지는지 구분해서 적어봤다. 

||신규 트랜잭션|복제된 트랜잭션|
|---|---|---|
|OFF|익명 트랜잭션으로 기록됨|익명 트랜잭션으로 처리 가능|
|OFF_PERMISSIVE|익명 트랜잭션으로 기록됨|익명 트랜잭션 및 GTID 트랜잭션 모두 처리 가능|
|ON_PERMISSIVE|GTID 트랜잭션으로 기록됨|익명 트랜잭션 및 GTID 트랜잭션 모두 처리 가능|
|ON|GTID 트랜잭션으로 기록됨|GTID 트랜잭션 모두 처리 가능|

gtid_mode는 위 표에 적혀진 값 순서를 기준으로 한 번에 한 단계씩만 변경할 수 있다. 예를 들어, gtid_mode가 현재 OFF_PERMISSIVE로 설정돼 있는 경우 OFF 또는 ON_PERMISSIVE로 변경할 수는 있지만 ON 으로는 변경할 수 없다. 

복제 그룹 내에서 소스 서버와 레플리카 서버의 gtid_mode를 변경하는 경우 서버별로 순차적으로 값 변 경이 이뤄지므로 최초에는 소스 서버와 레플리카 서버가 동일한 gtid_mode 값을 가지고 있다고 하더라 도 변경 작업을 진행할 때 기존의 설정 값으로 동작하는 서버와 새로운 설정 값으로 동작하는 서버가 동시점에 존재할 수 있다. 앞에서 언급한 것처럼 각 설정 값별로 MySQL 서버가 동작하는 방식이 달라지므로 값을 변경하기 전에 서로 다른 값으로 설정된 MySQL 서버 사이의 호환성 여부를 한번 확인해 보는 것이 좋다.

- O: 복제 가능
- X: 복제 불가능 
- A: 복제 설정 시 자동 포지션 옵션 사용 가능

|레플리카\소스|OFF|OFF_PERMISSIVE|ON_PERMISSIVE|ON|
|---|---|---|---|---|
|OFF|O|O|X|X|
|OFF_PERMISSIVE|O|O|O|O + A|
|ON_PERMISSIVE|O|O|O|O + A|
|ON|X|X|O|O + A|


이제 복제 그룹 내 MySQL 서버들의 GTID 모드를 변경하는 과정을 살펴보자. 먼저 Non-GTID 기반 으로 복제가 구성돼 있는 소스 서버와 레플리카 서버가 있고, 이 서버들의 GTID를 활성화한 뒤 GTID 기반의 복제로 변경한다고 가정해보자. 이때 소스 서버와 레플리카 서버는 MySQL 5.7.6 이상의 버전 을 사용하고 있다. 전환 작업은 다음과 같은 순서로 진행된다. 

1. 각 서버에서 enforce_gtid_consistency 시스템 변수 값을 WARN으로 변경 
```sql
mysql> SET GLOBAL enforce_gtidl_consistency = WARN ; 
```
설정을 변경한 후에는 일정 시간 동안 서버의 동작을 모니터링하며, MySQL 서버의 에러 로그에 경고성 로그가 출 력되지는 않는지 살펴봐야 한다. enforce_gtid_consistenc 설정이 WARN인 경우 GTID 사용 시 일관성을 해치는 트랜잭션들을 감지해 에러 로그에 경고 메시지를 남긴다. 그러므로 사용자는 반드시 일정 시간 동안 에러 로그에 이 같은 경고 메시지가 출력되는지 모니터링해야 하며, 만약 경고 메시지가 발생했다면 이를 확인해 애플리케이션을' 수정해야 한다. 애플리케이션을 수정한 후 더이상 경고 메시지가 출력되지 않음을 확인한 뒤에 다음 단계로 넘어가 야 한다.


