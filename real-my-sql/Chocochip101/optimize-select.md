
OLTP 환경의 데이터베이스에서의 SELECT는 여러 개의 테이블로부터 데이터를 조합해서 빠르게 가져와야 하기 때문에 여러 개의 테이블을 어떻게 읽을 것인가에 많은 주의를 기울여야 한다. 하나의 애플리케이션에서 사용되는 쿼리 중에서도 SELECT 쿼리의 비율은 높다.

# SELECT 절의 처리 순서 

```sql
SELECT s.emp_no, COUNT(DISTINCT e.first_name) AS cnt 
FROM salaries s 
	INNER JOIN employees e ON e.emp_no=s.emp_no 
WHERE s.emp_no IN (100001, 100002) 
GROUP BY s.emp_no 
HAVING AVG(s.salary) > 1000 
ORDER BY AVG(s.salary) LIMIT 10; 
```
이 쿼리 예제를 각 절로 나눠보면 다음과 같다. 

- SELECT 절: SELECT s.emp_no, COUNT(DISTINCT e.first_name) AS cnt 
- FROM 절: FROM salaries s INNER JOIN employees e ON e.emp_no=s.emp_no 
- WHERE 절: WHERE s.emp_no IN (100001, 100002) 
- GROUP BY 절: GROUP BY s.emp_no 
- HAVING 절: HAVING AVG(s.salary) > 1000
- ORDER BY 절: ORDER BY AVG(s.salary) 
- LIMIT 절: LIMIT 10 

위의 예제 쿼리는 SELECT 문장에 지정할 수 있는 대부분의 절이 포함돼 있다. 가끔 이런 쿼리에서 어느 절이 먼저 실행될지 예측하지 못할 때가 있는데, 어느 절이 먼저 실행되는지를 모르면 처리 내용이나 처리 결과를 예측할 수 없다.

![](https://velog.velcdn.com/images/chocochip/post/38f34393-8efa-45a5-aad5-86184f6f2ad6/image.png)

위 그림에서 각 요소가 없는 경우는 가능하지만, 이 순서가 바뀌어서 실행되는 형태의 퀴리는 거의 없다. 또한 SQL에는 ORDER BY나 GROUP BY 절이 있더라도 인덱스를 이용해 처리할 때는 그 단계 자체가 불필요하므로 생략된다. 

![](https://velog.velcdn.com/images/chocochip/post/c9fcf10d-c4b0-49f4-b30a-af2f824e24ce/image.png)

**ORDER BY가 사용된 쿼리**에서 예외적인 순서로 실행되는 경우를 보여준다. 이 경우는 첫 번째 테이블만 읽어서 정렬을 수행한 뒤에 나머지 테이블을 읽는데, 주로 GROUP BY 절이 없이 ORDER BY만 사용된 퀴리에서 사용될 수 있는 순서다. **위 두가지 예시에서 소개한 실행 순서를 벗어나는 쿼리가 필요하다면 서브퀴리로 작성된 인라인 뷰(Inline View)를 사용해야 한다.** 예를 들어, 위의 쿼리에서 LIMIT을 먼저 적용하고 ORDER BY를 실행하고자 한다면 다음과 같이 인라인 뷰를 사용해야 한다.


## WITH
MySQL 8.0에 새로 도입된 WITH 절(CTE, Common Table Expression)은 **항상 제일 먼저 실행되어 임시 테이블로 저장**된다. 그리고 WITH 절로 만들어진 임시 테이블은 단독으로 조회되거나 조인되는 테이블로 활용된다.

# WHERE 절과 GROUP BY 절, ORDER BY 절의 인덱스 사용
WHERE 절의 조건뿐만 아니라 GROUP BY나 ORDER BY 절도 인덱스를 이용해 빠르게 처리할 수 있다는 점은 이미 언급했다. 각 절에서 어떤 요건을 갖췄을 때 인덱스를 이용할 수 있는지 자세히 살펴보겠다.

## 인덱스를 사용하기 위한 기본 규칙 
WHERE 절이나 ORDER BY 또는 GROUP BY가 인덱스를 사용하려면 기본적으로 **인덱스된 칼럼의 값 자체를 변환하지 않고 그대로 사용한다는 조건을 만족해야 한다**. 인덱스는 칼럼의 값을 아무런 변환 없이 B-Tree에 정렬해서 저장한다. WHERE 조건이나 GROUP BY 또는 ORDER BY에서도 원본값을 검색하거나 정렬할 때만 B-Tree에 정렬된 인덱스를 이용한다. 즉, 인덱스는 salary 칼럼으로 만들어져 있는데, WHERE 절과 같이 salary 칼럼을 가공한 후 **다른 상숫값과 비교한다면 이 쿼리는 인덱스를 적절히 이용하지 못하게 된다**.

```sql
mysql> SELECT * FROM salaries WHERE salary*10 > 15000;
```

사실 이 쿼리는 간단히 다음과 같이 변경해서 salary 칼럼의 값을 변경하지 않고 검색하도록 유도할 수 있지만 MySQL 옵티마이저에서는 인덱스를 최적으로 이용할 수 있게 표현식을 변환하지는 못한다. 

```sql
mysql> SELECT * FROM salaries WHERE salary > 15000/10; 
```

이러한 형태는 아주 단순한 예제이며, 복잡한 연산을 수행한다거나 MD5() 함수와 같이 해시 값을 만들어서 비교해야 하는 경우라면 미리 계산된 값을 저장하도록 MySQL의 가상 칼럼(Virtual Column)을 추가하고 그 칼럼에 인덱스를 생성하거나 함수 기반의 인덱스를 사용하면 된다. **결론적으로 인덱스의 칼럼을 변형해서 비교하는 경우(그 변형이 아무리 간단한 연산이라고 하더라도)에는 인덱스를 이용할 수 없게 된다는 점에 주의하자.**

추가로 WHERE 절에 사용되는 비교 조건에서 연산자 양쪽의 두 비교 대상 값은 데이터 타입이 일치해야 한다. 비교되는 두 값의 타입이 문자열 타입(VARCHAR나 CHAR)과 숫자 타입(INTEGER)으로 다를 때 MySQL 옵티마이저가 내부적으로 문자열 타입을 술자 타입으로 변환한 후 비교 작업을 처리한다.

저장하고자하는 값의 타입에 맞춰 칼럼의 타입을 선정하고, **SQL을 작성할 때는 데이터의 타입에 맞춰서 비교 조건을 사용하길 권장**한다. 데이터 타입이 조금이라도 다른 경우 최적화되지 못하는 현상은 MySQL 서버의 버전이 업그레이드된다고 해서 해결될 수 있는 부분이 아니므로 항상 주의하자.

## WHERE 절의 인덱스 사용

### WHERE과 AND
WHERE 조건이 인덱스를 사용하는 방법은 크게 **작업 범위 결정 조건**과 **체크 조건**의 두 가지 방식으로 구분할 수 있다. 두 방식 중 작업 범위 결정 조건은, WHERE 절에서 동등 비교 조건이나 IN으로 구성된 조건에 사용된 칼럼들이 인덱스의 칼럼 구성과 좌측에서부터 비교했을 때 얼마나 일치하는가에 따라 달라진다.

![](https://velog.velcdn.com/images/chocochip/post/1e692a2d-b32d-4d55-b7b8-573f3e2356fa/image.jpg)

위쪽은 4개의 칼럼이 순서대로 결합 인덱스로 생성돼 있는 것을 의미하며, 아래쪽은 SQL의 WHERE 절에 존재하는 조건을 의미한다. 그림에서 "WHERE 조건절의 순서"에 나열된 조건들의 순서는 실제 인덱스의 사용 여부와 무관하다. 즉, WHERE 조건절에 나열된 순서가 인덱스와 다르더라도 MySQL 서버 옵티마이저는 인덱스를 사용할 수 있는 조건들을 뽑아서 최적화를 수행할 수 있다. 그림에서 COL_1과 COL_2는 동등 비교 조건이며 COL_3의 조건이 동등 비교 조건이 아닌 크다 또는 작다와 같은 범위 비교 조건이므로 뒤 칼럼인 COL_4의 조건은 작업 범위 결정 조건으로 사용되지 못하고 체크 조건(점선 표기)으로 사용된다. 이는 WHERE 조건절과 인덱스의 칼럼 순서가 일치하지 않기 때문이 아니라 인덱스 순서상 COL_4의 직전 칼럼인 COL_3가 동등 비교 조건 아니라 범위 비교 조건으로 사용됐기 때문이다.

MySQL 8.0 이전 버전까지는 하나의 인덱스를 구성하는 각 칼럼의 정렬 순서가 혼합되어 사용할 수 없었다. 하지만 MySQL 8.0 버전부터는 인덱스를 구성하는 칼럼별로 정순(오름차순)과 역순(내림차순) 정렬을 혼합해서 생성할 수 있게 개선됐다.

### WHERE과 OR
지금까지 보여준 모든 WHERE 조건은 AND 연산자로 연결되는 경우를 가정한 것이며, **OR 연산자가 있으면 처리 방법이 완전히 바뀐다**. 
```sql
mysql> SELECT 
FROM employees 
WHERE first_name= 'Kebin' OR last_name= 'Poly'; 
```
위의 퀴리에서 first_name= 'Kebin' 조건은 인덱스를 이용할 수 있지만 last_name= 'Poly'는 인덱스를 사용할 수 없다. 이 두 조건이 AND 연산자로 연결됐다면 first_name의 인덱스를 이용하겠지만 OR 연산자로 연결됐기 때문에 **옵티마이저는 풀 테이블 스캔을 선택**할 수밖에 없다. (풀 테이블 스캔) + (인덱스 레인지 스캔)의 작업량보다는 (풀 테이블 스캔) 한 번이 더 빠르기 때문이다. 이 경우 first_name과 last_name 칼럼에 각각 인덱스가 있다면 index_merge 접근 방법으로 실행할 수 있다. 물론 이 방법은 풀 테이블 스캔보다는 빠르지만 여전히 제대로 된 인덱스 하나를 레인지 스캔하는 것보다는 느리다. 

WHERE 절 에서 각 조건이 AND로 연결되면 읽어와야 할 레코드의 건수를 줄이는 역할을 하지만 각 조건이 OR로 연 결되면 읽어서 비교해야 할 레코드가 더 늘어나기 때문에 WHERE 조건에 OR 연산자가 있다면 주의해야 한다.


## GROUP BY 절의 인덱스 사용
GROUP BY 절의 각 칼럼은 비교 연산자를 가지지 않으므로 작업 범위 결정 조건이나 체크 조건과 같이 구분해서 생각할 필요는 없다. GROUP BY 절에 명시된 칼럼의 순서가 인덱스를 구성하는 칼럼의 순서와 같으면 GROUP BY 절은 일단 인덱스를 이용할 수 있다.

- GROUP BY 절에 명시된 칼럼이 인덱스 칼럼의 순서와 위치가 같아야 한다. 
- 인덱스를 구성하는 칼럼 중에서 뒤쪽에 있는 칼럼은 GROUP BY 절에 명시되지 않아도 인덱스를 사용할 수 있지만 인덱스의 앞쪽에 있는 칼럼이 GROUP BY 절에 명시되지 않으면 인덱스를 사용할 수 없다. 
- WHERE 조건절과는 달리 GROUP BY 절에 명시된 칼럼이 하나라도 인덱스에 없으면 GROUP BY 절은 전혀 인덱스를 이용하지 못한다. 


![](https://velog.velcdn.com/images/chocochip/post/c8a017c3-7033-4915-afd0-400958f4e0eb/image.jpg)


그림은 GROUP BY 절이 인덱스를 사용하기 위한 조건을 간단하게 보여준다. 위쪽은 (COL_1, COL_2, COL_3, COL_4)로 만들어진 인덱스를 의미하며, 아래쪽은 COL_1부터 COL_3을 순서대로 GROUP BY 절에 명시된 칼럼을 의미한다. 그림에서 GROUP BY 절과 인덱스를 구성하는 칼럼의 순서가 중요하므로 굵은 화살표로 방향 표시를 넣어둔 것이다. 다음에 예시된 GROUP BY 절은 모두 인덱스를 이용하지 못하는 경우다.

```sql
GROUP BY COL_2, COL_1 
GROUP BY COL_1, COL_3, COL_2 
GROUP BY COL_1, COL_3 
GROUP BY COL_1, COL_2, COL_3, COL_4, COL_5 
```

위의 예제가 인덱스를 사용하지 못하는 원인을 살펴보자. 
- 첫 번째와 두 번째 예제는 GROUP BY 칼럼이 인덱스를 구성하는 **칼럼의 순서와 일치하지 않기 때문**에 사용하지 못하 는 것이다. 
- 세 번째 예제는 GROUP BY 절에 COL_3가 명시됐지만 **COL_2가 그 앞에 명시되지 않았기 때문**이다.
- 네 번째 예제에서는 GROUP BY 절의 마지막에 있는 COL_5가 인덱스에는 없어서 인덱스를 사용하지 못하는 것이다.

다음 예제는 GROUP BY 절이 인덱스를 사용할 수 있는 패턴이다. 다음 예제는 WHERE 조건 없이 단순히 GROUP BY만 사용된 형태의 쿼리다. 

```sql
GROUP BY COL_1 
GROUP BY COL_1, COL_2 · 
GROUP BY COL_1, COL_2, COL_3 
GROUP BY COL_1, COL_2, COL_3, COL_4
```

WHERE 조건절에 COL_1이나 COL_2가 동등 비교 조건으로 사용된다면 GROUP BY 절에 COL_1이나 COL_2가 빠 져도 인덱스를 이용한 GROUP BY가 가능할 때도 있다. 다음 예제는 인덱스의 앞쪽에 있는 칼럼을 WHERE 절에서 상수로 비교하기 때문에 GROUP BY 절에 해당 칼럼이 명시되지 않아도 인덱스를 이용한 그루핑이 가능한 예제다. 

```sql
WHERE COL_1='상수' GROUP BY COL_2, COL_3 
WHERE COL_1='상수' AND COL_2='상수' GROUP BY COL_3, COL_4
WHERE COL_1='상수' AND COL_2='상수' AND COL_3='상수' GROUP BY COL_4 
```
위 예제와 같이 WHERE 절과 GROUP BY 절이 혼용된 쿼리가 인덱스를 이용해 WHERE 절과 GROUP BY 절이 모두 처리될 수 있는지는 다음 예제와 같이 WHERE 조건절에서 동등 비교 조건으로 사용된 칼럼을 GROUP BY 절로 옮겨보면 된다. 
```sql
--// 원본 쿼리 · WHERE COL_1=' 상수' · GROUP BY COL_2, COL_3 

--// WHERE 조건절의 COL_1 칼럼을 GROUP BY 절의 앞쪽으로 포함시켜 본 쿼리 
WHERE COL_1='상수' ··· GROUP BY COL_1, COL_2, COL_3 
```
위의 예제에서 COL_1은 상숫값과 비교되므로 "GROUP BY COL_2, COL_3"는 "GROUP BY COL_1, COL_2, COL_3"와 똑같은 결과를 만들어 낸다. 이처럼 GROUP BY 절을 고쳐도 똑같은 결과가 조회된다면 WHERE 절 과 GROUP BY 절이 모두 인덱스를 사용할 수 있는 쿼리로 판단하면 된다.

## ORDER BY 절의 인덱스 사용
MySQL에서 GROUP BY와 ORDER BY는 처리 방법이 상당히 비슷하다. 그래서 ORDER BY 절의 인덱스 사용 여부는 GROUP BY의 요건과 거의 흡사하다. 하지만 ORDER BY는 조건이 하나 더 있는데, 정렬되는 각 칼럼의 오름차순(ASC) 및 내림차순(DESC) 옵션이 인덱스와 같거나 정반대인 경우에만 사용할 수 있다는 것 이다. 여기서 MySQL의 인덱스는 모든 칼럼이 오름차순으로만 정렬돼 있기 때문에 ORDER BY 절의 모든 칼럼이 오름차순이거나 내림차순일 때만 인덱스를 사용할 수 있다. 인덱스의 모든 칼럼이 ORDER BY 절 에 사용돼야 하는 것은 아니지만, ORDER BY 절의 칼럼들이 인덱스에 정의된 칼럼의 왼쪽부터 일치해야 하는 것에는 변함이 없다. 그림 11.7은 ORDER BY 절이 인덱스를 이용하기 위한 요건을 보여준다. 


![](https://velog.velcdn.com/images/chocochip/post/4f8d079e-9651-4e44-9d85-6d7845f9ea4b/image.jpg)


그림 11.7과 같은 인덱스에서 다음 예제의 ORDER BY 절은 인덱스를 이용할 수 없다. 참고로 ORDER BY 절 에 ASC나 DESC와 같이 정렬 순서가 생략되면 오름차순(ASC)으로 해석한다. 

```sql
ORDER BY COL_2, COL_3 
ORDER BY COL_1, COL_3, COL_2 
ORDER BY COL_1, COL_2 DESC, COL_3 : · 
ORDER BY COL_1, COL_3 ... 
ORDER BY COL_1, COL_2, COL_3, COL_4, COL_5 
```
위의 각 예제가 인덱스를 사용하지 못하는 원인을 살펴보자. 
- 첫 번째 예제는 인덱스의 제일 앞쪽 칼럼인 COL_ 10I ORDER BY 절에 명시되지 않았기 때문에 인덱스를 사용할 수 없다.
- 두 번째 예제는 인덱스와 ORDER BY 절의 칼럼 순서가 일치하지 않기 때문에 인덱스를 사용할 수 없다.
- 세 번째 예제는 ORDER BY 절의 다른 칼럼은 모두 오름차순인데, 두 번째 칼럼인 COL_2의 정렬 순서가 내림차순이라 서 인덱스를 사용할 수 없다. 인덱스가 "(COL_1 ASC, COL_2 DESC, COL_3 ASC, COL_4 ASC)"와 같이 정의됐다 면 이 정렬은 인덱스를 사용할 수 있게 된다.
- 네 번째 예제는 인덱스에는 COL_ 1과 COL_3 사이에 COL_2 칼럼이 있지만 ORDER BY 절에는 COL.2 칼럼이 명시되지 않았기 때문에 인덱스를 사용할 수 없다. 
- 다섯 번째 예제는 인덱스에 존재하지 않는 COL_5가 ORDER BY 절에 명시됐기 때문에 인덱스를 사용하지 못한다.


## WHERE 조건과 ORDER BY(또는 GROUP BY) 절의 인덱스 사용 
쿼리에 WHERE 절만 또는 GROUP BY나 ORDER BY 절만 포함돼 있다면 사용된 절 하나에만 초점을 맞춰서 인덱스를 사용할 수 있게 튜닝하면 된다. 하지만 애플리케이션에서 사용되는 쿼리는 그렇게 단순하지 않다. SQL 문장이 WHERE 절과 ORDER BY 절을 가지고 있다고 가정했을 때 WHERE 조건은 A 인덱스를 사용하고 ORDER BY는 B 인덱스를 사용하도록 쿼리가 실행될 수는 없다. 이는 WHERE 절과 GROUP BY 절이 같이 사용된 경우와 GROUP BY와 ORDER BY가 같이 사용된 쿼리에서도 마찬가지다. 

WHERE 절과 ORDER BY 절이 같이 사용된 하나의 쿼리 문장은 다음 3가지 중 한 가지 방법으로만 인덱스를 이용한다.
- WHERE 절과 ORDER BY 절이 동시에 같은 인덱스를 이용: WHERE 절의 비교 조건에서 사용하는 칼럼과 ORDER BY 절 의 정렬 대상 칼럼이 모두 하나의 인덱스에 연속해서 포함돼 있을 때 이 방식으로 인덱스를 사용할 수 있다. 이 방법 은 나머지 2가지 방식보다 훨씬 빠른 성능을 보이기 때문에 가능하다면 이 방식으로 처리할 수 있게 쿼리를 튜닝하 거나 인덱스를 생성하는 것이 좋다.
- WHERE 절만 인덱스를 이용: ORDER BY 절은 인덱스를 이용한 정렬이 불가능하며, 인덱스를 통해 검색된 결과 레코드 를 별도의 정렬 처리 과정(Using Filesort)을 거쳐 정렬을 수행한다. 주로 이 방법은 WHERE 절의 조건에 일치하는 레 코드의 건수가 많지 않을 때 효율적인 방식이다. 
- ORDER BY 절만 인덱스를 이용: ORDER BY 절은 인덱스를 이용해 처리하지만 WHERE 절은 인덱스를 이용하지 못한다. 이 방식은 ORDER BY 절의 순서대로 인덱스를 읽으면서 레코드 한 건씩 WHERE 절의 조건에 일치하는지 비교하고, 일 치하지 않을 때는 버리는 형태로 처리한다. 주로 아주 많은 레코드를 조회해서 정렬해야 할 때는 이런 형태로 튜닝 하기도 한다. 

또한 WHERE 절에서 동등 비교 조건으로 비교된 칼럼과 ORDER BY 절에 명시된 칼럼이 순서대로 빠짐없이 인덱스 칼럼의 왼쪽부터 일치해야 한다. WHERE 절에 동등 비교 조건으로 사용된 칼럼과 ORDER BY 절의 칼럼이 중첩되는 부분은 인덱스를 사용할 때 문제가 되지는 않는다. 하지만 중간에 빠지는 칼럼이 있으 면 WHERE 절이나 ORDER BY 절 모두 인덱스를 사용할 수 없다. 이때는 주로 WHERE 절만 인덱스를 이용할 수 있다.


![](https://velog.velcdn.com/images/chocochip/post/242f473d-660e-4a20-aa3a-c7aec2226004/image.jpg)

## GROUP BY 절과 ORDER BY 절의 인덱스 사용
GROUP BY와 ORDER BY 절이 동시에 사용된 쿼리에서 두 절이 모두 하나의 인덱스를 사용해서 처리되려면 GROUP BY 절에 명시된 칼럼과 ORDER BY 절이 명시된 칼럼의 순서와 내용이 모두 같아야 한다.

즉 GROUP BY는 인덱스를 이용할 수 있지만 ORDER BY가 인덱스를 이용할 수 없을 때, GROUP BY와 ORDER BY는 모두 인덱스를 이용하지 못한다.

MySQL 5.7 버전까지는 GROUP BY는 GROUP BY 칼럼에 대한 정렬까지 함께 수행하는 것이 기본 동작 방식이다. 하지만 MySQL 8.0 버전부터는 GROUP BY 절이 칼럼의 정렬까지는 보장하지는 않도록 바뀌었다. 그래서 MySQL 8.0 버전부터는 GROUP BY 칼럼으로 그루핑과 정렬을 모두 수행하기 위해서는 GROUP BY와 ORDER BY를 모두 명시해야 한다.

## WHERE 조건과 ORDER BY 절, GROUP BY 절의 인덱스 사용
WHERE 절과 GROUP BY 절, ORDER BY 절이 모두 포함된 쿼리가 인덱스를 사용하는지 판단하는 방법을 알아보자. 다음과 같은 3개의 질문을 기본으로 해서 흐름을 적용해 보면 된다. 

1. WHERE 절이 인덱스를 사용할 수 있는가? 
2. GROUP BY 절이 인덱스를 사용할 수 있는가? 
3. GROUP BY 절과 ORDER BY 절이 동시에 인덱스를 사용할 수 있는가?

![](https://velog.velcdn.com/images/chocochip/post/83ccab77-a876-43ed-8653-3a65d897f296/image.jpg)

# WHERE 절의 비교 조건과 사용 시 주의사항
WHERE 절에 사용되는 비교 조건의 표현식은 상당히 중요하다. 쿼리가 최적으로 실행되려면 적합한 인덱스와 함께 WHERE 절에 사용되는 비교 조건의 표현식을 적절하게 사용해야 한다.

## NULL 비교
다른 DBMS와는 조금 다르게 MySQL에서는 **NULL 값이 포함된 레코드도 인덱스로 관리**된다. 이는 인덱스에서는 NULL을 하나의 값으로 인정해서 관리한다는 것을 의미한다. SQL 표준에서 NULL의 정의는 비교할 수 없는 값이다. 그래서 두 값이 모두 NULL을 가진다고 하더라도 이 두 값이 동등한지 비교하는 것은 불가능하다. 연산이나 비교에서 한쪽이라도 NULL이면 그 결과도 NULL이 반환되는 이유가 바로 여기에 있다. 쿼리에서 NULL 인지 비교하려면 "IS NULL"(또는 "<=>") 연산자를 사용해야 한다. 그 밖의 방법으로는 칼럼의 값이 NULL 인지 알 수 있는 방법이 없다.

### ISNULL()

칼럼의 값이 NULL인지 확인할 때는 ISNULL() 함수를 사용할 수 있다. 하지만 ISNULL() 함수를 WHERE 조건에서 사용할 때는 주의할 점이 있다. 

다음 예제 쿼리를 한번 살펴보자. 

```sql
mysql> SELECT * FROM titles WHERE to_date IS NULL; 
mysql> SELECT * FROM titles WHERE ISNULL(to_date); 
mysql> SELECT * FROM titles WHERE ISNULL(to_date)=1; 
mysql> SELECT * FROM titles WHERE ISNULL(to_date)=true; 
```

위에 나열된 4개의 쿼리는 전부 정상적으로 `to_date` 칼럼이 NULL 인지 판별해 낼 수 있는 쿼리다. 

- 첫 번째와 두 번째 쿼리: **인덱스를 레인지 스캔** 사용 가능
- 세 번째와 네 번째 쿼리: **테이블을 풀 스캔** 

NULL 비교를 할 때는 가급적 IS NULL 연산자를 사용하길 권장한다. 예상외로 세 번째나 네 번째 쿼리가 자주 사용되는데, 이러한 비교는 인덱스를 사용하지 못한다는 점을 확실히 알아두기 바란다.

## 문자열이나 숫자 비교 
문자열 칼럼이나 숫자 칼럼을 비교할 때는 반드시 그 타입에 맞는 상숫값을 사용할 것을 권장한다. 즉 비교 대상 칼럼이 문자열 칼럼이라면 문자열 리터럴을 사용하고, 숫자 타입이라면 숫자 리터럴을 이용하는 규칙만 지켜주면 된다. 
```sql
mysql> SELECT * FROM employees WHERE emp_no=10001; 
mysql> SELECT * FROM employees WHERE first_name='Smith'; 
mysql> SELECT * FROM employees WHERE emp_no='10001'; 
mysql> SELECT * FROM employees WHERE first_name=10001;
```

첫 번째와 두 번째 쿼리는 적절히 타입을 맞춰서 비교를 수행했지만, 세 번째와 네 번째 쿼리는 칼럼의 타입과 비교 상수의 타입이 일치하지 않는 WHERE 조건이 포함돼 있다. 위 예제의 쿼리가 어떻게 실행되 는지 쿼리별로 한번 살펴보자

- 첫 번째와 두 번째 쿼리: 칼럼의 타입과 비교하는 상숫값이 동일한 타입으로 사용됐기 때문에 인덱스 이용 가능 
- 세 번째의 쿼리: emp_no 칼럼이 숫자 타입이기 때문에 문자열 상숫값을 숫자로 타입 변환해서 비교를 수행하므로 특별히 성능 저하는 발생하지 않음
- 네 번째 쿼리: first_name이 문자열 칼럼이지만 비교되는 상숫값이 숫자 타입이므로 옵티마이저는 우선순위를 가지는 숫자 타입으로 비교를 수행하려고 실행 계획을 수립한다. 그래서 first_name 칼럼의 문자열을 숫자로 변환해서 비교를 수행한다. 하지만 first_name 칼럼의 타입 변환이 필요하기 때문에 ix_firstname 인덱스를 사용하지 못한다.


옵티마이저가 어떤 경우에 어떻게 타입 변환을 유도하는지 정확히 아는 것도 필요하지만 칼럼의 타입에 맞게 상수 리터럴을 비교 조건에 사용하는 것이 중요하다.

## 날짜 비교 
MySQL에서는 날짜만 저장하는 DATE 타입과 날짜와 시간을 함께 저장하는 DATETIME 과 TIMESTAMP 타입이 있으며, 시간만 저장하는 TIME이라는 타입도 있기 때문에 상당히 복잡하게 느껴질 수 있다.

### DATE 또는 DATETIME과 문자열 비교 
DATE 또는 DATETIME 타입의 값과 문자열을 비교할 때는 문자열 값을 자동으로 DATETIME 타입의 값으로 변환해서 비교를 수행한다. 

DATE 타입의 칼럼과 비교하기 위해 STR_TO_DATE() 함수를 이용해 문자열 "2011-07-23"을 DATE 타입으로 변환했다. 
```sql
mysql> 	SELECT COUNT(*) 
		FROM employees 
		WHERE hire_date > STR_TO_DATE('2011-07-23', '%Y-%m-%d'); 
mysql> 	SELECT COUNT(*) 
		FROM employees 
    	WHERE hire_date>'2011-07-23'; 
```

하지만 이렇게 **칼럼의 타입이 DATE나 DATETIME 타입이면 별도로 문자열을 DATE나 DATETIME 타입으로 명시적으로 변환하지 않아도 MySQL이 내부적으로 변환을 수행**한다. 결과적으로 두 번째 예제도 첫 번째 예제와 동일하게 처리된다. 물론 첫 번째 쿼리와 두 번째 쿼리 모두 인덱스를 효율적으로 이용하기 때문에 성능과 관련된 문제는 고민하지 않아도 된다. DATETIME 타입도 DATE 타입과 마찬가지로 동작한다. 

```sql
mysql> 	SELECT COUNT(*) 
		FROM employees 
		WHERE DATE_FORMAT(hire_date, '%Y-%m-%d') > '2011-07-23'; 

```

그런데 가끔 위의 쿼리를 다음과 같이 작성하는 사람들이 있다. 이미 눈치챘겠지만 다음 쿼리는 **hire_date 타입을 강제적으로 문자열로 변경하기 때문에 인덱스를 효율적으로 이용하지 못한다**. 

가능하면 DATE나 DATETIME 타입의 칼럼을 변경하지 말고 **상수를 변경하는 형태로 조건을 사용하는 것이 좋다**. 날짜 타입의 포맷을 변환하는 형태를 포함해서 날짜 타입 칼럼의 값을 더하거나 빼는 함수로 변형한 후 비교해도 마찬가지로 인덱스를 이용할 수 없다.

### DATE와 DATETIME의 비교 
DATETIME 값에서 시간 부분만 떼어 버리고 비교하려면 다음 예제와 같이 쿼리를 작성하면 된다. DATE() 함수는 DATETIME 타입의 값에서 시간 부분은 버리고 날짜 부분만 반환하는 함수다. 

```sql
mysql> SELECT COUNT(*) FROM employees WHERE hire_ _date>DATE(NOW()); 
```
DATETIME 타입의 값을 DATE 타입으로 만들지 않고 그냥 비교하면 MySQL 서버가 DATE 타입의 값을 DATETIME으로 변환해서 같은 타입을 만든 다음 비교를 수행한다. 즉, DATE 타입의 값 "2011-06-30"과 DATETIME 타입의 값 "2011-06-30 00:00:01"을 비교하는 과정에서는 "2011-06-30"을 "2011-06-30 00:00:00"으로 변환해서 비교를 수행한다. DATETIME과 DATE 타입의 비교에서 타입 변환은 인덱스의 사용 여부에 영향을 미치지 않기 때문에 성능 보다는 쿼리의 결과에 주의해서 사용하면 된다. 

### DATETIME과 TIMESTAMP의 비교 
DATE나 DATETIME 타입의 값과 TIMESTAMP의 값을 별도의 타입 변환 없이 비교하면 문제없이 작동하고 실제 실행 계획도 **인덱스 레인지 스캔을 사용해서 동작하는 것처럼 보이지만 사실은 그렇지 않다**. **`UNIX_TIMESTAMP()` 함수의 결괏값은 MySQL 내부적으로는 단순 숫자 값에 불과할 뿐이므로 비교를 통해 원하는 결과를 얻을 수 없다. 이때는 반드시 비교 값으로 사용되는 상수 리터럴을 비교 대상 칼럼의 타입에 맞게 변환해서 사용하는 것이 좋다.** 칼럼이 DATETIME 타입이라면`FROM_UNIXTIME()` 함수를 이용해 TIMESTAMP 값을 DATETIME 타입으로 만들어서 비교해야 한다. 그리고 반대로 칼럼의 타입이 TIMESTAMP라면 `UNIX_TIMESTAMP()` 함수를 이용해 DATETIME을 TIMESTAMP로 변환해서 비교해야 한다. 또는 간단하게 NOW() 함수를 이용해도 된다.

### Short-Circuit Evaluation 
다음 의사 코드를 이용해 "Short-circuit Evaluation"의 작동 방식을 살펴보자. 
```java 
boolean in_ transaction; 

if (in_transaction && has_modified()) { 
	commit(); 
} 
```

위의 예제 코드에서는 `in_transaction` 불리언 변수의 값이 TRUE이면 `has_modified()` 함수를 호출하고, 그 결괏값이 TRUE라면 commit() 함수가 실행될 것이다. 그런데 `in_transaction` 불리언 변수의 값이 FALSE라면 `has_modified()` 함수의 결괏값에 관계없이 commit() 함수는 호출되지 않는다. 그래서 많은 프로그래밍 언어에서는 빠른 성능을 위해 `in_transaction` 불리언 변숫값이 FALSE라면 has_modified()함수를 호출도 하지 않고 다음 코드를 실행한다. 이처럼 여러 개의 표현식이 AND 또는 OR 논리 연산자로 연결된 경우 선행 표현식의 결과에 따라 후행 표현식을 평가할지 말지 결정하는 최적화를 "Short-circuit Evaluation"이라고 한다. 

MySQL 서버에서도 "Short-circuit Evaluation"을 통해 퀴리의 성능에 영향을 미칠 수 있다. WHERE 절의 AND로 연결된 조건의 순서를 변경한다면 30% 정도의 성능 차이가 날 수 있다.


WHERE 절에 인덱스를 사용할 수 있을 경우, 나열된 순서와 무관하게 MySQL 서버는 인덱스를 사용할 수 있는 조건을 먼저 평가한다. 그 후, 인덱스를 이용한 나머지 칼럼에 대해 순서대로 평가한다.

MySQL 서버에서 쿼리를 작성할 때 가능하면 복잡한 연산 또는 다른 테이블의 레코드를 읽어야 하는 서브퀴리 조건 등은 **WHERE 절의 뒤쪽으로 배치하는 것이 성능상 도움이 될 것**이다. 물론 WHERE 조건 중에서 인덱스를 사용할 수 있는 조건은 WHERE 절의 어느 위치에 나열되든지 그 순서에 관계없이 가장 먼저 평가되기 때문에 고려하지 않아도 된다.

# LIMIT n
LIMIT은 쿼리 결과에서 지정된 순서에 위치한 레코드만 가져오고자 할 때 사용한다.

LIMIT 쿼리는 다음의 순서로 실행된다.

1. 테이블에서 WHERE 절의 검색 조건에 일치하는 레코드를 전부 읽어온다.
2. 읽어온 레코드를 ORDER BY 칼럼값에 따라 정렬한다.
3. 정렬된 결과를 LIMIT 제한에 맞춰 사용자에게 반환한다.

오라클과 다르게 MySQL의 LIMIT은 WHERE 조건이 아니기 때문에 항상 쿼리의 마지막에 실행된다. LIMIT의 중요한 특성은 LIMIT에서 필요한 레코드 건수만 준비되면 즉시 쿼리를 종료한다. 즉, 모든 레코드의 정렬이 완료되지 않았어도 LIMIT n개 중 n개의 레코드가 정렬되면 작업을 멈춘다.
## GROUP BY 및 DISTINT

GROUP BY와 함께 쓰일 때는 GROUP BY 처리가 완료되고 나서야 LIMIT 처리를 수행할 수 있다. 인덱스를 사용하지 못하는 GROUP BY는 그루핑과 정렬의 특성을 모두 가지고 있기 때문에 일단 GROUP BY 작업이 모두 완료돼야만 LIMIT을 수행할 수 있다. 결국 LIMIT이 GROUP BY와 함께 사용되는 경우에는 LIMIT이 절이 있더라도 실질적인 서버의 작업 내용을 크게 줄여주지 못한다.

DISTINT는 정렬에 대한 요건 없이 유니크한 그룹만 만들어낸다. MySQL은 스토리지 엔진을 통해 풀 테이블 스캔 방식을 이용해 테이블을 읽어들임과 동시에 DISTINCT를 위한 중복 제거 작업을 진행한다. 이 작업을 반복적으로 처리하다가 유니크한 레코드가 LIMIT 건수만큼 채워지면 그 순간 쿼리를 멈춘다. 따라서 DISTICT와 함께 사용된 LIMIT은 실질적인 중복 제거 작업의 범위를 줄이는 역할을 한다.

쿼리 문장에 GROUP BY나 ORDER BY 같은 전체 범위 작업이 선행되더라도 LIMIT 절이 있다면 나름의 성능 향상이 있다고 볼 수 있다.

ORDER BY나 GROUP BY 또는 DISTICT가 인덱스를 이용해 처리될 수 잇다면 LIMIT 절은 꼭 필요한 만큼의 레코드만 읽게 만들어 주기 때문에 쿼리의 작업량을 상당히 줄여준다.

## 제한 사항

자주 부딪히는 LIMIT 제한 사항으로는 LIMIT의 **인자로 표현식**이나 **별도의 서브쿼리**를 사용할 수 없다는 점이다.

```sql
SELECT * FROM employees LIMIT (100-10);
```
또 다른 주의점으로는 실제 쿼리의 성능은 사용자의 화면에 레코드가 몇 건 출력되느냐보다 MySQL 서버가 그 결과를 만들어 내가 위해 어떠한 작업들을 했는지가 중요하다. 

### 페이징
LIMIT을 통해 페이징을 다음과 같이 구현할 수 있다.

```sql
SELECT * FROM salaries ORDER BY salary LIMIT n, m;
```

이때 n, m이 2000000, 10으로 커지게되면 salaries 테이블을 처음부터 읽으면서 2000010건의 레코드를 읽은 후, 2000000건은 버리고 마지막 10건만 사용자에게 반환한다. 사용자에게는 10건만 표시되지만, MySQL 서버는 2000010건의 레코드를 읽어야하기 때문에 쿼리가 느려진다.

LIMIT 조건의 페이징이 첫 몇 개 페이지 조회로 끝나지 않을 가능성이 높다면 WHERE 조건절로 읽어야할 위치를 찾고 그 위치에서 10개만 읽는 형태의 쿼리를 사용하는 것이 좋다.

```sql
-- // 첫 페이지 조회용 쿼리
SELECT * FROM salaries ORDER BY salary LIMIT 0, 10;

-- // 마지막 페이지 조회용 쿼리
SELECT * FROM salaries WHERE salary >= 154888 AND NOT (salary=154888 AND emp_no<=109334) ORDER BY salary LIMIT 0, 10;
```

WHERE 방식을 활용할 경우, 인덱스는 중복이 허용되는 인덱스이기 때문에 단순히 마지막 값보다 큰 것을 조회하거나 크거나 같은 경우를 조회하면 중복이나 누락이 발생할 수 있다. 중복이나 누락을 제외하기 위한 방법은 사용하는 인덱스가 몇 개의 칼럼으로 구성돼 있는지, 유니크한지에 따라 달라질 수 있으니 쿼리 작성 시 주의하자.

# COUNT()
COUNT() 함수는 결과 레코드의 건수를 반환하는 함수다. COUNT() 함수는 칼럼이나 표현식을 인자로 받으며, 특별한 형태로 `*`를 사용할 수도 있다. 여기서 `*`는 SELECT 절에 사용될 때처럼 모든 칼럼을 가져오라는 의미가 아니라 그냥 **레코드 자체를 의미하는 것**이다. 실제로 COUNT(`*`)라고 해서 레코드의 모든 칼럼을 읽는 형태로 처리하지는 않는다. 그래서 굳이 COUNT(프라이머리 키 칼럼) 또는 COUNT(1)과 같이 사용하지 않고 COUNT(`*`)라고 표현해도 동일한 처리 성능을 보인다. 

## MyISAM
MyISAM 스토리지 엔진을 사용하는 테이블은 항상 테이블의 메타 정보에 전체 레코드 건수를 관리한다. 그래서 MySQL 서버가 실제 레코드 건수를 세어 보지 않아도 바로 결과를 반환할 수 있기 때문에 빠르게 처리된다. 하지만 WHERE 조건이 있는 COUNT(`*`) 쿼리는 그 조건에 일치하는 레코드를 읽어보지 않는 이상 알 수 없으므로 일반적인 DBMS와 같이 처리된다. 

## InnoDB
InnoDB 스토리지 엔진을 사용하는 테이블에서는 WHERE 조건이 없는 COUNT(`*`) 쿼리라고 하더라도 직접 데이터나 인덱스를 읽어야만 레코드 건수를 가져올 수 있기 때문에 큰 테이블에서 COUNT() 함수를 사용하는 작업은 주의해야 한다. 

테이블이 가진 대략적인 레코드 건수로 충분하다면 SELECT COUNT(`*`)보다는 SHOW TABLE STATUS 명령으로 통계 정보를 참조하는 것도 좋은 방법이다. 때로는 통계 정보의 레코드 건수는 실제 테이블의 레코드 건수와 많은 차이가 있을 수 있는데, 이런 경우에는 ANALYZE TABLE 명령을 실행해 통계 정보를 갱신하면 된다. 

## Count 주의점
COUNT(`*`) 쿼리에서 가장 많이 하는 실수는 **ORDER BY 구문이나 LEFT JOIN과 같은 레코드 건수를 가져오는 것과는 무관한 작업을 포함하는 것**이다. 대부분 COUNT(`*`) 쿼리는 페이징 처리를 위해 사용할 때가 많은데, 많은 개발자가 SELECT 쿼리를 그대로 복사해서 칼럼이 명시된 부분만 삭제하고 그 부분을 COUNT(`*`) 함수로 대체해서 사용하곤 한다. 그래서 단순히 COUNT(`*`)만 실행하는 쿼리임에도 ORDER BY가 포함돼 있다거나 별도의 체크 조건을 가지지도 않는 LEFT JOIN이 사용된 채로 실행될 때가 많다. COUNT(`*`) 퀴리에서 ORDER BY 절은 어떤 경우에도 필요치 않다. 그리고 LEFT JOIN 또한 레코드 건수의 변화가 없거나 아 우터 테이블에서 별도의 체크를 하지 않아도 되는 경우에는 모두 제거하는 것이 성능상 좋다. 

> MySQL 8.0 버전부터는 SELECT COUNT(`*`) 쿼리에 사용된 ORDER BY 절은 옵티마이저가 무시하도록 개선됐다.

많은 사용자가 일반적으로 칼럼의 값을 SELECT하는 쿼리보다 COUNT(`*`) 쿼리가 훨씬 빠르게 실행될 것으로 생각한다. 하지만 인덱스를 제대로 사용하도록 튜닝되지 못한 COUNT(`*`) 쿼리는 페이징해서 데이터를 가져오는 쿼리보다 몇 배 또는 몇십 배 더 느리게 실행될 수도 있다. COUNT(`*`) 쿼리도 많은 부하를 일으키기 때문에 주의 깊게 작성해야 한다. 

COUNT() 함수에 칼럼명이나 표현식이 인자로 사용되면 그 칼럼이나 표현식의 결과가 NULL이 아닌 레코드 건수만 반환한다. 예를 들어, "COUNT(column1)"이라고 SELECT 쿼리에 사용하면 **column1이 NULL이 아닌 레코드의 건수**를 가져온다. 그래서 NULL이 될 수 있는 칼럼을 COUNT() 함수에 사용할 때는 의도대로 쿼리가 작동하는지 확인하는 것이 좋다.

많은 사람이 게시물 건수를 확인하는 COUNT 쿼리가 어느 정도로 MySQL 서버에 부하를 유발하는지 잘 모르고 개발한다. id가 1인 레코드 건수가 백만 건이라면 테이블에서 100만 건을 읽어야 한다. 물론 인덱스만 읽어서 처리(커버링 인덱스)가 가능하다면 쿼리 성능은 빨라질 것이다. 하지만 실제 서비스에서는 로직이 복잡해 테이블의 데이 터를 읽어야만 하는 경우가 대부분이다. 따라서 게시물의 전체 건수를 조회하는 작업은 피하는 것이 좋은데, 게시물의 **페이지 번호를 보여주는 방식보다는 "이전"과 "다음" 버튼만 표시하는 방식을 검토해볼 것을 권장**한다.



# JOIN

## JOIN의 순서와 인덱스 
인덱스 레인지 스캔은 **인덱스를 탐색(Index Seek)**하는 단계와 **인덱스를 스캔(Index Scan)**하는 과정으로 구분해 볼 수 있다. 일반적으로 인덱스를 이용해서 쿼리하는 작업에서는 가져오는 레코드의 건수가 소량이기 때문에 인덱스 스캔 작업은 부하가 작지만 특정 인덱스 키를 찾는 인덱스 탐색 작업은 상대적으로 부하가 높은 편이다. 

조인 작업에서 드라이빙 테이블을 읽을 때는 인덱스 탐색 작업을 단 한 번만 수행하고, 그 이후부터는 스캔만 실행하면 된다. 하지만 드리븐 테이블에서는 인덱스 탐색 작업과 스캔 작업을 드라이빙 테이블에서 읽은 레코드 건수만큼 반복한다. 드라이빙 테이블과 드리븐 테이블이 1:1로 조인되더라도 드리븐 테이블을 읽는 것이 훨씬 더 큰 부하를 차지한다. 그래서 **옵티마이저는 항상 드라이빙 테이블이 아니라 드리븐 테이블을 최적으로 읽을 수 있게 실행 계획을 수립**한다. 

다음과 같이 employees 테이블과 dept_emp 테이블을 조인하는 쿼리로 이 내용을 한번 살펴보자. 
```sql
SELECT * FROM employees e, dept_emp de WHERE e.emp_no=de.emp_no; 
```
이 두 테이블의 조인 쿼리에서 employees 테이블의 emp_no 칼럼과 dept_emp 테이블의 emp_no 칼럼에 각각 인덱스가 있을 때와 없을 때 조인 순서가 어떻게 달라지는지 한번 살펴보자.

- 두 칼럼 모두 각각 인덱스가 있는 경우: 어느 테이블을 드라이빙으로 선택하든 인덱스를 이용해 드리븐 테이블의 검색 작업을 빠르게 처리할 수 있다. 이때 옵티마이저가 통계 정보를 이용해 적절히 드라이빙 테이블을 선택하게 된다. 어느 쪽 테이블이 드라이빙 테이블이 되든 옵티마이저가 선택하는 방법이 최적일 때가 많다. 
- employees.emp_no에만 인덱스가 있는 경우: employees.emp_no에만 인덱스가 있을 때 dept_emp 테이블이 드리븐 테이블로 선택된다면 employees 테이블의 레코드 건수만큼 dept_emp 테이블을 풀 스캔해야만 "e.emp_no=de. emp_no" 조건에 일치하는 레코드를 찾을 수 있다. 그래서 옵티마이저는 항상 dept_emp 테이블을 드라이빙 테이블로 선택하고, employees 테이블을 드리븐 테이블로 선택한다. 이때는 "e.emp_no=10001"과 같이 employees 테이블을 아주 효율적으로 접근할 수 있는 조건이 있더라도 옵티마이저는 employees 테이블을 드라이빙 테이블로 선택하지 않을 가능성이 높다. 

- dept_emp.emp_no에만 인덱스가 있는 경우: 위의 경우와는 반대로 처리 된다. 이때는 employees 테이블의 반복된 풀 스캔을 피하기 위해 employees 테이블을 드라이빙 테이블로 선택하고 dept_emp 테이블을 드리븐 테이블로 조인을 수행하게 실행 계획을 수립한다. 

- 두 칼럼 모두 인덱스가 없는 경우: "두 칼럼 모두 각각 인덱스가 있는 경우"와 마찬가지로 어느 테이블을 드라이빙으로 선택하더라도 드리븐 테이블의 **풀 스캔이 발생하기 때문에 옵티마이저가 적절히 드라이빙 테이블을 선택**한다. 단 **레코드 건수가 적은 테이블**을 드라이빙 테이블로 선택하는 것이 훨씬 효율적이다. 이렇게 조인 조건을 빠르게 처리할 적절한 인덱스가 없는 경우 MySQL 8.0.18 이전 버전까지는 블록 네스티드 루프 조인을 사용했다. 하지만 MySQL 8.0.18 버전부터는 블록 네스티드 루프 조인이 없어지고 해시 조인이 도입되면서 해시 조인으로 처리된다. 

## JOIN 칼럼의 데이터 타입
WHERE 절에 사용되는 조건에서 비교 대상 칼럼과 표현식의 데이터 타입을 반드시 동일하게 사용해야 하는 이유는 이미 자세히 살펴봤다. 이것은 테이블의 조인 조건에서도 동일하다. 조인 칼럼 간의 비교에서 각 칼럼의 **데이터 타입이 일치하지 않으면 인덱스를 효율적으로 이용할 수 없다**.


옵티마이저는 드리븐 테이블이 인덱스 레인지 스캔을 사용하지 못하고, 드리븐 테이블의 풀테이블 스캔이 필요한 것을 알면 조금이라도 빨리 실행되도록 조인 버퍼를 활용한 해시 조인을 사용한다.

인덱스 사용에 영향을 미치는 데이터 타입 불일치는 CHAR 타입과 VARCHAR 타입, 또는 INT 타입과 BIGINT 타입, 그리고 DATE 타입과 DATETIME 타입 사이에서는 발생하지 않는다. 즉, CHAR 타입과 VARCHAR 타입의 비교는 특별히 문제되지 않으며, INT 타입과 BIGINT 타입 또는 SMALLINT 타입과의 비교 등도 문제가 되지 않는다. 하지만 대표적으로 다음의 비교 패턴은 문제가 될 가능성이 높다.


- CHAR 타입과 INT 타입의 비교와 같이 데이터 타입의 종류가 완전히 다른 경우 
- 같은 CHAR 타입이더라도 문자 집합이나 콜레이션이 다른 경우 
- 같은 INT 타입이더라도 부호(Sign)의 존재 여부가 다른 경우 

### 문자 집합과 콜레이션
두 개의 테이블에서 같은 값을 저장하는 각 칼럼이 서로 다른 문자 집합과 콜레이션으로 생성되어 조인할 경우, 드리븐 테이블을 풀 테이블 스캔하는 실행 계획으로 조인이 실행되기에 옵티마이저가 조인 버퍼를 사용한다. 기본적인 표준화 규칙을 가지고 데이터 모델링된 경우에는 이러한 케이스가 잘 발생하지않지만 규칙 없이 조금씩 데이터 모델을 변경하다 보면 이런 현상이 자주 발생한다. 

이럴 때는 칼럼의 **문자 집합과 콜레이션을 통일하는 것**만이 유일한 해결책이다. 데이터베이스 모델에 대한 표준화 규칙을 수립하고, 규칙을 기반으로 설계를 진행한다면 이런 문제를 최소화할 수 있을 것이다. 표준 규칙을 수립하기가 어렵다면 각 칼럼에 저장되는 데이터 타입에 맞게 칼럼의 타입을 선정하는 것이 중요하다. 그리고 조인이 수행되는 칼럼은 데이터 타입을 일치시키기 위해 최종 점검을 하는 것이 좋다.


## OUTER JOIN 성능과 주의사항

이너 조인 (INNER JOIN)은 조인 대상 테이블에 모두 존재하는 레코드만 결과 집합으로 반환한다. 이너 조인의 이 같은 특성 때문에 아우터 조인(OUTER JOIN) 으로만 조인을 실행하는 쿼리들도 자주 보인다. 다음 예제 쿼리는 3개 테이블을 조인하면서 LEFT JOIN만 사용하고 있다. mysql> SELECT ★ FROM employees e LEFT JOIN dept_emp de ON de. emp_no=e. emp_no LEFT JOIN departments d ON d.dept_no=de.dept_no AND d.dept_name=" Development'; 이 쿼리의 실행 계획을 보면 다음과 같이 제일 먼저 employees 테이블을 풀 스캔하면서 dept_emp 테이블 과 departments 테이블을 드리븐 테이블로 사용한다는 것을 알 수 있다. employees 테이블에 존재하는 사원 중에서 dept_emp 테이블에 레코드를 갖지 않는 경우가 있다면 아우 터 조인이 필요하지만, 대부분 그런 경우는 없으므로 굳이 아우터 조인을 사용할 필요가 없다. 

즉 테이블의 데이터가 일관되지 않은 경우에만 아우터 조인이 필요한 경우인 것이다. MySQL 옵티마이저는 절대 아우터로 조인되는 테이블을 드라이빙 테이블로 선택하지 못하기 때문에 풀 스캔이 필요한 employees 테이블을 드라이빙 테이블로 선택한다. 그 결과 쿼리의 성능이 떨어지는 실행 계획을 수립한 것이다.

이 쿼리에 이너 조인을 이용했다면 다음과 같이 departments 테이블에서 부서명이 "Development"인 레코드 1건만 찾아서 조인을 실행하는 실행 계획을 선택했을 것이다. 이너 조인으로 사용해도 되는 쿼리를 아우터 조인으로 작성하면 MySQL 옵티마이저가 조인 순서를 변 경하면서 수행할 수 있는 최적화의 기회를 빼앗아버리는 결과가 된다. 필요한 데이터와 조인되는 테이 블 간의 관계를 정확히 파악해서 꼭 필요한 경우가 아니라면 이너 조인을 사용하는 것이 업무 요건을 정확히 구현함과 동시에 쿼리의 성능도 향상시킬 수 있다. 아우터 조인(OUTER JOIN) 쿼리를 작성하면서 많이 하는 또 다른 실수는 다음 예제와 같이 아우터(OUTER) 로 조인되는 테이블에 대한 조건을 WHERE 절에 함께 명시하는 것이다. mysq1> SELECT ★ FROM employees e LEFT JOIN dept_manager mgr ON mgr.emp_no=e.emp_no WHERE mgr.dept_no='d001'; ON 절에 조인 조건은 명시했지만 아우터로 조인되는 테이블인 dept_manager의 dept_no=' d001' 조건을 WHERE 절에 명시한 것은 잘못된 조인 방법이다. 위의 LEFT JOIN이 사용된 쿼리는 WHERE 절의 조건 때문 에 MySQL 옵티마이저가 LEFT JOIN을 다음 쿼리와 같이 INNER JOIN으로 변환해서 실행해버린다. mysql> SELECT ★ FROM employees e INNER JOIN dept_manager mgr ON mgr.emp_no=e.emp_no WHERE mgr.dept_no="d001'; 정상적인 아우터 조인이 되게 만들려면 다음 쿼리와 같이 WHERE 절의"mgr.dept_no=' d001 - 조건을 LEFT JOIN의 ON 절로 옮겨야 한다.

+ mysql> SELECT FROM employees e LEFT JOIN dept_manager mgr ON mgr.emp_no=e. emp_no AND mgr. dept_no=' d001' ; 예외적으로 OUTER JOIN으로 연결되는 테이블의 칼럼에 대한 조건을 WHERE 절에 사용해야 하는 경우가 있는데, 다음과 같이 안티 조인(ANTI-JOIN) 효과를 기대하는 경우가 그렇다. mysql> SELECT ★ FROM employees e LEFT JOIN dept_manager dm ON dm. emp_no=e. emp_no WHERE dm.emp_no IS NULL LIMIT 10; 위 퀴리는 사원 중에서 매니저가 아닌 사용자들만 조회하는 쿼리인데, WHERE 절에 아우터로 조인된 dept_manager 테이블의 emp_no 칼럼이 NULL 인 레코드들만 조회한다. 이런 형태의 요건이 아우터 테이블 의 칼럼이 WHERE 절에 사용될 수 있는 유일한 경우다. 그 외의 경우 MySQL 서버는 LEFT JOIN을 INNER JOIN으로 자동 변환한다는 것을 꼭 기억하자.

## JOIN과 외래키
데이터베이스에 외래키(FOREIGN KEY)가 생성돼 있어야만 조인할 수 있는지 궁금해하는 게시물을 본 적이 있다. **외래키는 조인과 아무런 연관이 없다.** 외래키를 생성하는 주목적은 데이터의 무결성을 보장하기 위해서다. 외래키와 연관된 무결성을 참조 무결성이라고 표현한다. 

그런데 애플리케이션의 버그 등의 이유로 부서 테이블에는 존재하지 않는 부서 코드가 사원 테이블에 있을 수 있다. 이렇게 참조 무결성이 깨지는 문제를 DBMS 차원에서 막기 위해 외래키를 생성한다. 하지만 SQL로 테이블 간의 조인을 수행하는 것은 전혀 무관한 칼럼을 조인 조건으로 사용해도 문법적으로는 문제가 되지 않는다. 데이터 모델링을 할 때는 각 테이블 간의 관계를 필수적으로 그려 넣어야 한다. 하지만 그 데이터 모델을 데이터베이스에 생성할 때는 그 테이블 간의 관계는 외래키로 생성하지 않을 때가 더 많다. 하지만 테이블 간의 조인을 사용하기 위해 외래키가 필요한 것은 아니다.

## 지연된 조인(Delayed Join)

조인을 사용해서 데이터를 조회하는 쿼리에 GROUP BY 또는 ORDER BY를 사용할 때 각 처리 방법에서 인덱스를 사용한다면 이미 최적으로 처리되고 있을 가능성이 높다. 하지만 **그렇지 못하다면 MySQL 서버는 우선 모든 조인을 실행하고 난 다음 GROUP BY나 ORDER BY를 처리**할 것이다. 조인은 대체로 실행되면 될수록 결과 레코드 건수가 늘어난다. 그래서 조인의 결과를 GROUP BY하거나 ORDER BY하면 조인을 실행 하기 전의 레코드에 GROUP BY나 ORDER BY를 수행하는 것보다 많은 레코드를 처리해야 한다. 

지연된 조인이란 **조인이 실행되기 이전에 GROUP BY나 ORDER BY를 처리하는 방식**을 의미한다. 지연된 조인은 주로 LIMIT이 함께 사용된 쿼리에서 더 큰 효과를 얻을 수 있다. 

지연된 조인으로 개선된 쿼리는 임시 테이블(`<<derived2>`)을 한 번 더 사용하기 때문에 느리다고 예상할 수도 있 다. 하지만 임시 테이블에 저장할 레코드가 적기 때문에 메모리를 이용해 빠르게 처리된다. 조인의 횟수를 비교해보면 지연된 조인으로 변경된 쿼리의 조인 횟수가 훨씬 적다는 사실을 알 수 있다. 실행 계획상으로 보면 지연된 조인으로 변경된 퀴리가 오히려 더 느릴 것 같지만, 실제 테스트를 해보면 **지연된 조인으로 개선된 쿼리가 3~4배 정도는 더 빠르게 실행된다는 것을 확인**할 수 있다. 지연된 쿼리의 원리를 정확히 이해하지 못한 상태로 지연된 쿼리를 작성하면 오히려 역효과가 날 수도 있다. 하지만 잘 튜닝된 지연된 쿼리는 원래의 쿼리보다 몇십 배, 몇백 배 더 나은 성능을 보일 수도 있다. 지연된 조인은 경우에 따라 상당한 성능 향상을 가져올 수 있지만 모든 퀴리를 지연된 조인 형태로 개선할 수 있는 것은 아니다. OUTER JOIN과 INNER JOIN에 대해 다음과 같은 조건이 갖춰져야만 지연된 퀴리로 변경해서 사용할 수 있다.

- LEFT (OUTER) JOIN인 경우 드라이빙 테이블과 드리븐 테이블은 1:1 또는 M:1 관계여야 한다. 
- INNER JOIN인 경우 드라이빙 테이블과 드리븐 테이블은 1:1 또는 M:1의 관계임과 동시에 (당연한 조건이겠지만) 드 라이빙 테이블에 있는 레코드는 드리븐 테이블에 모두 존재해야 한다. 두 번째와 세 번째 조건은 드라이빙 테이블을 서브쿼리로 만들고 이 서브쿼리에 LIMIT을 추가해도 최종 결과의 건수가 변하지 않는다는 보증을 해주는 조건이기 때문에 반드시 정확히 확인한 후 적용해야 한다. 

> 지연된 조인은 여기서 언급한 조인의 개수를 줄이는 것뿐만 아니라 GROUP BY나 ORDER BY 처리가 필요한 레코드의 전체 크기를 줄이는 역할도 한다. GROUP BY와 ORDER BY가 포함된 지연된 조인으로 개선되기 전 쿼리는 모든 테이블들의 칼럼을 임시 테이블에 저장하고 GROUP BY를 해야 한다. 하지만 지연된 조인으로 개선된 쿼리는 테이블의 칼럼만 임시 테이블에 저장하고 GROUP BY를 수행하기 때문에 원래의 쿼리보다는 GROUP BY나 ORDER BY용 버퍼를 더 적게 필요로 한다.


## 래터럴 조인(Lateral Join)
MySQL 8.0 이전 버전까지는 그룹별로 몇 건씩만 가져오는 쿼리를 작성할 수가 없었다. 하지만 MySQL 8.0 버전부터는 **래터럴 조인이라는 기능을 이용해 특정 그룹별로 서브쿼리를 실행해서 그 결과와 조인하는 것이 가능**해졌다. 예를 들어, 다음 쿼리를 한번 살펴보자.

```sql
mysql> 	SELECT * FROM employees e 
		LEFT JOIN LATERAL 	(SELECT * FROM salaries s 
        					WHERE s.emp_no=e. emp_no 
                            ORDER BY s. from_date DESC 
                            LIMIT 2) s2 ON s2.emp_no=e.emp_no 
    WHERE e.first_name='Matt'; 
```

위의 쿼리는 employees 테이블에서 이름이 'Matt'인 사원에 대해 사원별로 가장 최근 급여 변경 내역 을 최대 2건씩만 반환한다. 래터럴 조인에서 가장 중요한 부분은 **FROM 절에 사용된 서브퀴리(Derived Table) 에서 외부 쿼리의 FROM 절에 정의된 테이블의 칼럼을 참조할 수 있다는 것**이다. 이 예제에서는 salaries 테이블을 읽는 서브쿼리에서 employees 테이블의 emp_no를 참조한다. 이렇게 FROM 절에 사용된 서브쿼리가 외부 쿼리의 칼럼을 참조하기 위해서는 "LATERAL" 키워드가 명시돼야 한다. LATERAL 키워드 없이 외부 쿼리의 칼럼을 참조하면 에러가 발생한다. 

LATERAL 키워드를 가진 서브쿼리는 조인 순서상 후순위로 밀리고, 외부 쿼리의 결과 레코드 단위로 임  테이블이 생성 되기 때문에 꼭 필요한 경우에만 사용해야 한다.

## 실행 계획으로 인한 정렬 흐트러짐
MySQL 8.0 이전 버전까지는 네스티드-루프 방식의 조인만 가능했지만 MySQL 8.0 버전부터는 해시 조인 방식이 도입됐다. 네스티드-루프 조인은 알고리즘의 특성상 드라이빙 테이블에서 읽은 레코드의 순서가 다른 테이블이 모두 조인돼도 그대로 유지된다. 그래서 MySQL에서 조인을 사용하는 쿼리의 결과는 드라이빙 테이블을 읽은 순서로 정렬된다고 생각할 때가 많다. 실제로도 주어진 조건에 의해 드라이빙 테이블을 인덱스 스캔이나 풀 테이블 스캔을 하고, 그때 드라이빙 테이블을 읽은 순서가 그대로 최종 결과에 반영된다. 

하지만 쿼리의 실행 계획에서 네스티드 루프 조인 대신 **해시 조인이 사용되면 쿼리 결과의 레코드 정렬 순서가 달라진다.** 해시 조인뿐만 아니라 MySQL 8.0 이전 버전에서 사용되던 블록 네스티드 루프 조인이 사용되는 경우도 동일하게 쿼리 결과의 정렬 순서가 드라이빙 테이블을 읽는 순서와 다르게 출력된다. 

실행 계획은 MySQL 옵티마이저에 의해 그때그때 상황에 따라 달라질 수 있다. 그러므로 정렬된 결과 가 필요한 경우라면 드라이빙 테이블의 순서에 의존하지 말고 **ORDER BY 절을 명시적으로 사용하는 것이 좋다**.

# GROUP BY
GROUP BY는 특정 칼럼의 값으로 레코드를 그루핑하고, 그룹별로 집계된 결과를 하나의 레코드로 조회할 때 사용한다. 
## WITH ROLLUP

GROUP BY가 사용된 쿼리에서는 그루핑된 그룹별로 소계를 가져올 수 있는 롤업(ROLLUP) 기능을 사용할 수 있다. ROLLUP으로 출력되는 소계는 단순히 최종 합만 가져오는 것이 아니라 GROUP BY에 사용된 칼럼의 개수에 따라 소계의 레벨이 달라진다.

```sql
mysql> 	SELECT dept_no, COUNT(*) 
		FROM dept_emp 
        GROUP BY dept_no WITH ROLLUP; 
```
WITH ROLLUP과 함께 사용된 GROUP BY 쿼리의 결과는 **그룹별로 소계를 출력하는 레코드가 추가되어 표시**된다. 소계 레코드의 칼럼값은 항상 NULL로 표시된다는 점에 주의해야 한다.

마지막의 총계는 first_name과 last_name 칼럼이 모두 NULL로 채워져 있다. 소계나 총계 레코드는 항상 해당 그룹의 마지막에 나타난다.

## 레코드를 칼럼으로 변환해서 조회 
GROUP BY나 집합 함수를 통해 레코드를 그루핑할 수 있지만 하나의 레코드를 여러 개의 칼럼으로 나누거나 변환하는 SQL 문법은 없다. 하지만 SUM()이나 COUNT() 같은 집합 함수와 CASE WHEN ... END 구문을 이용해 레코드를 칼럼으로 변환하거나 하나의 칼럼을 조건으로 구분해서 2개 이상의 칼럼으로 변환하는 것은 가능하다.

### 레코드를 칼럼으로 변환
1. GROUP BY 쿼리 결과를 SUM(CASE WHEN . ..) 구문을 사용해 한 번 더 변환
2. GROUP BY된 결과를 서브쿼리로 만든 후 SUM() 함수 적용 
3. 부서 번호의 순서대로 CASE WHEN 구문을 이용해 각 칼럼에서 필요한 값만 선별해서 SUM()

### 하나의 칼럼을 여러 칼럼으로 분리 


1. 조인된 결과를 테이블의 칼럼별로 GROUP BY를 실행
2. 그루핑된 정보에서 CASE WHEN으로 sum 함수 실행


이처럼 간단한 SQL 문장으로 상당히 많은 프로그램 코드를 줄일 수 있다. 그리고 이러한 형태의 퀴 리에 WITH ROLLUP 기능을 함께 사용한다면 더 유용한 결과를 만들어 낼 수 있을 것이다.

# ORDER BY 
ORDER BY는 검색된 레코드를 어떤 순서로 정렬할지 결정한다. ORDER BY 절이 사용되지 않으면 SELECT 쿼리의 결과는 어떤 순서로 정렬될까?

- 인덱스를 사용한 SELECT의 경우에는 인덱스에 정렬된 순서대로 레코드를 가져온다. 
- 인덱스를 사용하지 못하고 풀 테이블 스캔을 실행하는 SELECT를 가정해보자. MyISAM 테이블은 테이블에 저장된 순서대로 가져오는데, 이 순서가 정확히 INSERT된 순서는 아닐 수도 있다. 일반적으로 테이블의 레코드가 삭제되면 서 빈 공간이 생기고, INSERT되는 레코드는 항상 테이블의 마지막이 아니라 빈 공간이 있으면 그 빈 공간에 저장되 기 때문이다. InnoDB의 경우에는 항상 프라이머리 키로 클러스터링돼 있기 때문에 풀 테이블 스캔의 경우에는 기본 적으로 프라이머리 키 순서대로 레코드를 가져온다. 
- SELECT 쿼리가 임시 테이블을 거쳐 처리되면 조회되는 레코드의 순서를 예측하기는 어렵다. 

ORDER BY 절이 없는 SELECT 쿼리 결과의 순서는 처리 절차에 따라 달라질 수 있다. 어떤 DBMS도 ORDER BY 절이 명시되지 않은 쿼리에 대해서는 어떠한 정렬도 보장하지 않는다. 예를 들어, 인덱스를 사용한 SELECT 쿼리이기 때문에 ORDER BY 절을 사용하지 않아도 된다는 것은 잘못된 생각이다. 항상 정렬이 필요한 곳에서는 ORDER BY 절을 사용해야 한다.

ORDER BY에서 인덱스를 사용하지 못할 때는 추가 정렬 작업이 수행되며, 쿼리 실행 계획에 있는 Extra 칼럼에 "Using filesort"라는 코멘트가 표시된다. "filesort"라는 단어에 포함된 "file"은 디스크의 파일을 이용해 정렬을 수행한다는 의미가 아니라 **쿼리를 수행하는 도중에 MySQL 서버가 명시적으로 정렬 알고리즘을 수행했다는 의미 정도로 이해**하면 된다. **정렬 대상이 많은 경우에는 여러 부분으로 나눠서 처리하는데, 정렬된 결과를 임시로 디스크나 메모리에 저장해 둔다.** 실제로 메모리만 이용해 정렬이 수행됐는지 디스크의 파일을 이용했는지는 실행 계획을 통해서는 알 수 없지만 MySQL 서버의 상태 값 을 확인해보면 알 수 있다. 

```sql
mysql> SHOW STATUS LIKE 'Sort_%'; 
|Variable_name 		|Value			|
|Sort_merge_passes	|316			| 
|Sort_range 		|0				|
|Sort_rows 			|14257137		|
|Sort_scan			|27				| 
```
Sort_merge_passes 상태 값은 메모리의 버퍼(sort_buffer_size 시스템 변수로 설정되는 메모리 공간)와 디스크에 저장된 레코드를 몇 번이나 병합했는지를 보여준다. 이 상태 값이 0보다 크다면 이는 정렬해야 할 데이터가 정렬용 버퍼보다 커서 디스크를 이용했다는 것을 의미한다. Sort_range와 Sort_scan은 인덱스 레인지 스캔을 통해서 읽은 레코드를 정렬한 횟수와 풀 테이블 스캔을 통해서 읽은 레코드를 정렬한 횟수를 누적한 값이다. Sort_rows는 정렬을 수행했던 전체 레코드 건수의 누적된 값을 나타낸다. 

## ORDER BY 사용법 및 주의사항 
ORDER BY 절은 1개 또는 그 이상 여러 개의 칼럼으로 정렬을 수행할 수 있으며, 정렬 순서(오름차순, 내림차순)는 칼럼별로 다르게 명시할 수 있다. 일반적으로 정렬할 대상은 칼럼명이나 표현식으로 명시하지만 SELECT되는 칼럼의 순번을 명시할 수도 있다. 즉, "ORDER BY 2"라고 명시하면 SELECT되는 칼럼 중 에서 2번째 칼럼으로 정렬하라는 의미가 된다.

ORDER BY 뒤에 숫자 값이 아닌 문자열 상수를 사용하는 경우에는 옵티마이저가 ORDER BY 절 자체를 무시한다.

## 여러 방향으로 동시 정렬 
MySQL 8.0 이전 버전까지는 여러 개의 칼럼을 조합해서 정렬할 때 각 칼럼의 정렬 순서가 오름차순과 내림차순이 혼용되면 인덱스를 이용할 수 없다. 하지만 **MySQL 8.0 버전부터는 다음 예제와 같이 오름차순과 내림차순을 혼용해서 인덱스를 생성할 수 있게 개선**됐다. 
```sql
mysql> ALTER TABLE salaries ADD INDEX ix_salary_fromdate (salary DESC, from_date ASC);
```
오름차순과 내림차순을 혼용해서 정렬하고자 하는 경우에는 위 예제와 같이 ASC와 DESC 옵션을 섞어서 하나의 인덱스를 생성하면 된다.

다음 2개의 인덱스 중 하나만 있어도 옵티마이저는 위 쿼리가 적절히 인덱스를 이용해서 정렬할 수 있게 최적화할 수 있다. 하지만 쿼리가 내림차순으로만 레코드를 정렬해서 가져간다면 인덱스는 당연히 ix_salary_desc를 생성 하는 것이 좋다. 

## 함수나 표현식을 이용한 정렬 
하나 또는 여러 칼럼의 연산 결과를 이용해 정렬하는 것도 가능하다. MySQL 8.0 이전까지는 연산의 결과를 기준으로 정렬하기 위해서는 가상 칼럼(Virtual Column) 을 추가하고 인덱스를 생성하는 방법을 사용해야 했다. 하지만 MySQL 8.0 버전부터는 함수 기반의 인덱스를 지원하기 시작했다. 그래서 연산의 결괏값을 기준으로 정렬하는 작업이 인덱스를 사용하도록 튜닝하는 것이 가능해 졌다.

# 서브 쿼리
쿼리를 작성할 때 **서브쿼리를 사용하면 단위 처리별로 쿼리를 독립적으로 작성**할 수 있다. 조인처럼 여러 테이블을 섞어 두는 형태가 아니어서 쿼리의 가독성도 높아지며, 복잡한 쿼리도 손쉽게 작성할 수 있다. MySQL 5.6 버전까지는 서브쿼리를 최적으로 실행하지 못할 때가 많았지만 **MySQL 8.0 버전부터는 서브쿼리 처리가 많이 개선**됐다. 서브쿼리는 쿼리의 여러 위치에서 사용될 수 있는데, 대표적으로 SELECT 절과 FROM 절, WHERE 절에 사용될 수 있다. 하지만 사용되는 위치에 따라 쿼리의 성능 영향도와 MySQL 서버의 최적화 방법은 완전히 달라진다. 서브쿼리가 사용되는 위치별로 어떻게 최적화되는지, 그리고 어떻게 쿼리를 작성해야 성능에 도움이 될지를 살펴보자. 

## SELECT 절에 사용된 서브쿼리 
SELECT 절에 사용된 서브쿼리는 **내부적으로 임시 테이블을 만들거나 쿼리를 비효율적으로 실행하게  들지는 않기 때문에 서브쿼리가 적절히 인덱스를 사용할 수 있다면 크게 주의할 사항은 없다**. 일반적으로 SELECT 절에 서브쿼리를 사용하면 그 서브쿼리는 **항상 칼럼과 레코드가 하나인 결과를 반환**해야 한다. 그 값이 NULL이든 아니든 관계없이 레코드가 1건이 존재해야 한다는 것인데, MySQL에서는 이 체크 조건이 조금은 느슨하다.

위 예제의 각 쿼리에서 주의할 점을 살펴보자. 

- 첫쿼리에서 사용된 서브쿼리는 항상 결과가 0건이다. 하지만 쿼리는 에러를 발생하지 않고, 서브쿼리의 결과는 NULL로 채워져서 반환된다. 
- 쿼리에서 서브쿼리가 2건 이상의 레코드를 반환하는 경우에는 에러가 나면서 쿼리가 종료된다. 
-  SELECT 절에 사용된 서브쿼리가 2개 이상의 칼럼을 가져오려고 할 때 에러가 발생한다. 

즉, SELECT 절의 서브쿼리에는 로우 서브쿼리를 사용할 수 없고, 오로지 스칼라 서브쿼리만 사용할 수 있다.

> 서브쿼리는 만들어 내는 결과에 따라 스칼라 서브쿼리(Scalar subquery)와 로우 서브쿼리(Row 또는 Record, 매뉴얼에서는 "Row subquery"로 소개하고 있음)로 구분할 수 있다. 스칼라 서브쿼리는 레코드의 칼럼이 각각 하나인 결과를 만들어내는 서브쿼리며, 스칼라 서브쿼리보다 레코드 건수가 많거나 칼럼 수가 많은 결과를 만들어 내는 서브 쿼리를 로우 서브쿼리 또는 레코드 서브쿼리라고 한다. 


가끔 조인으로 처리해도 되는 쿼리를 SELECT 절의 서브쿼리를 사용해서 작성할 때도 있다. 하지만 서브 쿼리로 실행될 때보다** 조인으로 처리할 때가 조금 더 빠르기 때문에 가능하다면 조인으로 쿼리를 작성 하는 것이 좋다**. 처리해야 하는 레코드 건수가 많아지면 많아질수록 성능 차이가 커질 수도 있으므로 가능하면 조인으로 쿼리를 작성하는 방법을 권장한다.

## FROM 절에 사용된 서브쿼리 
이전 버전의 MySQL 서버에서는 FROM 절에 서브쿼리가 사용되면 항상 서브쿼리의 결과를 임시 테이블 로 저장하고 필요할 때 다시 임시 테이블을 읽는 방식으로 처리했다. 그래서 가능하면 FROM 절의 서브 외부 쿼리로 병합하는 형태로 쿼리 튜닝을 했다. 하지만** MySQL 5.7 버전부터는 옵티마이저가 FROM 절의 서브쿼리를 외부 쿼리로 병합하는 최적화를 수행하도록 개선**됐다. EXPLAIN 명령을 실행한 후 SHOW WARNINGS 명령을 실행 하면 MySQL 서버가 서브쿼리를 병합해서 재작성한 쿼리의 내용을 확인할 수 있다.

서브쿼리의 외부 쿼리 병합은 꼭 FROM 절의 서브쿼리에 대해서만 적용되는 최적화는 아니다. FROM 절에 사용된 뷰(View)의 경우에도 MySQL 옵티마이저는 뷰 쿼리와 외부 쿼리를 병합해서 최적화된 실행 계획을 사용한다.

FROM 절의 모든 서브쿼리를 외부 쿼리로 병합할 수 있는 것은 아니다. 대표적으로 다음과 같은 기능이 서브쿼리에 사용되면 FROM 절의 서브쿼리는 외부 쿼리로 병합되지 못한다. 

- 집합 함수 사용(SUM(), MIN(), MAX(), COUNT() 등) 
- DISTINCT 
- GROUP BY 또는 HAVING 
- LIMIT 
- UNION(UNION DISTINCT) 또는 UNION ALL 
- SELECT 절에 서브쿼리가 사용된 경우 
- 사용자 변수 사용(사용자 변수에 값이 할당되는 경우) 

외부 쿼리와 병합되는 FROM 절의 서브쿼리가 ORDER BY 절을 가진 경우에는 외부 쿼리가 GROUP BY나 DISTINCT 같은 기능을 사용하지 않는다면 서브쿼리의 정렬 조건을 외부 쿼리로 같이 병합한다. 외부 쿼리에서 GROUP BY나 DISTINCT와 같은 기능이 사용되고 있다면, **서브쿼리의 정렬 작업은 무의미하기 때문에 서브쿼리의 ORDER BY 절은 무시**된다.

MySQL 서버에서 FROM 절의 서브쿼리를 외부 쿼리로 병합하는 최적화는 optimizer_switch 시스템 변수로 제어할 수 있는데, 서브쿼리 병합에 대한 더 자세한 내용과 제어 방법은 '파생 테이블 머지(derived_merge)'를 참조하자. 

## WHERE 절에 사용된 서브쿼리 
WHERE 절의 서브쿼리는 SELECT 절이나 FROM 절보다는 다양한 형태(연산자)로 사용될 수 있는데, 크게 다음 3가지로 구분해서 살펴보겠다.

### 동등 또는 크다 작다 비교 
MySQL 5.5 이전 버전까지는 서브쿼리 외부의 조건으로 쿼리를 실행하고, 최종적으로 서브쿼리를 체크 조건으로 사용했다. 하지만 이러한 처리 방식의 경우 풀 테이블 스캔이 필요한 경우가 많아서 성능 저하가 심각했다. 

MySQL 5.5 버전부터는 이 쿼리의 실행 계획은 그 이전 버전과는 정반대로 실행되도록 개선됐다. 서브 쿼리를 먼저 실행한 후 상수로 변환한다. 그리고 상숫값으로 서브쿼리를 대체해서 나머지 쿼리 부분을 처리한다.

동등 비교 대신 크다 또는 작다 비교가 사용돼도 동일한 실행 계획을 사용한다. **단일 값 비교가 아닌 튜플 비교 방식이 사용되면 서브쿼리가 먼저 처리되어 상수화되긴 하지만 외부 쿼리는 인덱스를 사용하지 못하고 풀 테이블 스캔을 실행하는 것을 확인**할 수 있다. MySQL 8.0 버전이라고 하더라도 아직 튜플 형태의 비교는 주의해서 사용해야 한다.

### IN 비교 (IN subquery) 
실제 조인은 아니지만 다음 예제와 같이 테이블의 레코드가 다른 테이블의 레코드를 이용한 표현식(또는 칼럼 그 자체)과 일치하는지를 체크하는 형태를 세미 조인(Semi-Join)이라고 한다. 즉 **WHERE 절에 사용된 IN (subquery) 형태의 조건을 조인의 한 방식인 세미 조인이라고 보는 것**이다. 
```sql
mysql> 	SELECT * FROM employees e 
		WHERE e.emp_no 
        IN (	SELECT de.emp_no 
        		FROM dept_emp de 
                WHERE de.from_date='1995-01-01'); 
```
MySQL 5.5 버전까지는 세미 조인의 최적화가 매우 부족해서 대부분 풀 테이블 스캔을 했다. 그래서 이런 세미 조인 형태는 MySQL 서버에서 사용하면 안 되는 패턴으로 기억하는 사용자가 많을 것이다. 하지만 **MySQL 5.6 버전부터 8.0 버전까지 세미 조인의 최적화가 많이 개선되면서 이제 더 이상은 IN (subquery) 형태를 2개의 쿼리로 쪼개어 실행하거나 다른 우회 방법을 찾을 필요가 없어졌다.** MySQL 서버의 세미 조인 최적화는 쿼리 특성이나 조인 관계에 맞게 다음과 같이 5개의 최적화 전략을 선택적으로 사용한다. 

- 테이블 풀-아웃(Table Pull-out) 
- 퍼스트 매치(Firstmatch)
- 루스 스캔(Loosescan) 
- 구체화(Materialization) 
- 중복 제거(Duplicated Weed-out) 

MySQL 8.0을 사용한다면 세미 조인 최적화에 익숙해져야 한다. MySQL 8.0의 기능을 적극 활용해 개발 생산성을 높이는 방향을 추천한다. 

### NOT IN 비교 (NOT IN subquery) 
IN (subquery)와 비슷한 형태지만 이 경우를 안티 세미 조인(Anti Semi-Join)이라고 명명한다. 일반적인 RDBMS에서 Not-Equal 비교(<> 연산자)는 인덱스를 제대로 활용할 수 없듯이 안티 세미 조인 또한 최적화할 수 있는 방법이 많지 않다. MySQL 옵티마이저는 안티 세미 조인 쿼리가 사용되면 다음 두 가지 방법으로 최적화를 수행한다.

- NOT EXISTS 
- 구체화(Materialization)

두 가지 최적화 모두 그다지 성능 향상에 도움이 되지 않는 방법이므로 쿼리가 최대한 다른 조건을 활 용해서 데이터 검색 범위를 좁힐 수 있게 하는 것이 좋다. WHERE 절에 단독으로 안티 세미 조인 조건만 있다면 풀 테이블 스캔을 피할 수 없으니 주의하자.

# 잠금을 사용한 SELECT

InnoDB 테이블에 대해서는 레코드를 SELECT할 때 레코드에 아무런 잠금도 걸지 않는데, 이를 잠금 없는 읽기(Non Locking Consistent Read)라고 한다. 하지만 SELECT 쿼리를 이용해 읽은 레코드의 칼럼 값을 애플리케이션에서 가공해서 다시 업데이트하고자 할 때는 SELECT가 실행된 후 다른 트랜잭션이 그 칼럼의 값을 변경하지 못하게 해야 한다. 이럴 때는 레코드를 읽으면서 강제로 잠금을 걸어둘 필요가 있는데, 이때 사용하는 옵션이 FOR SHARE와 FOR UPDATE이다. 

- FOR SHARE: SELECT 쿼리로 읽은 레코드에 대해서 읽기 잠금을 걸고, 
- FOR UPDATE: SELECT 쿼리가 읽은 레코드에 대해서 쓰기 잠금을 건다. 


> MySQL 8.0 이전 버전에서는 SELECT로 읽은 레코드에 대해서 읽기 잠금을 위해 LOCK IN SHARE MODE 을 사용했지만, MySQL 8.0 버전부터는 FOR SHARE로 변경됐다. 물론 MySQL 8.0 버전에서 여전히 LOCK IN SHARE MODE 문법을 지원하지만, 이는 이전 버전과의 호환성 차원에서 지원되는 것이므로 가능하다면 LOCK IN SHARE MODE보다는 FOR SHARE 절을 사용하는 것을 권장한다. 또한 MySQL 8.0 버전부터는 SELECT 쿼리의 잠금을 위해 여 러 가지 새로운 기능을 제공하는데, 이 가능을 제대로 활용하려면 FOR SHARE와 FOR UPDATE 절을 사용해야 한다. 

이 두 가지 잠금 옵션은 모두 자동 커밋(AUTO-COMMIT)이 **비활성화(OFF)된 상태 또는 BEGIN 명령이나 START TRANSACTION 명령으로 트랜잭션이 시작된 상태에서만 잠금이 유지**된다. 

- FOR SHARE: SELECT된 레코드에 대해 읽기 잠금(공유 잠금, Shared lock)을 설정하고 다른 세션에서 해당 레코드를 변경하지 못하게 한다. 물론 다른 세션에서 잠금이 걸린 레코드를 읽는 것은 가능하다. 
- FOR UPDATE: 쓰기 잠금(배타 잠금, Exclusive lock)을 설정하고, 다른 트랜잭션에서는 그 레코드를 변경하는 것뿐만 아니라 읽기(FOR SHARE 절을 사용하는 SELECT 쿼리)도 수행할 수 없다.

## 주의 사항
한 가지 주의할 사항은 FOR UPDATE나 FOR SHARE 절을 가지지 않는 SELECT 쿼리의 작동 방식이다. InnoDB 스토리지 엔진을 사용하는 테이블에서는 잠금 없는 읽기가 지원되기 때문에 특정 레코드가 "SELECT ... FOR UPDATE" 쿼리에 의해서 잠겨진 상태라 하더라도 FOR SHARE나 FOR UPDATE 절을 가지지 않은 **단순 SELECT 쿼리는 아무런 대기 없이 실행**된다. 다음 표는 간단히 예제로 잠금 대기 여부를 시간 순서대로 나열해본 것이다. 

### 잠금 대기하지 않는 경우

|세션-1 |세션-2 |
|---|---|
|BEGIN;|| 
|SELECT * FROM employees WHERE emp_no=10001 FOR UPDATE; ||
||SELECT *  FROM employees WHERE emp_no=10001; => 잠금 대기 없이 즉시 결과 반환|

### 잠금 대기하는 경우 

|세션-1 |세션-2|
|---|---|
|BEGIN; SELECT * FROM employees WHERE emp_no=10001 FOR UPDATE;||
||SELECT * FROM employees WHERE emp_no=10001 FOR SHARE; 세션-1의 잠금을 기다림|
|COMMIT;||
||=> SELECT 쿼리 결과 반환|

## 잠금 테이블 선택 
3개의 테이블을 조인해서 읽으면서 FOR UPDATE 절을 사용하면, InnoDB 스토리지 엔진은 3개 테이블에서 **읽은 레코드에 대해 모두 쓰기 잠금 (Exclusive Lock)을 걸게 된다**. 그런데 특정 테이블은 그냥 참고용으로만 읽고, 실제 쓰기 잠금은 일부 테이블에만 걸고 싶다면 어떻게 해야 할까? MySQL 8.0 이전 버전에서는 선택적으로 잠금을 걸 수 있는 옵션이 없었지만 **MySQL 8.0 버전부터는 다음과 같이 잠금을 걸 테이블을 선택할 수 있도록 기능이 개선**됐다. FOR UPDATE 뒤에 "OF 테이블" 절을 추가 하면 해당 테이블에 대해서만 잠금을 걸게 된다. 테이블에 대해 별명(Alias)이 사용된 경우에는 별명을 명시해야 한다. SELECT 쿼리에 사용된 테이블 중에서 특정 테이블만 잠금을 획득하는 옵션은 FOR UPDATE 와 FOR SHARE 절 모두 적용할 수 있다. 
```sql
mysql> 	SELECT * FROM employees e 
		INNER JOIN dept_emp de ON de.emp_no=e.emp_no 
		INNER JOIN departments d ON d.dept_no=de.dept_no 
		WHERE e.emp_no=10001 FOR UPDATE OF e; 
```
## NOWAIT & SKIP LOCKED 

### NOWAIT
MySQL 8.0 버전부터는 NOWAIT과 SKIP LOCKED 옵션을 사용할 수 있게 기능이 추가됐다. 지금까지의 MySQL 잠금은 누군가가 레코드를 잠그고 있다면 다른 트랜잭션은 그 잠금이 해제될 때까지 기다려야 했다. 때로는 일정 시간이 지나야 잠금 획득 실패 에러 메시지를 받아야 했다.

먼저 실행된 트랜잭션이 테이블의 특정 레코드에 대해서 변경 작업을 장시간 수행하고 있다면 SELECT FOR UPDATE 구문은 선행 트랜잭션이 완료될 때까지 기다려야 한다. 또는 `innodb_lock_wait_timeout` 시스템 변수에 설정된 시간(기본적으로 50초) 동안 기다렸다가 에러 메시지를 받게 될 것이다. 그런데 애**플리케이션의 어떤 기능에서는 해당 레코드가 이미 잠겨진 상태라면 그냥 무시하고 즉시 에러를 반환하면 응용 프로그램에서 다른 처리를 수행하거나 다시 트랜잭션을 시작하도록 구현해야 할 때도 있다.** 이럴 때 SELECT 쿼리의 마지막에 NOWAIT 옵션을 사용하면 된다. FOR UPDATE나 FOR SHARE 절이 없는 SELECT 쿼리는 잠금 대기 자체가 없기 때문에 NOWAIT 옵션을 사용하는 것은 의미가 없다. 

**NOWAIT 옵션을 사용하면 SELECT 쿼리가 해당 레코드에 대해 즉시 잠금을 획득했다면 NOWAIT 옵션이 없을 때와 동일하게 실행된다. 하지만 해당 레코드가 다른 트랜잭션에 의해서 잠겨진 상태라면 다음과 같이 에러를 반환하면서 쿼리는 즉시 종료된다. **


### SKIP LOCKED 
SKIP LOCKED 옵션은 SELECT하려는 레코드가 다른 트랜잭션에 의해 이미 잠겨진 상태라면** 에러를 반환하지 않고 잠긴 레코드는 무시하고 잠금이 걸리지 않은 레코드만 가져온다.** 

FOR UPDATE 절 없이 그냥 실행했을 때는 선행 트랜잭션이 조회한 레코드와 동일 한 레코드를 반환한 것을 확인할 수 있다. 하지만 동일한 SELECT 쿼리에 FOR UPDATE SKIP LOCKED 절을 추가하면 MySQL 서버는 잠그고 있는 레코드는 무시 (SKIP LOCKED)하고 그다음 레코드를 반환한다. 이런 이유로 SKIP LOCKED 절을 가진 SELECT 구문은 확정적이지 않은(NOT-DETERMINISTIC) 쿼리가 된다. 

> "확정적(DETERMINISTIC)"이란 말의 의미는 입력이 동일하면 시점에 관계없이 동일한 결과를 반환하는 것을 의미한다. 하지만 SKIP LOCKED 절을 가진 SELECT 쿼리는 실행하는 시점에 따라(아무런 데이터 변경이 없는 상태에서 도) 각 트랜잭션의 간섭에 의해 다른 결과를 반환할 수도 있는데, 이를 비확정적(NOT-DETERMINISTIC)이라고 한다. 이렇게 비확정적인 쿼리는 문장(STATEMENT) 기반의 복제에서 소스 서버와 레플리카 서버의 데이터를 다르게 만들 수도 있다. 그래서 가능하면 복제의 바이너리 로그 포맷으로 STATEMENT보다는 ROW 또는 MIXED를 사용하자.


## NOWAIT과 SKIP LOCKED 활용
NOWAIT이나 SKIP LOCKED 기능은 큐(Queue)와 같은 기능을 MySQL 서버에서 구현하고자 할 때 매우 유용하다.

예를 들어, 다음과 같은 간단한 요건을 가지는 쿠폰 발급 기능을 한번 생각해보자.

- 하나의 쿠폰은 한 사용자만 사용 가능하다. 
- 쿠폰의 개수는 1000개 제한이며, 선착순으로 요청한 사용자에게 발급한다. 

일반적으로 이 같은 요건을 처리하기 위해 다음과 같은 테이블을 생성했다. 
```sql
CREATE TABLE coupon ( 
	coupon_id BIGINT NOT NULL, 
    owned_user_id BIGINT NULL DEFAULT θ, /* 쿠폰이 발급되면 소유한 사용자의 id를 저장 */ 
    coupon_code VARCHAR(15) NOT NULL,
    ...
    PRIMARY KEY (coupon_id), 
    INDEX ix_owneduserid (owned_user_id) 
); 
```
그리고 응용 프로그램에서는 다음과 같은 절차를 거쳐 쿠폰을 발급하게 될 것이다. 응용 프로그램 코드에서는 우선 아직 주인이 없는(owned_user_id=0) 쿠폰을 검색해서 하나를 가져온다. 이때 다른 트랜잭션에서 해당 쿠폰을 가져가지 못하게 FOR UPDATE 절을 사용했다. 
```
mysql> BEGIN; 
mysql> 	SELECT * FROM coupon 
		WHERE owned_user_id=0 
        ORDER BY coupon_id ASC 
        LIMIT 1 FOR UPDATE; 
... 응용 프로그램 연산 수행 
mysql> UPDATE coupon SET owned_user_id=? WHERE coupon_id=?; 
mysql> COMMIT; 
```
많은 사용자가 이미 경험했겠지만 많은 사용자에게 인기 있는 쿠폰이라면 애플리케이션 서버는 단번에 응답 불능 상태가 될 것이다. 

1. 동시에 1000명의 사용자가 쿠폰을 요청
2. 애플리케이션 서버는 그 요청만큼 프로세스를 생성해서 위의 트랜잭션을 동시 실행
3. 각 트랜잭션에서 실행하는 SELECT ... FOR UPDATE 쿼리는 coupon 테이블에서 하나의 레코드로 집중해서 잠금 획득
4. 처음으로 잠금을 획득하는 트랜잭션을 제외하고 **나머지 999개의 트랜잭션은 첫 번째 트랜잭션이 작업을 끝내고 COMMIT할 때까지 대기**
5. 두 번째와 세 번째, 네 번째 순으로 트랜잭션이 하나씩 실행
6. 트랜잭션의 처리 속도에 따라 일정 시점 이후 트랜잭션은 대기 시간(innodb_look_wait_timeout 시스템 변수에 설정된 시간) 동안 잠금을 획득하지 못해서 결국 에러 반환

SELECT 쿼리의 "ORDER BY coupon_id" 때문에 이렇게 모든 트랜잭션이 하나의 레코드로 집중된다고 생각할 수도 있다. 하지만 **DBMS 서버는 쿼리의 실행이 항상 실행 계획을 기반으로 수행되기 때문에 ORDER BY 절과 무관하게 (ORDER BY 절이 있든 없든) 모든 트랜잭션은 항상 순서대로 레코드를 읽을 것**이다. 이 예제에서 ORDER BY 절은 별 도의 정렬을 필요로 하지도 않고, 쿼리 실행 시에는 그냥 ix_owneduserid 인덱스를 순서대로 읽기 때문에 이로 인해 서 쿼리의 성능이 떨어지지는 않는다. 

### FOR UPDATE SKIP LOCKED
MySQL 8.0 이전 버전에서는 이런 문제를 해결하기 위해 레디스(Redis)나 멤캐시(Memcached) 같 은 캐시 솔루션을 별도로 구축해서 쿠폰 발급 기능을 구현했다. 하지만 MySQL 8.0 버전부터는 FOR UPDATE SKIP LOCKED 절을 사용하면 **트랜잭션이 수행되는 데 걸리는 시간과 관계없이 다른 트랜잭션에 의해서 이미 사용 중인(잠겨진) 레코드를 스킵하는 시간만 지나면 각자의 트랜잭션을 실행할 수 있다**. 이 예제에서는 1000개의 쿠폰을 가정했는데, MySQL 서버에서 1000건의(가장 마지막 트랜잭션이 잠금을 획득하기 위해 스킵해야 할 레코드 건수) 레코드를 스캔하는 데 걸리는 시간은 매우 짧다. 그래서 **FOR UPDATE SKIP LOCKED 절을 사용한다면 실제 MySQL 서버에서는 1000개의 트랜잭션을 동시에 처리 하게 되는 효과를 얻을 수도 있다**. 그림 11.11과 그림 11.12는 SKIP LOCKED를 사용한 경우와 그러지 않은 경우의 동시 처리 및 스루풋 비교를 보여준다.

![](https://velog.velcdn.com/images/chocochip/post/568755ca-5a81-4bdb-8832-b1f08ebaad05/image.png)

![](https://velog.velcdn.com/images/chocochip/post/727f38ce-6f93-4bc6-a41c-a49524175620/image.png)



"A"로 표시된 선의 길이는 하나의 트랜잭션이 처리되는 데 걸리는 시간을 의미하고, 그림 11.12에서 "B"로 표시된 선의 길이는 잠겨진 레코드 1건을 스킵(SKIP LOCKED)하는 데 걸린 시간을 의미한다. 이해를 돕기 위해 B의 길이(잠겨진 레코드 1건을 스킵하는 데 걸린 시간 를 길게 표시했지만 실제 MySQL 서버에서 레코드 1건을 읽는 데 걸리는 시간은 매우 짧은 시간일 것이다. 

그림 11.12에서 보다시피 FOR UPDATE SKIP LOCKED는 MySQL 서버로 동시에 유입된 트랜잭션들이 대기 시간 없이 잠긴 레코드를 스킵하고 사용 가능한 레코드를 찾기만 하면 즉시 트랜잭션 처리를 시작할 수 있다. 하지만 그림 11.11에서는 SKIP LOCKED 절 없이 FOR UPDATE만 사용한 경우에는 동시에 유입된 트랜잭션이 모두 잠금 대기를 하고 있다가 첫 번째 레코드를 잠근 트랜잭션이 완료돼야 비로소 두 번째 트랜잭션이 시작될 수 있고, 세 번째 트랜잭션은 두 번째 트랜잭션이 완료돼야 시작될 수 있다. 그래서 그림 11.11에서는 겨우 3개 트랜잭션만 완료되고 나머지 트랜잭션들은 아직도 대기 중인 상태로 남아 있는 것이다. 아무리 MySQL 서버가 많은 CPU와 메모리를 가지고 있다고 하더라도 이렇게 처리가 순차적(Serialization)으로 처리되면 서버의 남는 자원을 제대로 활용하지 못한다. 

주의 많은 프로젝트에서 자신의 애플리케이션이 겪는 문제의 원인을 제대로 분석하지 못하고, 애플리케이션 코드는 그대로 놔두고 MySQL 서버가 느려서 트랜잭션이 느려진다고들 한다. 그러고는 MySQL 서버의 메모리와 CPU, 디스크의 성능만 계속 높이는 경우도 있다. 서비스 처리 지연이 발생하면 항상 병목 지점을 정확히 찾고 원인을 분석해서 그에 맞는 해결책을 사용해야 한다.

NOWAIT과 SKIP LOCKED 절은 SELECT ... FOR UPDATE 구문에서만 사용할 수 있으며, 당연히 UPDATE나 DELETE 쿼리에서는 사용할 수 없다. 그런데 왜 UPDATE나 DELETE에는 NOWAIT과 SKIP LOCKED를 사용하지 못 하게 막아뒀을까? NOWAIT과 SKIP LOCKED 절은 쿼리 자체를 비확정적으로 만들기 때문에 NOWAIT이나 SKIP LOCKED가 UPDATE나 DELETE 문장에서 사용된다면 실행될 때마다 데이터베이스의 상태를 다른 결과로 만들게 된다. 즉 UPDATE나 DELETE 문장이 정상적으로 실행됐지만 어떤 레코드가 업데이트되거나 삭제됐는지 알 수 없게 되는 것이다. 이는 사용자들을 혼란에 빠뜨리게 될 것이다. 또한 MySQL 서버의 복제에 서는 더 큰 문제를 일으킬 수도 있다.