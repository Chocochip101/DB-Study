MySQL에서는 소스 서버와 레플리카 서버 간의 복제 동기화에 대해 두 가지 방식을 제공한다. 하나는 오래전부터 사용돼온 비동기 복제 방식이며, 다른 하나는 MySQL 5.5버전부터 도입된 반동기 복제 방식이다.

# 비동기 복제

MySQL 복제는 기본적으로 비동기 방식으로 동작한다. 비동기 방식이란 소스 서버가 레플리카 서버에서 변경 이벤트가 정상적으로 적용됐는지를 확인하지 않는 방식이다.

![](https://velog.velcdn.com/images/chocochip/post/57b9d3d1-d506-4e78-8592-914963d4646c/image.png)

소스 서버에서 커밋된 트랜잭션은 바이너리 로그에 기록되면, 레플리카 서버에서는 주기적으로 신규 트랜잭션에 대한 바이너리 로그를 소스 서버에 요청한다.

소스 서버에서 커밋된 트랜잭션은 바이너리 로그에 기록되며, 레플리카 서버에서는 주기적으로 신규 트랜잭션에 대한 바이너리 로그를 소스 서버에 요청한다. 비동기 복제 방식에서 소스 서버는 레플리카 서버로 변경 이벤트가 잘 전달됐는지, 실제로 적용됐는지 알지 못하며 이에 대한 어떠한 보장도 하지 않는다. 이로 인해 소스 서버에 장애가 발생하면 소스 서버에서 최근까지 적용된 트랜잭션이 레플리카 서버로 전송되지 않을 수 있다. 즉, 누락된 트랜잭션이 존재하게 되는 것이다. 따라서 만약 소스 서버 장애로 인해 레플리카 서버를 새로운 소스 서버로 승격시키는 경우 사용자는 이 레플리카 서버가 소스 서버로부터 전달받지 못한 트랜잭션이 있는지 직접 확인하고 그런 것들이 있다면 필요 시 레플리카 서 버에 수동으로 다시 적용해야 한다.

이처럼 비동기 복제는 소스 서버가 레플리카 서버의 동기화 여부를 보장하지 않는다는 것이 가장 큰 단점이지만 소스 서버가 각 트랜잭션에 대해 레플리카 서버로 전송되는 부분을 고려하지 않기 때문에 **트랜잭션 처리에 있어서도 좀 더 빠른 성능**을 보이고, 아울러 **레플리카 서버에 문제가 생기더라도 소스 서버는 아무런 영향도 받지 않는다는 장점**이 있다. 
비동기 복제 방식은 소스 서버에 레플리카 서버를 여러 대 연결한다 해도 소스 서버에서 큰 성능 저하가 없으므로(물론 10대 이상 연결하는 경우 소스 서버에도 성능 저하가 있을 수 있다) 레플리카 서버를 확장해서 읽기 트래픽을 분산하는 용도로 제격이라 할 수 있다. 또한 레플리카 서버에 무거운 퀴리가 실행되어 성능 저하가 있다고 하더라도 소스 서버와는 무관한 일이므로 분석 용도 등으로 사용하기에도 적합하다. 

## Replication Lag
비동기 복제에서는 사용자가 소스 서버에서 데이터를 변경한 후 바로 레플리카 서버에서 해당 데이터를 확인 했을 때 변경 전 데이터가 보여질 수도 있다. 그러나 일반적으로 특별한 문제가 없다면 소스 서버에서 실행된 쿼리는 2~300ms(MySQL 서버의 처리 성능이나 네트워크 속도에 따라서 가변적이긴 하지만) 이내의 짧은 시간 내에 레플리카 서버에도 적용된다. 따라서 서비스에서 직접적으로 사용되는 읽기 쿼리를 레플리카 서버에서 실행한다 하더라도 큰 문제는 없다고 볼 수 있다. 다만 즉각적으로 반영된 데이터를 조회해야하는 민감한 경우에는 레플리카 서버보다는 소스 서버에서 직접 데이터를 읽어가도록 구현하는 것이 좋다. 
# 반동기 복제
반동기 복제는 비동기 복제보다 좀 더 향상된 데이터 무결성을 제공하는 복제 동기화 방식으로, 반동기 복제에서 소스 서버는 레플리카 서버가 소스 서버로부터 전달받은 변경 이벤트를 릴레이 로그에 기록 후 응답(ACK)을 보내면 그때 트랜잭션을 완전히 커밋시키고 클라이언트에 결과를 반환한다. 따라서 반동기 복제에서는 소스 서버에서 커밋되어 정상적으로 결과가 반환된 모든 트랜잭션들에 대해 적어도 하나의 레플리카 서버에는 해당 트랜잭션들이 전송됐음을 보장한다. 하지만 여기서 **중요한 부분은 바로 레플리카 서버에 "전송"됐음을 보장한다는 것이지, 실제로 복제된 트랜잭션이 레플리카 서버에 "적용"되는 것까지 보장한다는 것**은 아니다. 그래서 이 동기화 방식의 이름이 반동기인 것이다. 반동기 복제에서는 소스 서버가 트랜잭션 처리 중 어느 지점에서 레플리카 서버의 응답(ACK)을 기다리느냐에 따라 소스 서버에서 장애가 발생했을 때 사용자가 겪을 수 있는 문제 상황이 조금 다를 수 있다. 

사용자는 `rpl_semi_sync_master_wait_point` 시스템 변수를 통해 소스 서버가 레플리카 서버의 응답 을 기다리는 지점을 제어할 수 있으며, 시스템 변수에는 AFTER_SYNC 또는 AFTER_COMMIT 값으로 설정 가능하다. 각 설정 값에 따른 반동기 복제 방식을 그림과 함께 살펴보겠다. AFTER_SYNC로 설정된 경우 소스 서버에서는 각 트랜잭션을 바이너리 로그에 기록하고 난 후 스토리지 엔진에 커밋하기 전 단계에서 레플리카 서버의 응답을 기다리게 된다. 레플리카 서버로부터 정상적으로 응답이 내려오면 소스 서버는 그때 스토리지 엔진을 커밋해서 트랜잭션에 대한 처리를 완전히 끝내 고 트랜잭션을 실행한 클라이언트에 그 처리 결과를 반환한다.

![](https://velog.velcdn.com/images/chocochip/post/069bb5af-e6b4-4945-8407-8bab305feebe/image.png)


![](https://velog.velcdn.com/images/chocochip/post/1f5b0642-3bcd-44a0-b082-30f61aaa35e3/image.png)

AFTER_COMMIT으로 설정된 경우에는 소스 서버에서 트랜잭션을 바이너리 로그에 기록하고 스토리지 엔진에서의 커밋도 진행하고 나서 최종적으로 클라이언트에 결과를 반환하기 전에 레플리카 서버의 응답을 기다린다. 레플리카 서버로부터 응답이 내려오면 그때 클라이언트는 처리 결과를 얻고 그다음 쿼리를 실행할 수 있게 된다. 처음 반동기 복제가 도입됐을 때는 스토리지 엔진 커밋까지 완료 후 대기하는 AFTER_COMMIT 방식으로만 동작했었다. 이후 MySQL 5.7 버전에서 AFTER_SYNC 방식이 새로 도입됐으며, 현재 MySQL 8.0 버전에 서 기본적으로 설정된 동작 방식은 AFTER_SYNC다. AFTER_SYNC 방식은 AFTER_COMMIT 방식과 비교해서 다음과 같은 장점이 있다. 

- 소스 서버에 장애가 발생했을 때 팬텀 리드(Phantom Read)가 발생하지 않음 
- 장애가 발생한 소스 서버에 대해 좀 더 수월하게 복구 처리가 가능

AFTER_COMMIT에서는 트랜잭션이 스토리지 엔진 커밋까지 처리된 후 레플리카 서버의 응답을 기다리는데, 이처럼 스토리지 엔진 커밋까지 완료된 데이터는 다른 세션에서도 조회가 가능하다. 이로 인해 소스 서버가 어떤 트랜잭션에 대해 스토리지 엔진 커밋 후 레플리카 서버로부터 아직 응답을 기다리고 있는 상황에서 소스 서버에 장애가 발생한 경우, 사용자는 이후 새로운 소스 서버로 승격된 레플리카 서버에서 데이터를 조회할 때 자신이 이전 소스 서버에서 조회했던 데이터를 보지 못할 수도 있다. 이 같은 현상을 팬텀 리드(Phantom Read)라고 한다. AFTER_SYNC에서는 스토리지 엔진 커밋 전에 레플리카 서버의 응답을 기다리므로 응답을 기다리던 중에 소스 서버에 장애가 발생하더라도 사용자는 팬텀 리드 현상을 겪지 않게 된다. 또한 이처럼 소스 서버에서 커밋됐으나 레플리카 서버로 복제는 되지 않은 상황에서 장애가 발생한 소스 서버를 재사용하는 경우, AFTER_COMMIT 방식에서는 사용자가 수동으로 그러한 트랜잭션들을 롤백시켜야 했다. 그러나 AFTER_SYNC 방식에서는 레플리카 서버에 복제되지 않았지 만 소스 서버에는 커밋되어 실제 데이터에 반영된 트랜잭션들이 존재하는 경우가 발생하지 않으므로 사용자는 앞서 언급한 롤백 처리를 할 필요가 없다. 따라서 AFTER_SYNC는 AFTER_COMMIT보다 좀 더 데이 터 무결성이 강화된 방식이라고 할 수 있다. 주의 반동기 복제라 하더라도 소스 서버에 장애가 발생했을 때 소스 서버의 데이터와 레플리카 서버의 데이터가 달라 지는 경우가 발생할 수 있으므로 웬만해서는 장애가 발생한 소스 서버를 바로 재사용하지 않는 것이 좋다. 안전하게 재 사용하기 위해서는 장애가 발생한 시점에 유입된 트랜잭션들에 대해 소스 서버와 레플리카 서버에서 반영 여부를 수 동으로 확인해야 하는데, 만약 유입된 트랜잭션의 수가 많다면 이를 제대로 확인하는 것은 거의 불가능에 가깝다. 따라 서 소스 서버를 바로 재사용하기보다는 백업된 데이터로 새로 구축해 사용하는 것이 좋다. 반동기 복제는 트랜잭션을 처리하는 중에 레플리카 서버의 응답을 기다리므로 비동기 방식과 비교했 을 때 트랜잭션의 처리 속도가 더 느릴 수 있다. 최소 레플리카 서버로 응답을 요청하고 전달받기까지 의 네트워크 왕복 시간만큼 더 걸린다고 할 수 있으며, 만약 레플리카 서버에서 응답이 늦어지는 경우 그만큼 트랜잭션 처리가 더 지연될 수 있다. 이처럼 네트워크로 통신하는 부분으로 인해 반동기 복제는 물리적으로 가깝게 위치한 레플리카 서버와의 복제에 더 적합하다고 할 수 있다. 물론 소스 서버에서 레플리카 서버의 응답을 무기한적으로 기다리는 것은 아니다. 사용자는 이와 관련해 타임아웃 시간을 설정할 수 있으며, 소스 서버는 지정된 타임아웃 시간 동안 레플리카 서버의 응답이 없으면 자동으로 비동기 복제 방식으로 전환한다. 또한 소스 서버에 여러 대의 레플리카 서버가 복제 연결돼 있을 때 반 드시 연결된 전체 레플리카 서버의 응답을 기다려야 하는 것은 아니며, 이 또한 사용자가 응답을 받아 야 하는 레플리카 서버 수를 설정할 수 있다.

## 반동기 복제 설정 방법 
MySQL 서버에서 반동기 복제 기능은 플러그인 형태로 구현돼 있으므로 이를 사용하려면 먼저 관련 플러그인이 설치돼 있어야 한다. 플러그인은 현재 구동 중인 MySQL 서버에서 동적으로 설치 가능하 며, 소스 서버와 레플리카 서버에 다음과 같이 플러그인 설치 명령을 실행한다. 두 명령어를 소스 서버 와 레플리카 서버에서 모두 실행해도 무방하다. 
```sql
-- // 소스 서버 
mysql_Source> INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so'; 
--// 레플리카 서버 
mysql_Replica> INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so'; 
```

플러그인이 정상적으로 설치됐는지는 information_schema.PLUGINS 테이블을 조회하거나 SHOW PLUGINS 명령을 통해 확인할 수 있다.

플러그인이 설치됐다고 해서 자동으로 반동기 복제가 활성화되는 것은 아니다. 사용자는 반동기 복제 사용을 위해 관련 시스템 변수들을 적절히 설정해야 하는데, 이 시스템 변수들은 플러그인이 정상적으 로 설치된 이후에 SHOW GLOBAL VARIABLES 명령 등에서 확인할 수 있다. 반동기 복제와 관련된 MySQL의 시스템 변수들은 다음과 같다. rpl_semi_sync_master_enabled 소스 서버에서 반동기 복제의 활성화 여부를 제어한다. ON(1) 또는 OFF (0)로 설정 가능하다. rpl_semi_sync_mas ter_timeout 소스 서버에서 레플리카 서버의 응답이 올 때까지 대기하는 시간으로, 밀리초 단위로 설정할 수 있다. 소스 서버는 이 변수에 지정된 시간만큼 레플리카 서버의 응답을 기다렸다가 만약 지정된 시간이 초과할 때까지 응답이 오지 않 으면 비동기 복제로 전환된다. 기본값은 10000(10초)이다. · rpl_semi_sync__master_trace_level 소스 서버에서 반동기 복제에 대해 디버깅 시 어느 정도 수준으로 디버그 로그가 출력되게 할 것인지 디버깅 추적 레벨을 지정하는 설정으로, 1. 16, 32,64 값으로 설정 가능하다. ■ rpl_semi_sync_master__wait__for_slave_count 스 서버에서 반드시 응답을 받아야 하는 레플리카 수를 결정한다. 기본값은 1이며, 최대 65535까지 설정 가능하 다. 응답을 받아야 하는 레플리카 수가 많을수록 소스 서버에서의 처리 성능은 저하될 수 있다.

- rpl_semi_sync_mas: ter_wait_no_slave rpl_semi_sync_master_wait_for_slave_count에 지정된 수보다 적어졌을 때 어떻게 처리할 것인지를 결정하는 변수로, ON (1)이면 레플리카 수가 적어지더라도 타임아웃 시간 동안 반동기 복제를 그대로 유지한다. OFF(0)로 설 정된 경우에는 레플리카 수가 적어지는 즉시 비동기 복제로 전환된다. 기본값은 ON이다. 소스 서버에 반동기 복제로 연결된 레플리카 서버 수는 SHOW GLOBAL STATUS 명령문의 결과에서 rpl_semi_sync_master_clients 상태 변수 를 통해 확인할 수 있다. 
- rpl_semi_sync_master_wait_point: 소스 서버가 트랜잭션 처리 단계 중 레플리카 서버의 응답을 대기하는 지점을 설정하는 옵션이다. AFTER_SYNC와 AFTER_COMMIT 값으로 설정 가능하며, 기본값은 AFTER_SYNC다. 
- rpl_semi_sync_slave_enabled: 레플리카 서버에서 반동기 복제의 활성화 여부를 제어한다. ON(1) 또는 OFF(0)로 설정 가능하다. 
- rpl_semi_sync_slave_trace_level: 레플리카 서버에서 반동기 복제에 대해 디버깅 시 어느 정도 수준으로 디버그 로그가 출력되게 할 것인지를 지정하 는 디버깅 추적 레벨에 대한 설정으로, 1. 16. 32. 64 값으로 설정 가능하다. 

주의 MySQL 5.7.2 버전에서 AFTER_SYNC 방식이 새로 도입되면서 rpl_semi_sync_master_wait_point 시스템 변수도 새로 추가된 것인데, 이로 인해 반동기 복제에 대한 인터페이스 버전이 증가됐다. 따라서 MySQL 5.7.2 버전보 다 낮은 버전의 MySQL 서버와 MySQL 5.7.2 버전 이상의 MySQL 서버 간에는 반동기 복제가 제대로 동작하지 않음 을 유의하자. 이제 반동기 복제 활성화를 위해 소스 서버와 레플리카 서버에서 다음과 같이 변수들을 설정해보자. rpl_semi_sync_master* timeout에는 사용자가 자신의 필요에 맞는 적절한 값을 설정하면 된다. -- // 소스 서버 SET GLOBAL rpl_semi_sync_master_enabled = 1; SET GLOBAL rpl_semi_sync_master__timeout = 5000; -- // 레플리카 서버 SET GLOBAL rpl_semi_sync__slave_enabled = 1; 

rpl_semi_s)nc_master_ timeout에 지정된 시간 동안 소스 서버에서 반동기 복제로 연결된 레플리카 서버 수가

설정 후 각 서버에서 SHOW GLOBAL VARIABLES 명령을 실행해 적용된 값들을 확인할 수 있다. mysql_Source> SHOW GLOBAL VARIABLES LIKE '%semi_sync_master%'; Variable_name I Value I rpl_semi_sync__master_enabled : ON rpl_semi_sync_master_timeout 1 5000 rpl_semi_sync_master_trace_level : 32 rpl_semi_sync_master_wait_for_slave_count I 1 rpl_semi_sync_master_wai t_no_slave ON rpl_semi_sync,_master_wait_point AFTER_SYNC mysql_Replica> SHOW GLOBAL VARIABLES LIKE '%semi_sync_slave@'; Variable_name I Value rpl_semi_sync_slave_enabled I ON rpl_semi_sync_slave_trace_level I 32 만약 소스 서버와 레플리카 서버가 기존에 복제가 실행 중인 상태라면 반동기 복제 적용을 위해 다음과 같이 레플리카 서버에서 레플리케이션 I/O 스레드를 재시작해야 한다. 그렇지 않으면 반동기 복제 설 정을 활성화했다 하더라도 복제는 계속 비동기 복제를 유지하게 된다. - // MySQL 8.0.22 미만 버전 mysql_Replica> STOP SLAVE IO_THREAD; mysql_Replica> START SLAVE IO_THREAD; - // MySQL 8.0.22 이상 버전 mysql_Replica> STOP REPLICA IO_THREAD; mysql_Replica> START REPLICA IO_THREAD; 실제로 반동기 복제가 잘 적용됐는지는 SHOW GLOBAL STATUS 명령을 통해 확인할 수 있다.


