# UPDDATE와 DELETE
일반적인 온라인 트랜잭션 프로그램에서 UPDATE와 DELETE 문장은 주로 하나의 테이블에 대해 한 건 또는 여러 건의 레코드를 변경 또는 삭제하기 위해 사용된다. 하지만 MySQL 서버에서는 **여러 테이블을 조인해서 한 개 이상 테이블의 레코드를 변경한다거나 삭제하는 기능도 제공**한다. 특히 잘못된 데이터를 보정하거나 일괄로 많은 레코드를 변경 및 삭제하는 경우에 **JOIN UPDATE와 JOIN DELETE** 구문은 매우 유용하다.

## UPDATE ORDER BY ... LIMIT n 
UPDATE와 DELETE는 WHERE 조건절에 일치하는 모든 레코드를 업데이트한다. 하지만 MySQL에서는 UPDATE나 DELETE 문장에 **ORDER BY 절과 LIMIT 절을 동시에 사용해 특정 칼럼으로 정렬해서 상위 몇 건만 변경 및 삭제하는 것도 가능**하다. 한 번에 너무 많은 레코드를 변경 및 삭제하는 작업은 MySQL 서버에 과부하를 유발하거나 다른 커넥션의 쿼리 처리를 방해할 수도 있다. 이 때 LIMIT을 이용해 조금씩 잘라서 변경하거나 삭제하는 방식을 손쉽게 구현할 수 있다. 

복제 소스 서버에서 `ORDER BY ... LIMIT`이 포함된 UPDATE나 DELETE 문장을 실행하면 **경고 메시지**가 발생할 수도 있다. 물론 바이너리 로그의 포맷이ROW일 때는 문제가 되지 않지만 STATEMENT 기반의 복제에서는 주의가 필요하다.

경고 메시지가 발생하는 것은 ORDER BY에 의해 정렬되더라도 중복된 값의 순서가 복제 소스 서버와 레플리카 서버에서 달라질 수도 있기 때문인데, 프라이머리 키로 정렬하면 문제는 없지만 여전히 경고 메시지는 기록된다. 복제가 구축된 MySQL 서버에서 ORDER BY가 포함된 UPDATE나 DELETE 문장을 사용할 때는 주의하자.

## JOIN UPDATE 
**두 개 이상의 테이블을 조인해 조인된 결과 레코드를 변경 및 삭제하는 쿼리를 조인 업데이트(JOIN UPDATE)**라고 한다. 조인된 테이블 중에서 특정 테이블의 칼럼값을 다른 테이블의 칼럼에 업데이트해야 할 때 주로 조인 업데이트를 사용한다. 또는 꼭 다른 테이블의 칼럼값을 참조하지 않더라도 조인되는 양쪽 테이블에 공통으로 존재하는 레코드만 찾아서 업데이트하는 용도로도 사용할 수 있다. 

일반적으로 JOIN UPDATE는 조인되는 모든 테이블에 대해 읽기 참조만 되는 테이블은 읽기 잠금이 걸리고, 칼럼이 변경되는 테이블은 쓰기 잠금이 걸린다. 그래서 JOIN UPDATE 문장이 웹 서비스 같은 OLTP 환경에서는 **데드락을 유발할 가능성이 높으므로** 너무 빈번하게 사용하는 것은 피하는 것이 좋다. 하지만 배치 프로그램이나 통계용 UPDATE 문장에서는 유용하게 사용할 수 있다. 

JOIN UPDATE 쿼리도 2개 이상의 테이블을 먼저 조인해야하므로 테이블의 조인 순서에 따라 UPDATE 문장의 성능이 달라질 수 있다. 그래서 JOIN UPDATE 문장도 사용하기 전에 실행 계획을 확인하는 것이 좋다.

### GROUP BY가 포함된 JOIN UPDATE
다음 예제의 첫 번째 쿼리는 테스트를 목적으로 departments 테이블에 emp_count 칼럼을 추가한 것이다. departments 테이블에 추가된 emp_count는 해당 부서에 소속된 사원의 수를 저장하기 위한 칼럼이다. 
```sql
mysql> ALTER TABLE departments ADD emp_count INT; 

mysql> 	UPDATE departments d, dept_emp de 
		SET d.emp_count=COUNT(*) 
        WHERE de.dept_no=d.dept_no 
        GROUP BY de.dept_no; 
```
위 쿼리는 작동하지 않고 에러를 발생시킬 것이다. JOIN UPDATE 문장에서는 GROUP BY나 ORDER BY 절을 사용할 수 없기 때문이다. 그러면 이 작업을 처리하려면 어떻게 해야 할까? 바로 이렇게 문법적으로 지원하지 않는 SQL에 대해 **서브쿼리를 이용한 파생 테이블을 사용하는 것**이다. 이 JOIN UPDATE 문장을 서브쿼리를 이용해 다시 작성해 보자. 

```sql
mysql>	UPDATE departments d, 
			(SELECT de.dept_no, COUNT(*) AS emp_count 
            FROM dept_emp de 
            GROUP BY de.dept_no) dc 
        SET d.emp_count=dc.emp_count 
        WHERE dc.dept_no=d.dept_no; 
```

위의 예제 쿼리에서는 우선 서브쿼리로 dept_emp 테이블을 dept_no로 그루핑하고, 그 결과를 파생 테이블로 저장했다. 그리고 이 결과와 departments 테이블을 조인해 departments 테이블의 emp_count 칼럼에 업데이트한 것이다. 이미 조인에서 배웠지만 이 예제 쿼리와 같이 일반 테이블이 조인될 때는 임시 테이블이 드라이빙 테이블이 되는 것이 일반적으로 빠른 성능을 보여준다. 

MySQL의 옵티마이저가 최적의 조인 방향을 선택하지만, 혹시라도 원하는 조인의 방향을 옵티마이저에게 알려주고 싶다면 다음과 같이 JOIN UPDATE 문장에 STRAIGHT_JOIN 키워드를 사용하면 된다. 또는 MySQL 8.0에 새롭게 추가된 JOIN_ORDER 옵티마이저 힌트를 사용해도 된다.

```sql
mysql> 	UPDATE 	(SELECT de.dept_no, COUNT(*) AS emp_count 
				FROM dept_emp de 
                GROUP BY de.dept_no) dc 
       	STRAIGHT_JOIN departments d ON dc.dept_no=d.dept_no 
        SET d.emp_count=cic.emp_count; 
        
mysql> 	UPDATE /*+ JOIN_ORDER (dc, d) */ 
			(SELECT de.dept_no, COUNT(*) AS emp_count 
            FROM dept_emp de 
            GROUP BY de.dept_no) dc 
        INNER JOIN departments d ON dc.dept_no=d.dept_no 
        SET d.emp_count=dc. emp_count; 
```

여기에 사용된 STRAIGHT_JOIN 키워드는 조인의 순서를 지정하는 MySQL 힌트이기도 하지만 INNER JOIN 또는 LEFT JOIN과 같이 조인 키워드로 사용되기도 한다. INNER JOIN이나 LEFT JOIN 키워드는 사실 테이블의 조인 순서를 결정하는 키워드는 아니다. 하지만 STRAIGHT_JOIN 키워드는 조인의 순서까지 결정하는 키워드다. STRAIGHT_JOIN 키워드 왼쪽에 명시된 테이블이 드라이빙 테이블이 되며, 오른쪽의 테이블은 드리븐 테이블이 된다. INNER JOIN 또는 LEFT JOIN을 사용하는 경우 옵티마이저가 원하는 순서대로 조인을 실행하지 않는다면 JOIN_ORDER 힌트를 사용하면 된다. 

예제에서는 GROUP BY 절을 가진 쿼리의 결과를 임시 테이블에 저장했지만 필요에 따라 다음과 같이 **래터럴 조인(LATERAL JOIN)**을 이용해 JOIN UPDATE를 구현할 수도 있다.

## 여러 레코드 UPDATE 
MySQL 8.0 버전부터는 다음과 같이 레코드 생성(Row Constructor) 문법을 이용해 레코드별로 서로 다른 값을 업데이트할 수 있게 됐다. 
```sql
mysql> 	CREATE TABLE user_level ( 
			user_id BIGINT NOT NULL, 
            user_lv INT NOT NULL, 
            created_at DATETIME NOT NULL, 
            PRIMARY KEY (user_id) 
            ); 

mysql> 	UPDATE user_level ul 
		INNER JOIN (VALUES ROW(1, 1), 
        			ROW(2, 4)) new_user_level (user_id, user_lv) 
                    			ON new_user_level.user_id=ul.user_id 
        SET ul.user_lv=ul.user_lv + new_user_level.user_lv; 
```
**"VALUES ROW(...), ROW(...)," 문법을 사용하면 SQL 문장 내에서 임시 테이블을 생성하는 효과**를 낼 수 있다. 위의 예제에서는 2건의 레코드(1,1)과 (2,4))를 가지는 임시 테이블 "new_user_level"을 생성하고, new_user_level 임시 테이블과 user_level 테이블을 조인해서 업데이트를 수행하는 "JOIN UPDATE" 문장의 효과를 낼 수 있게 됐다. 
## JOIN DELETE 
JOIN DELETE 문장을 사용하려면 단일 테이블의 DELETE 문장과는 조금 다른 문법으로 쿼리를 작성해야 한다. 우선 3개의 테이블을 조인해서 그중 하나의 테이블에서만 레코드를 삭제하는 예제를 살펴보자.
```sql
mysql> 	DELETE e 
		FROM employees e, dept_emp de, departments d 
        WHERE e.emp_no=de.emp_no 
        AND de .dept_no=d.dept_no 
        AND d.dept_no=' d001 ; 
```
위 예제는 employees와 `dept_emp`, departments라는 3개의 테이블을 조인한 다음, 조인이 성공한 레코드에 대해 employees 테이블의 레코드만 삭제하는 쿼리다. 일반적으로 하나의 테이블에서 레코드를 삭제할 때는 "DELETE FROM table "과 같은 문법으로 사용하지만 **JOIN DELETE 문장에서는 DELETE와 FROM 절 사이에 삭제할 테이블을 명시**해야 한다. 이 예제에서는 조인을 위해 FROM 절에는 employees와 `dept_emp`, departments 테이블을 명시했고, DELETE와 FROM 절 사이에는 실제로 삭제할 employees 테이블의 별명(e)만 명시했다. 

JOIN DELETE 문장으로 하나의 테이블에서만 레코드를 삭제할 수 있는 것은 아니다.
```sql
mysql> 	DELETE e, de 
		FROM employees e, dept_emp de, departments d 
        WHERE e.emp_no=de.emp_no 
        AND de .dept_no=d.dept_no 
        AND d.dept_no= d001 
        
mysql> 	DELETE e, de, d 
		FROM employees e, dept_emp de, departments d 
        WHERE e.emp_no=de.emp_no 
        AND de.dept_no=d.dept_no 
        AND d.dept_no=' d001'; 
```
위 예제에서 첫 번째 쿼리는 employees와 `dept_emp`, departments 테이블을 조인해서 employees와 `dept_emp` 테이블에서 동시에 레코드를 삭제하는 쿼리이며, 두 번째 쿼리는 3개의 테이블 모두에서 dept_ no='d001'인 레코드를 삭제하는 예제다. 물론 JOIN DELETE 또한 JOIN UPDATE와 마찬가지로 SELECT 쿼리로 변환해서 실행 계획을 확인해 볼 수 있다. 옵티마이저가 적절한 조인 순서를 결정하지 못한다면 STRAIGHT_JOIN 키워드나 JOIN_ORDER 옵티마이저 힌트를 이용해 조인의 순서를 옵티마이저에게 지시할 수 있다. 

# 스키마 조작(DDL)

DBMS 서버의 모든 오브젝트를 생성하거나 변경하는 쿼리를 DDL이라고 한다. 스토어드 프로시저나 함수, DB나 테이블 등을 생성하거나 변경하는 대부분의 명령이 DDL에 해당한다. MySQL 서버가 업그레이드되면서 많은 DDL이 온라인 모드로 처리될 수 있게 개선됐지만 여전히 스키마를 변경하는 작업 중에는 **상당히 오랜 시간이 걸리고 MySQL 서버에 많은 부하를 발생 시키는 작업들이 있으므로 주의**해야 한다. 여기서는 중요 DDL 문의 문법과 함께 어떤 DDL 문이 특히 느리고 큰 부하를 유발하는지도 함께 살펴보자. 

> 각 예제에서 대괄호("[]") 표기를 사용한 곳이 있는데, 이는 MySQL 매뉴얼의 대괄호와 동일하게 선택 적인 키워드임을 의미한다. 

## 온라인 DDL 
MySQL 5.5 이전 버전까지는 MySQL 서버에서 테이블의 구조를 변경하는 동안에는 다른 커넥션에서 DML을 실행할 수가 없었다. MySQL 8.0 버전으로 업그레이드되면서 대부분의 스키마 변경 작업은 MySQL 서버에 내장된 온라인 DDL 기능으로 처리가 가능해졌다.

### 온라인 DDL 알고리즘 
온라인 DDL은 **스키마를 변경하는 작업 도중에도 다른 커넥션에서 해당 테이블의 데이터를 변경하거나 조회하는 작업을 가능하게 해준다.** 온라인 DDL은**ALGORITHM과 LOCK 옵션**을 이용해 어떤 모드로 스키마 변경을 실행할지를 결정할 수 있다. 온라인 DDL 기능은 **테이블의 구조를 변경**하거나 **인덱스 추가**와 같은 대부분의 작업에 대해 작동한다. 

MySQL 서버에서는 old_alter_table 시스템 변수를 이용해 ALTER TABLE 명령이 온라인 DDL로 작동할지, 아니면 예전 방식(테이블의 읽고 쓰기를 막고 스키마 변경하는 방식)으로 처리할지를 결정할 수 있다. MySQL 8.0 버전에서는 old_alter_table 시스템 변수의 기본값은 OFF로 설정돼 있기 때문에 자동으로 온라인 DDL이 활성화된다. 

#### ALGORITHM
ALTER TABLE 명령을 실행하면 MySQL 서버는 다음과 같은 순서로 스키마 변경에 적합한 알고리즘을 찾는다. 

1. ALGORITHM=INSTANT로 스키마 변경이 가능한지 확인 후, 가능하다면 선택
2. ALGORITHM=INPLACE로 스키마 변경이 가능한지 확인 후, 가능하다면 선택
3. ALGORITHM=COPY 알고리즘 선택 

스키마 변경 알고리즘의 우선순위가 낮을수록 MySQL 서버는 스키마 변경을 위해서 더 큰 잠금과 많은 작업을 필요로 하고 서버의 부하도 많이 발생시킨다.

- INSTANT: 테이블의 **데이터는 전혀 변경하지 않고, 메타데이터만 변경하고 작업을 완료**한다. 테이블이 가진 레코드 건수와 무관하게 **작업 시간은 매우 짧다**. 스키마 변경 도중 테이블의 읽고 쓰기는 대기하게 되지만 스키마 변경 시간이 매우 짧기 때문에 다른 커넥션의 쿼리 처리에는 크게 영향을 미치지 않는다. 

- INPLACE: **임시 테이블로 데이터를 복사하지 않고 스키마 변경을 실행**한다. 하지만 내부적으로는 **테이블의 리빌드를 실행**할 수도 있다. 레코드의 복사 작업은 없지만 테이블의 모든 레코드를 리빌드해야 하기 때문에 **테이블의 크기에 따라 많은 시간이 소요**될 수도 있다. 하지만 **스키마 변경 중에도 테이블의 읽기와 쓰기 모두 가능**하다. INPLACE 알고리즘으로 스키마가 변경되는 경우에도 최초 시작 시점과 마지막 종료 시점에는 테이블의 읽고 쓰기가 불가능하 다. 하지만 이 시간은 매우 짧기 때문에 다른 커넥션의 쿼리 처리에 대한 영향도는 높지 않다.

- COPY: 변경된 스키마를 적용한 **임시 테이블을 생성**하고, 테이블의 레코드를 모두 임시 테이블로 복사한 후 최종적으 로 임시 테이블을 RENAME해서 스키마 변경을 완료한다. 이 방법은 테이블 읽기만 가능하고 DML(INSERT, UPDATE, DELETE)은 실행할 수 없다. 

온라인 DDL 명령은 다음 예제와 같이 알고리즘과 함께 잠금 수준도 함께 명시할 수 있다. ALGORITHM과 LOCK 옵션이 명시되지 않으면 **MySQL 서버가 적절한 수준의 알고리즘과 잠금 수준을 선택**하게 된다.

```sql
mysql> ALTER TABLE salaries CHANGE to_date end_date DATE NOT NULL, 
	ALGORITHM=INPLACE, LOCK=NONE; 
```

#### LOCK
온라인 DDL에서 INSTATNT 알고리즘은 테이블의 메타데이터만 변경하기 때문에 매우 짧은 시간 동안의 메타데이터 잠금만 필요로 한다. 그래서 **INSTANT 알고리즘을 사용하는 경우에는 LOCK 옵션은 명시할 수 없다.** INPLACE나 COPY 알고리즘을 사용하는 경우 LOCK은 다음 3가지 중 하나를 명시할 수 있다. 

- NONE: 아무런 잠금을 걸지 않음 
- SHARED: 읽기 잠금을 걸고 스키마 변경을 실행하기 때문에 스키마 변경 중 읽기는 가능하지만 쓰기(INSERT, UPDATE, DELETE)는 불가함 
- EXCLUSIVE: 쓰기 잠금을 걸고 스키마 변경을 실행하기 때문에 테이블의 읽고 쓰기가 불가함 

알고리즘으로 INPLACE가 사용되는 경우 대부분 잠금은 NONE으로 설정 가능하지만, 가끔 SHARED 수준까지 설정해야 할 수도 있다. 그리고 EXCLUSIVE는 예전 MySQL 서버의 전통적인 ALTER TABLE과 동일하므로 굳이 LOCK을 명시할 필요는 없다. 

온라인 스키마 변경 작업이 INPLACE 알고리즘을 사용하더라도 내부적으로는 테이블의 리빌드가 필요할 수도 있다. 대표적으로 테이블의 프라이머리 키를 추가하는 작업은 데이터 파일에서 레코드의 저장 위치가 바뀌어야 하기 때문에 테이블의 리빌드가 필요한 반면, 단순히 칼럼의 이름만 변경하는 경우 INPLACE 알고리즘을 사용해야 하지만 실제 테이블 레코드의 리빌드 작업은 필요치 않다. 

> 프라이머리 키를 추가하는 경우와 같이 테이블 레코드의 리빌드가 필요한 경우를 MySQL 서버 매뉴얼에서는 "Data Reorganizing(데이터 재구성)" 또는 "Table Rebuild(테이블 리빌드) "라고 명명한다. 

결론적으로 INPLACE 알고리즘을 사용하는 경우는 다음과 같이 구분할 수 있다. 

- 데이터 재구성(테이블 리빌드)이 필요한 경우: 잠금을 필요로 하지 않기 때문에 읽고 쓰기는 가능하지만 여전히 테이 블의 레코드 건수에 따라 상당히 많은 시간이 소요될 수도 있다. 
- 데이터 재구성(테이블 리빌드)이 필요치 않은 경우: INPLACE 알고리즘을 사용하지만 INSTANT 알고리즘과 비슷하게 매우 빨리 작업이 완료될 수 있다. MySQL 서버의 온라인 DDL 기능은 버전별로 많은 차이가 있다. 

그래서 사용 중인 MySQL 서버의 버 전이 8.0이 아니라면 이 책의 내용보다는 사용 중인 버전의 MySQL 매뉴얼을 살펴보고 테이블 리빌드(Table Rebuild)가 필요한지 확인한 후 진행하자. 스키마 변경을 실행하기 전에 이런 내용을 확인하지 않고 시작했는데 스키마 변경 작업에 시간이 오래 걸리면 그때서야 불안해하는 상황을 자주 경험했다. 스키마 변경 작업을 실행하기 전에 먼저 매뉴얼과 테스트를 진행해볼 것을 권장한다. 

### 온라인 처리 가능한 스키마 변경 
MySQL 서버의 모든 스키마 변경 작업이 온라인으로 가능한 것이 아니기 때문에 필요한 스키마 변경 작업의 형태가 온라인으로 처리될 수 있는지, 아니면 테이블의 읽고 쓰기가 대기(Waiting)하게 되는지 확인한 후 실행하는 것이 좋다.

MySQL 서버에서 사용할 수 있는 스키마 변경 작업은 매우 다양하기 때문에 **모든 명령이 온라인 DDL을 지원하는지 아닌지를 기억하기는 쉽지 않다. 이러한 경우에는  ALTER TABLE 문장에 LOCK과 ALGORITHM 절을 명시해서 온라인 스키마 변경의 처리 알고리즘을 강제**할 수 있다. 물론 이렇게 온라인 DDL 알고리즘을 강제한다고 해서 무조건 그 알고리즘으로 처리되는 것은 아니다. 하지만 **명시된 알고리즘으로 온라인 DDL이 처리되지 못한다면 단순히 에러만 발생시키고 실제 스키마 변경 작업은 시작되지 않기 때문에 의도하지 않은 잠금과 대기는 발생하지 않는다**.

위의 예제에서는 다음 순서로 ALGORITHM과 LOCK 옵션을 시도해보면서 해당 알고리즘이 지원되는지 여부를 판단할 수 있다.

1. ALGORITHM=INSTANT 옵션으로 스키마 변경을 시도 
2. 실패하면 ALGORITHM=INPLACE, LOCK=NONE 옵션으로 스키마 변경을 시도 
3. 실패하면 ALGORITHM=INPLACE, LOCK=SHARED 옵션으로 스키마 변경을 시도 
4. 실패하면 ALGORITHM=COPY, LOCK=SHARED 옵션으로 스키마 변경을 시도 
5. 실패하면 ALGORITHM=COPY, LOCK=EXCLUSIVE 옵션으로 스키마 변경을 시도 

실행하고자 하는 스키마 변경 작업으로 인해 DML(INSERT, UPDATE, DELETE)이 멈춰서는 안 된다면 1, 2번까지만 해보면 된다. 1번과 2번 옵션으로 스키마 변경이 되지 않는다면 점검(서비스를 멈추고)을 걸고 DML을 멈춘 다음 스키마 변경을 해야 한다는 것을 확인할 수 있다. 실행하고자 하는 스키마 변경이 1번이나 2번으로 옵션으로 가능한 작업이라면 MySQL 서버는 즉시 스키마 변경을 실행하게 된다. 하지만 온라인 DDL이라 하더라도 그만큼 MySQL 서버에 부하를 유발할 수 있으며, 그로 인해 다른 커넥션의 쿼리들이 느려질 수도 있다. 그러므로 설령 스키마 변경 작업이 직접 다른 커넥션의 DML을 대기하게 만들지는 않더라도 주의해서 사용해야 한다. 

### INPLACE 알고리즘 
INPLACE 알고리즘은 임시 테이블로 레코드를 복사하지는 않더라도 내부적으로 테이블의 모든 레코드를 리빌드해야 하는 경우가 많다. 이러한 경우 MySQL 서버는 다음과 같은 과정을 거치게 된다. 

1. INPLACE 스키마 변경이 지원되는 스토리지 엔진의 테이블인지 확인 
2. INPLACE 스키마 변경 준비 (스키마 변경에 대한 정보를 준비해서 온라인 DDL 작업 동안 변경되는 데 이터를 추적할 준비)
3. 테이블 스키마 변경 및 새로운 DML 로깅(이 작업은 실제 스키마 변경을 수행하는 과정으로, 이 작 업이 수행되는 동안은 다른 커넥션의 DML 작업이 대기하지 않는다· 이렇게 스키마를 온라인으로 변 경함과 동시에 다른 스레드에서는 사용자에 의해서 발생한 DML들에 대해서 별도의 로그로 기록) 
4. 로그 적용(온라인 DDL 작업 동안 수집된 DML 로그를 테이블에 적용) 
5. INPLACE 스키마 변경 완료(COMMIT) 

INPLACE 알고리즘으로 스키마가 변경된다고 하더라도 2번과 4번 단계에서는 잠깐의 배타적 잠금 (Exclusive lock) 이 필요하며, 이 시점에는 다른 커넥션의 DML들이 잠깐 대기한다. 하지만 **실제 변경 작업이 실행되면서 많은 시간이 필요한 3번 단계는 다른 커넥션의 DML 작업이 대기 없이 즉시 처리**된다. 그리고 INPLACE 알고리즘으로 온라인 스키마 변경이 진행되는 동안 새로 유입된 DML 퀴리들에 의해 변경되는 데이터를 "온라인 변경 로그(Online alter log)"라는 메모리 공간에 쌓아 두었다가 온라인 스키마 변경이 완료되면 로그의 내용을 실제 테이블로 일괄 적용하게 된다. 이때 온라인 변경 로그는 디스크가 아니라 메모리에만 생성되며, 이 메모리 공간의 크기는 `innodb_online_alter_log_max_size` 시스템 설정 변수에 의해 결정된다. 기본적으로 온라인 변경 로그의 크기는 128MB인데, 온라인 스키 마 변경이 오랜 시간이 걸린다거나 온라인 스키마 변경 중에 유입되는 DML 쿼리가 많다면 이 메모리 공간을 더 크게 설정하는 것이 좋다. innodb_online_alter_log_max_size 시스템 변수는 세션 단위의 동적 변수이므로 필요한 경우에는 언제든지 변경할 수 있다.

### 온라인 DDL의 실패 케이스 
온라인 DDL 명령은 다음과 같은 이유로 실패할 수도 있다. 온라인 DDL이 INSTANT 알고리즘을 사용하는 경우 거의 시작과 동시에 작업이 완료되기 때문에 작업 도중 실패할 가능성은 거의 없다. 하지만 **INPLACE 알고리즘으로 실행되는 경우 내부적으로 테이블 리빌드 과정이 필요하고 최종 로그 적용 과정 이 필요해서 중간 과정에서 실패할 가능성이 상대적으로 높은 편**이다. INPLACE 알고리즘으로 몇 시간 동안 실행되던 온라인 DDL이 실패하면 이는 상당한 자원과 시간 낭비가 될 것이다. 

다음 실패 케이스를 살펴보고, 최대한 온라인 DDL이 실패할 가능성을 낮추는 것이 좋다.

- ALTER TABLE 명령이 장시간 실행되고 동시에 다른 커넥션에서 DML이 많이 실행되는 경우이거나 온라인 변경 로 그의 공간이 부족한 경우 온라인 스키마 변경 작업은 실패 

```sql
ERROR 1799 (HY000): Creating index 'idx_col1' required more than 'innodb_online_alter_ log_max_size' bytes of modification log. Please try again. 
```

- ALTER TABLE 명령이 실행되는 동안 ALTER TABLE 이전 버전의 테이블 구조에서는 아무런 문제가 안 되지만 ALTER TABLE 이후의 테이블 구조에는 적합하지 않은 레코드가 INSERT되거나 UPDATE됐다면 온라인 스키마 변경 작업은 마지막 과정에서 실패 
```sql
ERROR 1062 (23000): Duplicate entry 'd005-10001 · for key 'PRIMARY'
```

- 스키마 변경을 위해서 필요한 잠금 수준보다 낮은 잠금 옵션이 사용된 경우 
```sql
ERROR 1846 (θA900): LOCK=NONE is not supported. Reason: Adding an auto-increment column requires a lock. Try LOCK=SHARED. 
```
- 온라인 스키마 변경은 LOCK=NONE으로 실행된다고 하더라도 변경 작업의 처음과 마지막 과정에서 잠금이 필요한데, 이 잠금을 획득하지 못하고 타임 아웃이 발생하면 실패 
```sql
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction 
```

- 온라인으로 인덱스를 생성하는 작업의 경우 정렬을 위해 tmpdir 시스템 변수에 설정된 디스크의 임시 디렉터리를 사용하는데, 이 공간이 부족한 경우 또한 온라인 스키마 변경은 실패함 

LOCK=NONE으로 온라인 스키마 변경이 실행되더라도 변경 작업의 처음과 마지막에는 테이블의 메타데이터에 대한 잠금이 필요하다는 것은 이미 살펴봤다. 메타데이터에 대한 잠금을 획득하지 못하고 타임 아웃이 발생하면 온라인 스키마 변경이 실패하게 된다. MySQL 서버에는 이미 타임 아웃과 관련된 시스템 변수가 꽤 많이 있는데, 이때 타임 아웃의 기준으로 사용되는 시스템 변수는 무엇일까? InnoDB 스토리지 엔진을 사용하는 테이블이라고 하더라도 온라인 스키마 변경에서 필요한 잠금은 테이블 수준의 메타데이터 잠금이다. MySQL에서 메타데이터 잠금에 대한 타임 아웃은 lock_wait_timeout 시스템 변수에 의해서 결정된다. InnoDB의 레코드 잠금에 대한 대기 타임 아웃인 innodb_lock_wait_timeout은 온라인 스키마 변경과는 무관하다는 것도 기억해 두자.

31536000초 정도가 lock_wait_timeout으로 설정돼 있는데, 이 값은 실제 MySQL 서버의 기본 설정값이다. 온라인 스키마 변경을 실행하고 있는데, 다른 커넥션에서 아주 장시간 DML이 실행되고 있다거나 트랜잭션이 정상적으로 종료되지 않아서 INSERT나 UPDATE 쿼리가 활성 트랜잭션 상태로 남아 있는 커넥션이 있다면 온라인 스키마 변경은 31536000초 동안 기다릴 것이다. 물론 온라인 스키마 변경이 진행되는 동안에는 주의해서 이와 같이 스키마 변경을 방해하는 트랜잭션이 발생하지 않 게 해야겠지만, 이런 현상을 피할 수 없는 상황이라면 lock_wait_timeout을 적절한 시간으로 조정해서 일정 시간 이상 대기할 때는 온라인 스키마 변경을 취소하도록 조치하는 것도 도움이 될 수 있다. lock_wait_timeout은 글로벌 레벨의 시스템 변수임과 동시에 세션 레벨의 시스템 변수이기도 하다. 그러므로 lock_wait_timeout은 온라인 스키마 변경을 실행하는 세션에서 적정값으로 조정하는 것이 좋다.

### 온라인 DDL 진행 상황 모니터링 
온라인 DDL을 포함한 모든 ALTER TABLE 명령은 MySQL 서버의 performance_schema를 통해 진행 상황을 모니터링할 수 있다. ALTER TABLE의 진행 상황을 모니터링할 수 없었을 때는 MySQL 서버의 상태 변수를 뒤져가면서 몇 건이나 레코드를 읽고 쓰기를 했는지를 이용해 ALTER TABLE이 어느 정도 진행됐는지 대략 예측하곤 했다. 하지만 레코드를 얼마나 읽고 쓰기를 했는지로는 예측하는데 한계가 있어 제대로 시간을 예측한 적이 없다. 우선 performance_schema를 이용해 ALTER TABLE의 진행 상황을 모니터링하려면 다음과 같이 performance_schema 옵션(Instrument와 Consumer 옵션) 이 활성화돼야 한다.

스키마 변경 작업의 진행 상황은 performance_schema.events_stages_current 테이블을 통해 확인할 수 있는데, 실행 중인 스키만 변경 종류에 따라 기록되는 내용이 조금씩 달라진다.


performance_schema 내부에 WORK_ESTIMATED와 WORK_COMPLETED 칼럼의 값을 비교해보면 ALTER TABLE의 진행 상황을 예측할 수 있다. 하지만 WORK_ESTIMATED 칼럼의 값은 예측지이기 때문에 ALTER TABLE이 진행되면서 조금씩 변경된다.

## 데이터베이스 변경

MySQL에서 하나의 인스턴스는 1개 이상의 데이터베이스를 가질 수 있다. 다른 RDBMS에서는 스키마와 데이터베이스를 구분해서 관리하지만 **MySQL 서버에서는 스키마와 데이터베이스는 동격의 개념**이다. 그래서 MySQL 서버에서는 굳이 스키마를 명시적으로 사용하지는 않는다. MySQL의 데이터베이스는 디스크의 물리적인 저장소를 구분하기도 하지만 여러 데이터베이스의 테이블을 묶어서 조인 퀴리를 사용할 수도 있기 때문에 단순히 논리적인 개념이기도 하다. 물론 데이터베이스는 객체에 대한 권한을 구분하는 용도로 사용되기도 하지만 그 이상의 큰 의미를 가지지는 않는다. 그래서 데이터베이스 단위로 변경하거나 설정하는 DDL 명령은 그다지 많지 않다. 데이터베이스에 설정할 수 있는 옵션은 기본 문자 집합이나 콜레이션을 설정하는 정도이므로 간단하다. 

### 데이터베이스 생성 
```sql
mysql> CREATE DATABASE [IF NOT EXISTS] employees; 
mysql> CREATE DATABASE [IF NOT EXISTS] employees CHARACTER SET utf8mb4; 
mysql> CREATE DATABASE [IF NOT EXISTS] employees 
		CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; 
```
첫 번째 명령은 기본 문자 집합과 콜레이션으로 employees라는 데이터베이스를 생성한다. 여기서 기본이라 함은 MySQL 서버의 character_set_server 시스템 변수에 정의된 문자 집합을 사용한다는 의미다. 두 번째와 세 번째 명령은 별도의 문자 집합과 콜레이션이 지정된 데이터베이스를 생성한다. 이미 동일 이름의 데이터베이스가 있다면 이 DDL 문장은 에러를 유발할 것이다. 하지만 "IF NOT EXISTS"라 는 키워드를 사용하면 데이터베이스가 없는 경우에만 생성하고, 이미 있다면 이 DDL은 그냥 무시 된다. 
### 데이터베이스 목록 
```sql
mysql> SHOW DATABASES; 
mysql> SHOW DATABASES LIKE '%emp%'; 
```
접속된 MySQL 서버가 가지고 있는 **데이터베이스의 목록을 나열**한다. 단, 권한을 가지고 있는 데이터 베이스의 목록만 표시하며, 이 명령을 실행하려면 "SHOW DATABASES" 권한이 있어야 한다. 두 번째 명령은 "emp"라는 문자열을 포함한 데이터베이스 목록만 표시한다.

### 데이터베이스 선택 
```sql
mysql> USE employees; 
```
기본 데이터베이스를 선택하는 명령이다. SQL 문장에서 별도로 데이터베이스를 명시하지 않고 테이블 이름이나 프로시저의 이름만 명시하면 MySQL 서버는 현재 커넥션의 기본 데이터베이스에서 주어진 테이블이나 프로시저를 검색한다. 기본 데이터베이스에 존재하지 않는 테이블이나 프로시저를 사용하려면 **테이블이나 프로시저의 이름 앞에 데이터베이스 이름을 반드시 명시**해야 한다.
### 데이터베이스 속성 변경 

```sql
mysql> ALTER DATABASE employees CHARACTER SET=euckr; 
mysql> ALTER DATABASE employees CHARACTER SET=euckr COLLATE= euckr_korean_ci; 
```
데이터베이스를 생성할 때 지정한 문자 집합이나 콜레이션을 변경한다. 

### 데이터베이스 삭제 
```sql
mysql> DROP DATABASE [IF EXISTS] employees; 
```
데이터베이스를 삭제한다. 지정한 이름의 데이터베이스가 존재하지 않는다면 에러가 발생한다. 하지만 "IF EXISTS" 키워드를 사용하면 해당 데이터베이스가 존재할 때만 삭제하고, 그렇지 않으면 이 명령을 실행하지 않는다. 

## 테이블 스페이스 변경 
MySQL 서버에는 전통적으로 테이블별로 전용의 테이블스페이스를 사용했었다. InnoDB 스토리지 엔진의 시스템 테이블 스페이스(ibdata1 파일)만 제너럴 테이블스페이스(General Tablespace)를 사용했는데, 제너럴 테이블스페이스는 여러 테이블의 데이터를 한꺼번에 저장하는 테이블스페이스를 의미한다.

### 사용자 테이블을 제너럴 테이블스페이스
MySQL 8.0 버전이 되면서 **MySQL 서버에서도 사용자 테이블을 제너럴 테이블스페이스로 저장하는 기능이 추가되고 테이블스페이스를 관리하는 DDL 명령들이 추가**됐다. 그러나 MySQL 8.0에서도 제 너럴 테이블스페이스는 여러 가지 제약 사항을 가진다. 그중 몇 가지 **중요한 제약 사항**은 다음과 같다. 
- 파티션 테이블은 제너럴 테이블스페이스를 사용하지 못함 
- 복제 소스와 레플리카 서버가 동일 호스트에서 실행되는 경우 ADD DATAFILE 문장은 사용 불가 
- 테이블 암호화(TDE)는 테이블스페이스 단위로 설정됨 
- 테이블 압축 가능 여부는 테이블스페이스의 블록 사이즈와 InnoDB 페이지 사이즈에 의해 결정됨 
- 특정 테이블을 삭제(DROP TABLE)해도 디스크 공간이 운영체제로 반납되지 않음

그럼에도 불구하고, MySQL 8.0에서 사용자 테이블이 제너럴 테이블스페이스를 이용할 수 있게 개선된 것은 다음과 같은 장점이 있기 때문이다. 

- 제너럴 테이블스페이스를 사용하면 파일 핸들러(Open file descriptor)를 최소화 
- 테이블스페이스 관리에 필요한 메모리 공간을 최소화

제너럴 테이블스페이스가 가진 2가지 장점은 사실 테이블의 개수가 매우 많은 경우에 유용하다. 아직 일반적인 환경에서 제너럴 테이블스페이스의 장점은 취하기가 어렵다. MySQL 서버에서 테이블이 개 별 테이블스페이스를 사용할지 아니면 제너럴 테이블스페이스를 사용할지는 innodb_file_per_table 시스템 변수로 제어할 수 있다. MySQL 8.0에서는 innodb_file_per_table 시스템 변수의 기본값이 ON이 므로 테이블은 자동으로 개별 테이블스페이스를 사용한다.

## 테이블 변경 
테이블은 사용자의 데이터를 가지는 주체로서, MySQL 서버의 많은 옵션과 인덱스 등의 기능이 테이 블에 종속되어 사용된다.

### 테이블 생성
다음 예제는 테이블을 생성하는 CREATE TABLE 문장이다. 설명을 위해 가능한 많은 옵션이 포함된 칼 럼으로 테이블 생성 예제를 준비했다. 
```sql
CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tb_test ( 
	member_id BIGINT [UNSIGNED] [AUTO_INCREMENT], 
    nickname CHAR(20) [CHARACTER SET 'utf8'] [COLLATE 'utf8_general_ci'] [NOT NULL], 
    home_url VARCHAR(200) [COLLATE 'latin1_general_cs'], 
    birth_year SMALLINT [ (4) ] [UNSIGNED] [ZEROFILL], member_point INT [NOT NULL ] [DEFAULT 0], 
    registered_dttm DATETIME [NOT NULL ] , 
    modified_ts TIMESTAMP [NOT NULL] [DEFAULT CURRENT_TIMESTAMP], 
    gender ENUM('Female', 'Male') [NOT NULL], 
    hobby SET('Reading', 'Game' , 'Sports'), 
    profile TEXT [NOT NULL], 
    session_data BLOB, 
    PRIMARY KEY (member_id), 
    UNIQUE INDEX ux_nickname (nickname), 
    INDEX ix_registereddttm (registered_dttm) 
    ) ENGINE=INNODB; 
```
TEMPORARY 키워드를 사용하면 해당 데이터베이스 커넥션(세션)에서만 사용 가능한 임시 테이블을 생성한다. 테이블의 생성 또한 데이터베이스와 마찬가지로 이미 같은 이름의 테이블이 있으면 에러가 발생 하는데, "IF NOT EXISTS" 옵션을 사용하면 에러를 무시한다. MySQL은 테이블을 정의한 스크립트 마지 막에 테이블이 사용할 스토리지 엔진을 결정하기 위해 ENGINE이라는 키워드를 사용할 수 있다. 위 쿼리 에서는 ENGINE=InnoDB라고 정의했기 때문에 이 테이블은 InnoDB 스토리지 엔진을 사용하는 테이블로 생성된다. 별도로 ENGINE이 정의되지 않으면 MySQL 8.0에서는 InnoDB 스토리지 엔진이 기본으로 사용된다. 

각 칼럼은 `칼럼명 + 칼럼타입 + [타입별 옵션] + [NULL여부] + [기본값]`의 순서로 명시하고, 타입별 로 다음과 같은 옵션을 추가로 사용할 수 있다. 


- 모든 칼럼은 공통적으로 칼럼의 초깃값을 설정하는 DEFAULT 절과 칼럼이 NULL을 가질 수 있는지 여부를 설정하기 위해 NULL 또는 NOT NULL 제약을 명시할 수 있다.
- 문자열 타입은 타입 뒤에 반드시 칼럼에 최대한 저장할 수 있는 문자 수를 명시해야 한다. 그리고 CHARACTER SET 절은 칼럼에 저장되는 문자열 값이 어떤 문자 집합을 사용할지를 결정하고, COLLATE로 문자열 비교나 정렬 규칙을 나타내기 위한 콜레이션을 설정할 수 있다. CHARACTER SET만 설정되면 해당 문자 집합의 기본 콜레이션이 자동으로 사용된다.
- 숫자 타입은 선택적으로 길이를 가질 수 있지만, 이는 실제 칼럼에 저장될 값이 길이를 의미하는 것이 아니라 단순히 값을 표시할 때 보여줄 길이를 지정하는 것이다.
- MySQL 5.5 버전까지는 DATE나 DATETIME 타입은 기본 값을 명시할 수 없었지만, MySQL 5.6 버전부터는 DATE와 DATETIME 타입 그리고 TIMESTAMP 타입 모두 자동으로 현재 시간으로 업데이트되도록 기본 값을 명시할 수 있다.
- ENUM 또는 SET 타입은 타입의 이름 뒤에 해당 칼럼이 가질 수 있는 값을 괄호로 정의해야 한다.

### 테이블 구조 조회
MySQL에서 테이블의 구조를 확인하는 방법은 SHOW CREATE TABLE 명령과 DESC 명령으로 두 가지가 있다.

#### SHOW CREATE TABLE
SHOW CREATE TABLE 명령을 사용하면 테이블의 CREATE TABLE 문장을 표시해준다. 하지만 **SHOW CREATE TABLE 명령의 결과가 최초 테이블을 생성할 때 사용자가 실행한 내용을 그대로 보여주는 것은 아니다.** MySQL 서버가 테이블의 메타 정보를 읽어서 이를 CREATE TABLE 명령으로 재작성해서 보여주는 것이다. 하지만 이 명령은 특별한 수정 없이 바로 사용할 수 있는 CREATE TABLE 명령을 만들어 주기 때문에 상당히 유용하다.

SHOW CREATE TABLE 명령은 칼럼의 목록과 인덱스, 외래키 정보를 동시에 보여주기 때문에 SQL을 튜닝하거나 테이블의 구조를 확인할 때 주로 이 명령을 사용한다.

#### DESC
DESC 명령은 DESCRIBE의 약어 형태의 명령으로 둘 모두 같은 결과를 보여준다. DESC 명령은 테이블의 칼럼 정보를 보기 편한 표 형태로 표시해준다. 하지만 인덱스 칼럼의 순서나 외래키, 테이블 자체의 속성을 보여주지는 않으므로 테이블의 전체적인 구조를 한 번에 확인하기 어렵다.

### 테이블 구조 변경
테이블의 구조를 변경하려면 ALTER TABLE 명령을 사용한다. ALTER TABLE 명령은 테이블 자체의 속성을 변경할 수 있을 뿐만 아니라 인덱스의 추가 삭제나 칼럼을 추가/삭제하는 용도로도 사용된다.

ALTER TABLE 명령 테이블 자체 옵션과 칼럼, 인덱스 등 거의 대부분의 스키마를 변경하는 작업에 사용된다. 해당 명령으로 테이블의 스토리지 엔진을 변경할 수 있다. 스토리지 명령 변경은 내부적인 테이블의 저장소를 변경하는 것이라서 항상 테이블의 모든 레코드를 복사하는 작업이 필요하다. ALTER TABLE 문장에 명시된 ENGINE이 기존과 동일하더라도 테이블의 데이터를 복사하는 작업은 실행되기 때문에 주의해야 한다. 이 명령은 실제 테이블의 스토리지 엔진을 변경하는 목적으로도 사용하지만 테이블 데이터를 리빌드하는 목적으로도 사용한다. 테이블 리빌드 작업은 주로 레코드의 삭제가 자주 발생하는 테이블에서 데이터가 저장되지 않은 빈 공간을 제거해 디스크 사용 공간을 줄이는 역할을 한다.

### 테이블 명 변경

MySQL 서버에서 테이블명을 변경하려면 RENAME TABLE 명령을 이용하면 된다. 

RENAME TABLE 명령은 단순히 테이블의 이름 변경뿐만 아니라 다른 데이터베이스로 테이블을 이동할 때도 사용할 수 있다.

동일 데이터베이스 내에서 테이블의 이름만 변경하는 작업은 단순히 메타 정보만 변경하기 때문에 매우 빠르게 처리된다. 하지만 **데이터베이스를 변경하는 경우에는 메타 정보뿐만 아니라 테이블이 저장된 파일까지 다른 디렉터리(데이터베이스별로 별도 디렉터리가 할당되기 때문)로 이동**해야 한다. 그런데 db1과 db2 데이터베이스가 서로 다른 파티션에 만들어졌다고 가정해보자. 일반적으로 유닉스나 윈도우에서 서로 다른 파티션으로 파일을 이동할 때는 데이터 파일을 먼저 복사하고 복사를 완료하면 원본 파티션의 파일을 삭제하는 형태로 처리한다. MySQL 서버의 RENAME TABLE에서도 똑같이 작동한다. **RENAME TABLE을 이용해 테이블을 db1 에서 db2로 이동할 때 db1과 db2가 서로 다른 운영체제의 파일 시스템을 사용하고 있었다면 이 RENAME TABLE 명령은 데이터 파일의 복사 작업이 필요하기 때문에 데이터 파일의 크기에 비례해서 시간이 소요될 것이다.** 때로는 일정 주기로 테이블을 교체(Swap)해야 하는 경우도 있다. 현재 batch라는 테이블이 응용 프로그램에서 사용 중이며, batch_new라는 테이블을 생성하고 새로운 데이터를 저장하고자 한다. 그리고 최종적으로 응용 프로그램에서 사용할 수 있게 batch_new 테이블을 batch라는 이름으로 변경하는 방식으 로 다음과 같이 배치 프로그램을 작성했다고 가정해보자. 배치 프로그램이 작성되면 마지막의 기존 테이블과 신규 테이블을 교체하는 동안 일시적으로 batch 테이블이 없어지는 시점이 발생한다. 2개의 RENAME TABLE 명령이 얼마나 간격을 두고 실행되느냐에 따라 시간은 더 길어질 수도 있다. 이 시점 동안 응용 프로그램은 batch 테이블을 찾지 못해서 에러를 발생시키게 된다. 이 같은 문제점을 막기 위해 MySQL 서버의 RENAME TABLE 명령은 다음과 같이 여러 테이블의 RENAME 명령을 하나의 문장으로 묶어서 실행할 수 있다. 

여러 테이블의 RENAME 명령을 하나의 문장으로 묶으면 MySQL 서버는 RENAME TABLE 명령에 명 시된 모든 테이블에 대해 잠금을 걸고 테이블의 이름 변경 작업을 실행하게 된다. 응용 프로그램의 입장에서 보면 batch 테이블을 조회하려고 할 때 이미 잠금이 걸려있기 때문에 대기한다. 그리고 RENAME TABLE 명령이 완료되면 batch 테이블의 잠금이 해제되어 batch 테이블(batch_new 테이블이 batch 테이블 로 변경된 후)의 읽기를 실행한다. 즉 쿼리가 시작될 때와 실제 쿼리를 실행할 때의 대상 테이블이 변경 됐지만 응용 프로그램은 이를 알아차리지 못하고 투명하게 실행되는 것이다. 잠깐의 잠금 대기가 발생하는 것이지 에러가 발생하지는 않는다.

### 테이블 상태 조회 
MySQL의 모든 테이블은 만들어진 시간, 대략의 레코드 건수, 데이터 파일의 크기 등의 정보를 가지고 있다. 또한 데이터 파일의 버전이나 레코드 포맷 등과 같이 자주 사용되지는 않지만 중요한 정보도 가지고 있는데, 이러한 정보를 조회할 수 있는 명령이 "SHOW TABLE STATUS "다. SHOW TABLE STATUS 명 령은 "LIKE '패턴'"과 같은 조건을 사용해 특정 테이블의 상태만 조회하는 것도 가능하다. 위의 SHOW TABLE STATUS 명령 결과를 보면 테이블이 어떤 스토리지 엔진을 사용하는지, 그리고 데이터 파일의 포맷으로 무엇을 사용하고 있는지 등을 조회할 수 있다. 때로는 테이블의 크기가 너무 커서 테이블의 전체 레코드 건수가 궁금한 경우에도 SHOW TABLE STATUS 명령을 유용하게 사용할 수 있다. 위의 결과에서는 대략 30만 건의 레코드를 가지고 있다는 것을 알 수 있다. 그리고 레코드 하나의 평균 크기가 대략 50바이트라는 점도 확인할 수 있다. 여기에 출력되는 레코드 건수나 레코드 평균 크기는 MySQL 서버가 예측하고 있는 값이기 때문에 테이블이 너무 작거나 너무 크면 오차가 더 커질 수도 있다. 참고 위의 예제 쿼리에서 마지막에 사용된 "\G"는 레코드의 칼럼을 라인당 하나씩만 표현하게 하는 옵션이다. 또한 "\G"는 SQL 문장의 끝을 의미하기도 하기 때문에 "\G"가 있으면 별도로 ";"를 붙이지 않아도 쿼리 입력이 종료된 것 으로 간주한다. 레코드의 칼럼 개수가 많거나 각 칼럼의 값이 너무 긴 경우에는 쿼리의 마지막에 "\G"를 사용해 결과 를 좀 더 가독성 있게 출력할 수 있다.

information_schema 데이터베이스에는 MySQL 서버가 가진 스키마들에 대한 메타 정보를 가진 딕셔너 리 테이블이 관리된다. information_schema 데이터베이스에 존재하는 테이블들은 실제로 존재하는 테이 블이 아니라 MySQL 서버가 시작되면서 데이터베이스와 테이블 등에 대한 다양한 메타 정보를 모아서 메모리에 모아두고 사용자가 참조할 수 있는 테이블이다. information_schema 데이터베이스의 TABLES 또 는 COLUMNS 뷰를 이용하면 데이터베이스 서버에 대한 많은 정보를 얻을 수 있다. 대표적으로 다음과 같 은 쿼리로 MySQL 서버에 존재하는 테이블들이 사용하는 디스크 공간 정보를 조회할 수도 있다.

### 테이블 구조 복사
테이블의 구조는 같지만 이름만 다른 테이블을 생성할 때는 SHOW CREATE TABLE 명령을 이용해 테이블의 생성 DDL을 조회한 후에 조금 변경해서 만들 수도 있다. 또한 CREATE TABLE ... AS SELECT ... LIMIT 0 명령으로 테이블을 생성할 수 있다. 하지만 SHOW CREATE TABLE 명령을 이용하면 내용을 조금 변경해야 할 수도 있으며, CREATE TABLE ... AS SELECT ... LIMIT 0은 인덱스가 생성되지 않는다는 단점이 있다. 데이터는 복사하지 않고 테이블의 구조만 동일하게 복사하는 명령으로 "CREATE TABLE ... LIKE"를 사용하면 구조가 같은 테이블을 손쉽게 생성할 수 있다.

### 테이블 삭제
일반적으로 MySQL에서 레코드가 많지 않은 테이블을 삭제하는 작업은 서비스 도중이라고 하더라도 문제가 되지 않는다. MySQL 8.0 버전에서는 특정 테이블을 삭제하는 작업이 다른 테이블의 DML이나 퀴리를 직접 방해하지는 않는다. MySQL 서버에서 테이블 삭제는 DROP TABLE 명령으로 실행한다. 

```sql
mysql> DROP TABLE [ IF EXISTS ] table1; 
```
하지만 용량이 매우 큰 테이블을 삭제하는 작업은 상당히 부하가 큰 작업에 속한다. 테이블이 삭제되면 MySQL 서버는 해당 테이블이 사용하던 데이터 파일을 삭제해야 하는데, 이 파일의 크기가 매우 크고 디스크에서 파일의 조각들이 너무 분산되어 저장돼 있다면 많은 디스크 읽고 쓰기 작업이 필요하다. MySQL 서버의 디스크 읽고 쓰기 부하가 높아지면 다른 커넥션의 쿼리 처리 성능이 떨어질 수도 있다. 테이블 삭제가 직접 다른 커넥션의 쿼리를 방해하지는 않지만 간접적으로는 영향을 미칠 수도 있다. 그래서 **테이블이 크다면 서비스 도중에 삭제 작업(DROP TABLE)은 수행하지 않는 것이 좋다.** 

MySQL 서버의 데이터 파일이 리눅스의 ext3 파일 시스템을 사용하는 경우 파일의 조각이 디스크의 이곳저곳에 분산되어 저장된다. 이로 인해 ext3 파일 시스템의 경우 대용량 테이블 삭제 작업은 디스크 읽고 쓰기 작업을 상당히 많이 발생시킬 수도 있다. 하지만 최근에 많이 사용되는 리눅스 운영체제에서는 대부분 ext4 파일 시스템 또는 xfs 를 사용하는데, 이 경우 파일 삭제 시 디스크 읽고 쓰기 작업이 많이 줄어들었다. 아직 ext3 파일 시스템을 사용한다면 테이블을 삭제할 때 주의하자. 

테이블 삭제에서 한 가지 더 주의해야 하는 것은 InnoDB 스토리지 엔진의 어댑티브 해시 인덱스 (Adaptive hash index)다. 어댑티브 해시 인덱스는 InnoDB 버퍼 풀의 각 페이지가 가진 레코드에 대한 해시 인덱스 기능을 제공하는데, 어댑티브 해시 인덱스가 활성화돼 있는 경우 테이블이 삭제되면 어댑티브 해시 인덱스 정보도 모두 삭제해야 한다. 어댑티브 해시 인덱스가 삭제될 테이블에 대한 정보를 많이 가지고 있다면 **어댑티브 해시 인덱스 삭제 작업으로 인해 MySQL 서버의 부하가 높아지고 간접적으로 다른 쿼리 처리에 영향을 미칠 수도 있다.** 어댑티브 해시 인덱스는 자주 사용되는 테이블에 대해서만 해시 인덱스를 빌드하기 때문에 거의 사용되지 않는 테이블이었다면 크게 문제되지 않을 수 도 있다. 어댑티브 해시 인덱스는 테이블 삭제뿐만 아니라 테이블의 스키마 변경에도 영향을 미칠 수 있다. 

## 칼럼 변경 
테이블 구조 변경 작업은 대부분 칼럼을 추가하거나 칼럼 타입을 변경하는 작업이다. ALTER TABLE 명령 을 이용한 칼럼 추가 및 삭제, 칼럼 이름 변경, 칼럼 타입 변경에 대해 간단히 살펴보자. 
### 칼럼 추가 
MySQL 8.0 버전으로 업그레이드되면서 테이블의 칼럼 추가 작업은 대부분 INPLACE 알고리즘을 사용 하는 온라인 DDL로 처리가 가능하다. 그뿐만 아니라 칼럼을 테이블의 제일 마지막 칼럼으로 추가하는 경우에는 INSTANT 알고리즘으로 즉시 추가된다. 
```sql
- // 테이블의 제일 마지막에 새로운 칼럼을 추가 
mysql> ALTER TABLE employees ADD COLUMN emp_telno VARCHAR(20), ALGORITHM=INSTANT; 

// 테이블의 중간에 새로운 칼럼을 추가 
mysql> ALTER TABLE employees ADD COLUMN emp_telno VARCHAR(20) AFTER emp_no , ALGORITHM=INPLACE, LOCK=NONE; 
```

위 예제의 첫 번째 DDL 문장은 테이블의 마지막에 새로운 칼럼을 추가하므로 INSTANT 알고리즘으로 즉시 추가가 가능하다. 하지만 두 번째 예제는 테이블의 기존 칼럼 중간에 새로 추가하기 때문에 테이 블의 리빌드가 필요하다. 그래서 INSTANT 알고리즘으로 처리가 불가능하며, INPLACE 알고리즘으로 처리 돼야 한다. 그래서 테이블이 큰 경우라면 가능하다면 칼럼을 테이블의 마지막 칼럼으로 추가하는 것이 좋다.


### 칼럼 삭제
칼럼을 삭제하는 작업은 항상 테이블의 리빌드를 필요로 하기 때문에 INSTANT 알고리즘을 사용할 수 없다. 그래서 항상 INPLACE 알고리즘으로만 칼럼 삭제가 가능하다.


### 칼럼 이름 및 칼럼 타입 변경

칼럼의 이름이나 타입을 변경하는 방법은 다음과 같다. 칼럼의 타입 변경은 현재 칼럼의 타입과 변경하 고자 하는 데이터 타입에 따라 매우 다양한 형태가 될 수 있는데, 여기서는 간략하게 자주 사용되는 타 입 변환만 살펴보자. 
```sql
- // 칼럼의 이름 변경 mysql> ALTER TABLE salaries CHANGE to_date end_date DATE NOT NULL, ALGORITHM=INPLACE, LOCK=NONE; 一 // INT 칼럼을 VARCHAR 타입으로 변경 mysq1> ALTER TABLE salaries MODIFY salary VARCHAR(20), ALGORITHM=COPY, LOCK=SHARED;

/ // VARCHAR 타입의 길이 확장 mysql> ALTER TABLE employees MODIFY last_name VARCHAR(30) NOT NULL, ALGORITHM=INPLACE, LOCK=NONE; // VARCHAR 타입의 길이 축소 mysq1> ALTER TABLE employees MODIFY last_name varchar(10) NOT NULL ALGORITHM=COPY, LOCK=SHARED;
```
- 첫 번째 DDL은 salaries 테이블의 to_date 칼럼의 이름만 end_date로 변경하는 예제다. 이렇게 칼럼의 이름만 변경하는 작업은 INPLACE 알고리즘을 사용하지만 실제 데이터 리빌드 작업은 필요치 않다. 그래서 INSTANT 알고리 즘과 같이 빠르게 작업이 완료된다. 
- 두 번째 DDL은 INT 타입의 칼럼을 VARCHAR 타입으로 변경하는 예제다. 이렇게 칼럼의 데이터 타입이 변경되는 경 우 COPY 알고리즘이 필요하며 온라인 DDL로 실행돼도 스키마 변경 도중에는 테이블의 쓰기 작업은 불가하다. 
- 세 번째 DDL은 VARCHAR 타입의 길이를 16에서 30으로 변경하는 예제다. VARCHAR 타입의 길이를 확장하는 경우는 현재 길이와 확장하는 길이의 관계에 따라 테이블의 리빌드가 필요할 수도 있고 아닐 수도 있다. 이에 대해서는 다 시 자세히 살펴보겠다. 
- 네 번째 DDL은 VARCHAR 타입의 길이를 16에서 10으로 변경하는 예제다. VARCHAR 타입의 길이를 축소하는 경우는 완전히 다른 타입으로 변경되는 경우와 같이 COPY 알고리즘을 사용해야 한다. 그리고 스키마를 변경하는 중 해당 테 이블의 데이터 변경은 허용되지 않으므로 LOCK은 SHARED로 사용돼야 한다. 

아마도 칼럼의 타입을 변경하는 경우 중 가장 빈번한 경우가 VARCHAR나 VARBINARY 타입의 길이를 확장하 는 것일 것이다. VARCHAR나 VARBINARY 타입의 경우 칼럼의 최대 허용 사이즈는 메타데이터에 저장되지만 실제 칼럼이 가지는 값의 길이는 데이터 레코드의 칼럼 혜더에 저장된다. 그런데 값의 길이를 위해서 사용하는 공간의 크기는 VARCHAR 칼럼이 최대 가질 수 있는 바이트 수만큼 필요하다. 즉 칼럼값의 길이 저장용 공간은 칼럼의 값이 최대 가질 수 있는 바이트 수가 255 이하인 경우 1바이트만 사용하며, 256 바이트 이상인 경우 2바이트를 사용한다. 그래서 동일한 값이라고 하더라도 VARCHAR(10) 칼럼에 저장될 때보다 VARCHAR( 1000) 칼럼에 저장될 때는 1바이트를 더 사용한다. 

INPLACE 알고리즘으로 VARCHAR(10)에서 VARCHAR(20)으로 변경하는 경우라면 둘 다 255바이트 이하이므 로 테이블 리빌드가 필요 없다. 하지만 UTF8MB4 문자 셋을 사용하는 경우 VARCHAR(10)에서 VARCHAR(64) 로 변경하는 경우에는 테이블 리빌드가 필요하다. UTF8MB4 문자 셋은 한 글자가 최대 4바이트를 사용할 수 있기 때문에 VARCHAR(64)는 최대 256바이트를 사용한다. 그래서 이 경우에는 칼럼값의 길이를 1바 이트에서 2바이트로 변경해야 하므로 테이블의 레코드 전체를 다시 리빌드해야 한다. 

## 인덱스 변경 
MySQL 8.0 버전에서는 대부분의 인덱스 변경 작업이 온라인 DDL로 처리 가능하도록 개선됐다. 여기 서는 인덱스의 종류별로 추가 및 변경, 삭제하는 방법을 살펴보겠다. 주의 MySQL 서버에서 전문 검색 인덱스와 공간 검색 인덱스를 제외하면 나머지 인덱스는 모두 B-Tree 자료 구 조를 사용한다. MySQL 서버의 매뉴얼에서는 "USING BTREE" 또는 "USING HASH" 절을 이용해 해시 인덱스를 지 원하는 것으로 보이지만 "USING HASH" 절은 MySQL Cluster (NDB)를 위한 옵션이지 MySQL 서버의 InnoDB나 MyISAM 스토리지 엔진을 위한 옵션이 아니다. 그래서 이 책에서는 해시 인덱스에 대한 설명은 생략하겠다.

### 인덱스 추가 
MySQL 서버에서 사용 가능한 인덱스의 종류나 인덱싱 알고리즘별로 대략 사용 가능한 ALTER TABLE ADO INDEX 문장의 형태를 나열해봤다. 다음 예제에서는 각 인덱스의 종류나 알고리즘별로 온라인 DDL 이 가능한지, 어떤 알고리즘과 잠금으로 생성 가능한지도 함께 추가했다. 
```sql
mysql> ALTER TABLE employees ADD PRIMARY KEY (emp_no), ALGORITHM=INPLACE, LOCK=NONE; 

mysql> ALTER TABLE employees ADD UNIQUE INDEX ux_empno (emp_no) , ALGORITHM=INPLACE, LOCK=NONE; 

mysq1> ALTER TABLE employees ADD INDEX ix_lastname (last_name), ALGORITHM=INPLACE, LOCK=NONE; 

mysql> ALTER TABLE employees ADD FULLTEXT INDEX fx_firstname_lastname (first_name, last_name), ALGORITHM=INPLACE, LOCK=SHARED; 

mysql> ALTER TABLE employees ADD SPATIAL INDEX fx_loc (last_location), ALGORITHM=INPLACE, LOCK=SHARED; 
```
전문 검색을 위한 인덱스와 공간 검색을 위한 인덱스는 INPLACE 알고리즘으로 인덱스 생성이 가능하지 만 SHARED 잠금이 필요하다는 것을 알 수 있다. 그러나 나머지 B-Tree 자료 구조를 사용하는 인덱스의 추가는 프라이머리 키라고 하더라도 INPLACE 알고리즘에 잠금 없이 온라인으로 인덱스 생성이 가능한 것을 알 수 있다.

### 인덱스 조회

MySQL 서버에서 인덱스의 목록을 조회할 때는 SHOW INDEXES 명령을 사용하거나 SHOW CREATE TABLE 명령으로 표시되는 테이블 생성 명령을 참조하자.

SHOW INDEXES 명령은 테이블의 인덱스만 표시하는데, 인덱스 칼럼별로 한 줄 씩 표시해준다.
- Key_name 칼럼: 인덱스의 이름을 나타낸다.
- Seq_in_index 칼럼: 값은 인덱스에서 해당 칼럼의 위치를 보여준다. 단일 칼럼으로 생성된 인덱스는 Seq_in_index 칼럼이 1만 표시되며, 복합 칼럼 인덱스인 경우 Seq_in_index 칼럼의 값이 1부터 2, 3, 4 ... 형태로 증가한다.
- Cardinality 칼럼: 인덱스에서 해당 칼럼까지의 유니크한 값의 개수를 보여준다. 단일 칼럼으로 구성된 인덱스의 경우 해당 칼럼이 가지는 유티크한 값의 개수를 표시하지만 복합 칼럼 인덱스인 경우 인덱스의 첫 번째 칼럼부터 해당 칼럼까지의 조합으로 유니크한 값의 개수를 표시한다.


### 인덱스 이름 변경

쿼리 문장에서 인덱스의 이름을 힌트로 사용하면 MySQL 서버에서 해당 인덱스를 삭제하거나 다른 인 덱스로 대체하는 경우 응용 프로그램의 코드를 변경해야 했다. 물론 인덱스를 삭제하고 동일 이름으로 새로운 인덱스를 생성하면 되지만 이 순서로 작업을 실행하면 새로운 인덱스를 생성하는 동안 필요한 인덱스가 없어지므로 손쉽게 작업하기가 어려웠다. 사실 이는 간단히 인덱스의 이름만 변경할 수 있다 면 새로운 인덱스로 기존 인덱스를 대체할 수 있지만 MySQL 5.6 버전까지도 인덱스의 이름을 변경할 수 있는 방법이 없었다. MySQL 5.7 버전부터는 다음과 같이 인덱스의 이름을 변경할 수 있게 됐다. 

```sql
mysql> ALTER TABLE salaries RENAME INDEX ix_salary T0 ix_salary2, ALGORITHM=INPLACE, LOCK=NONE; 
```
인덱스의 이름을 변경하는 작업은 INPLACE 알고리즘을 사용하지만 실제 테이블 리빌드를 필요로 하지 는 않는다. 그래서 응용 프로그램에서 힌트로 해당 인덱스의 이름을 사용 중이라고 하더라도 짧은 시 간에 인덱스를 교체할 수 있게 됐다. 다음 예제는 employees 테이블이 이미 가지고 있던"ix_firstname (first_name)"를 대신해서 "ix_firstname (first_name, last_name)" 인덱스를 교체하는 작업 방식을 보 여준다.

### 인덱스 가시성 변경 
MySQL 서버에서 인덱스를 삭제하는 작업은 ALTER TABLE DROP INDEX 명령으로 즉시 완료된다. 하지만 한 번 삭제된 인덱스를 새로 생성하는 것은 매우 많은 시간이 걸릴 수도 있다. 특정 인덱스를 사용하지 않는다고 판단하고 삭제했는데, 실제 그 인덱스를 사용하는 쿼리가 있었다면 어떻게 될지는 이미 예측 할 수 있을 것이다. 최악의 경우에는 응용 프로그램의 서비스를 멈추고, 인덱스를 다시 생성하고 응용 프로그램을 다시 시작해야 한다. 그래서 인덱스나 테이블을 삭제하는 작업은 데이터베이스 관리자에게 는 매우 긴장되는 작업이었으며, 이러한 이유로 데이터베이스 서버의 인덱스는 한 번 생성되면 거의 삭 제하지 못하는 경우가 많다. 하지만 MySQL 8.0 버전부터는 인덱스의 가시성을 제어할 수 있는 기능이 도입됐다. 인덱스의 가시성 이란 MySQL 서버가 쿼리 실행할 때 해당 인덱스를 사용할 수 있게 할지 말지를 결정하는 것이다. 다 음 예제는 응용 프로그램의 쿼리에서 특정 인덱스가 사용되지 못하게 하는 DDL 문장이다. 
```sql
mysq1> ALTER TABLE employees ALTER INDEX ix_firstname INVISIBLE; 
```
인덱스가 INVISIBLE 상태로 변경되면 MySQL 옵티마이저는 INVISIBLE 상태의 인덱스는 없는 것으로 간 주하고 실행 계획을 수립한다. 다음 예제는 first_name 칼럼의 인덱스가 INVISIBLE 상태로 바뀌기 전과 후의 실행 계획 변화를 보여준다. 

INVISIBLE 상태의 인덱스를 다시 사용할 수 있게 하려면 VISIBLE 옵션을 명시하면 된다. `ALTER TABLE ALTER INDEX ... [VISIBLE I INVISIBLE]` 명령은 메타데이터만 변경하기 때문에 온라인 DDL로 실행되는지 여부를 고려하지 않아도 된다. MySQL 8.0 버전부터는 인덱스를 삭제하기 전에 먼저 해당 인덱스를 보이지 않게 변경해서 하루 이틀 정도 상황을 모니터링한 후 안전하게 인덱스를 삭제 할 수 있게 됐다. 그뿐만 아니라 최초 인덱스를 생성할 때도 가시성을 설정할 수 있다. SHOW CREATE TABLE 명령으로 블의 구조를 살펴보면 추가된 ix_firstname_lastname 인덱스의 끝부분에 "INVISIBLE" 키워드가 설정된 것을 확인할 수 있다.

새로운 인덱스를 생성하는 것은 크게 문제되지 않을 거라고 생각할 수도 있다. 하지만 비슷한 칼럼으로 구성된 인덱스가 많아지면 MySQL 옵티마이저는 기존에 사용하던 인덱스와는 다른 인덱스를 사용할 수도 있다. 물론 더 성능이 빨라질 수도 있지만 성능이 더 악화될 수도 있다. 이러한 부분이 우려된다면 인덱스를 처음 생성할 때는 INVISIBLE 인덱스로 생성하고, 적절히 부하가 낮은 시점을 골라서 인덱스를 VISIBLE로 변경하면 된다. 서버의 성능이 떨어진다면 다시 INVISIBLE로 바꾸고 원인을 좀 더 분석해볼 수도 있다. 즉 인덱스를 생성하고 삭제하는 작업을 하지 않고도 쿼리가 인덱스를 사용할지 말지를 변경 할 수 있게 됐다. MySQL 서버의 optimizer_switch 시스템 변수에 use_invisible_indexes 옵션이 ON 으로 설정된 경우 MySQL 옵티마이저는 쿼리가 INVISIBLE 상태의 인덱스도 사용할 수 있게 한다. optimizer_switch의 use_invisible_indexes 옵션의 기본값은 OFF로 설정돼 있다. 
### 인덱스 삭제 
ALTER TABLE DROP INDEX 명령으로 삭제할 수 있다. MySQL 서버의 인덱스 삭제는 일반적으로 매우 빨리 처리된다. 세컨더리 인덱스 삭제 작업은 INPLACE 알고리즘을 사용하지만 실제 테이블 리빌드를 필요로 하지는 않는다. 하지만 프라이머리 키의 삭제 작업은 모든 세컨더리 인덱스의 리프 노드에 저장된 프라이머리 키 값을 삭제해야 하기 때문에 임시 테이블로 레코드를 복사해서 테이블을 재구축 해야 한다. 다음 예제는 종류별로 인덱스를 삭제하는 명령이다. 프라이머리 키 삭제는 COPY 알고리즘을 사용해야 하며, 프라이머리 키 삭제 도중 레코드 쓰기는 불가능한 SHARED 모드의 잠금이 필요하다.

## 테이블 변경 묶음 실행 
하나의 테이블에 대해 여러 가지 스키마 변경을 해야 하는 경우 개별 ALTER TABLE 명령을 차례대로 실행 하는 경우를 본 적이 있다. 온라인 DDL로 빠르게 스키마 변경을 처리할 수 있다면 개별로 실행하는 것이 좋지만 그렇지 않다면 모아서 실행하는 것이 효율적이다. 

2개의 ALTER TABLE 명령으로 인덱스를 각각 생성하면 인덱스를 생성할 때마다 테이블의 레코드를 풀 스캔해서 인덱스를 생성하게 된다. 하지만 하나의 ALTER TABLE 명령으로 모아서 실행하면 MySQL 서버는 테이블의 레코드를 한 번만 풀 스캔해서 2개의 인덱스를 한꺼번에 생성할 수 있게 된다. 

물론 2개의 인덱스를 한 번에 생성하면 인덱스 하나를 생성할 때보다는 더 많은 시간이 걸리겠지만 2 개의 인덱스를 각각 ALTER TABLE 명령으로 생성하는데 걸리는 시간보다는 훨씬 시간을 단축할 수 있다. 

2개의 스키마 변경 작업이 하나는 INSTANT 알고리즘을 사용하고 다른 하나는 INPLACE 알고리즘을 사용 한다면 굳이 이렇게 모아서 실행할 필요는 없다. 가능하면 같은 알고리즘을 사용하는 스키마 변경 작업 이라면 모아서 실행하는 것이 효율적일 것이다. INPLACE 알고리즘을 사용한다고 하더라도 테이블 리빌드가 필요한 작업과 그렇지 않은 작업끼리도 구분하고 모아서 실행할 수 있다면 더 효율적으로 스키마 관리를 할 수 있다.

## 프로세스 조회 및 강제 종료 
MySQL 서버에 접속된 사용자의 목록이나 각 클라이언트 사용자가 현재 어떤 쿼리를 실행하고 있는지 SHOW PROCESSLIST 명령으로 확인할 수 있다. 

SHOW PROCESSLIST 명령의 결과에는 현재 MySQL 서버에 접속된 클라이언트의 요청을 처리하는 스레드 수만큼의 레코드가 표시된다. 각 칼럼에 포함된 값의 의미는 다음과 같다. 
- Id: MySQL 서버의 스레드 아이디이며, 쿼리나 커넥션을 강제 종료할 때는 이 칼럼(id) 값을 식별자로 사용한다. 
- User: 클라이언트가 MySQL 서버에 접속할 때 인증에 사용한 사용자 계정을 의미한다. 
- Host: 클라이언트의 호스트명이나 IP 주소가 표시된다. 
- db: 클라이언트가 기본으로 사용하는 데이터베이스의 이름이 표시된다. 
- Command: 해당 스레드가 현재 어떤 작업을 처리하고 있는지 표시한다. 
- Time: Command 칼럼에 표시되는 작업이 얼마나 실행되고 있는지 표시한다. 위의 예제에서 두 번째 라인은 53216 초 동안 SELECT 쿼리를 실행하고 있음을 보여주고, 첫 번째 라인은 이 스레드가 대기(Sleep) 상태로 527초 동안 아 무것도 하지 않고 있음을 보여준다. 
- State: Command 칼럼에 표시되는 내용이 해당 스레드가 처리하고 있는 작업의 큰 분류를 보여준다면 State 칼럼 에는 소분류 작업 내용을 보여준다. 이 칼럼에 표시될 수 있는 내용은 상당히 많다. 자세한 내용은 MySQL 매뉴얼의 "스레드의 상태 모니터링"21을 참조하자. 
- Info: 해당 스레드가 실행 중인 쿼리 문장을 보여준다. 쿼리는 화면의 크기에 맞춰서 표시 가능한 부분까지만 표시 된다. 쿼리의 모든 내용을 확인하려면 SHOW FULL PROCESSLIST 명령을 사용하면 된다.

SHOW PROCESSLIST 명령은 MySQL 서버가 어떤 상태인지를 판단하는 데도 많은 도움이 된다. 일반적으로 쾌적한 상태로 서비스되는 MySQL에서는 대부분 프로세스의 Command 칼럼이 Sleep 상태로 표시된다. 그런데 Command 칼럼의 값이 "Query"이면서 Time이 상당히 큰 값을 가지고 있다면 쿼리가 상당히 장 시간 실행되고 있음을 의미한다. SHOW PROCESSLIST의 결과에서 특별히 관심을 둬야 할 부분은 State 칼럼의 내용이다. State 칼럼에 표시 될 수 있는 값은 종류가 다양한데, 대표적으로 "Copying ... " 그리고 "Sorting ..."으로 시작하는 값들 이 표시될 때는 주의 깊게 살펴봐야 한다. 각 Command나 State 칼럼에 표시될 수 있는 내용은 "스레드의 상태 모니터링"을 참고한다. 

SHOW PROCESSLIST 명령의 결과에서 Id 칼럼값은 접속된 커넥션의 요청을 처리하는 전용 스레드의 번호 를 의미한다. 특정 스레드에서 실행 중인 쿼리나 커넥션 자체를 강제 종료하려면 KILL 명령을 사용하면 된다. 
```sql
mysql> KILL QUERY 4228; 
mysql> KILL 4228; 
```
위 예제의 첫 번째 명령은 아이디가 4228인 스레드가 실행 중인 쿼리는 강제 종료시키지만 커넥션 자 체는 그대로 유지한다. 반면 두 번째 명령은 해당 4228번 스레드가 실행하고 있는 쿼리뿐만 아니라 해 당 커넥션까지 강제 종료시키는 명령이다. 커넥션이 강제 종료되면 그 커넥션에서 처리하고 있던 트랜 잭션은 자동으로 롤백 처리된다. 
## 활성 트랜잭션 조회 
쿼리가 오랜 시간 실행되고 있는 경우도 문제지만 트랜잭션이 오랜 시간 완료되지 않고 활성 상태로 남아있는 것도 MySQL 서버의 성능에 영향을 미칠 수 있다. MySQL 서버의 트랜잭션 목록은 다음과 같이 information_schema.innodb_trx 테이블을 통해 확인할 수 있다. 


WHERE 절을 통해 트랜잭션이 5초 이상 활성 상태로 남아있는 프로세스만 조사할 수 있다. 조회 결과를 보면 14번 프로세스(trx_mysql_thread_id 칼럼의 값)는 "root@localhost" 계정으로 접속했으며, 현재 170초(lasting_sec 칼럼의 값) 동안 활성 트랜잭션(Active Transaction) 상태를 유지하고 있다는 것을 알 수 있다. 

평상시보다 오랜 시간 트랜잭션이 활성 상태를 유지하고 있다면 information_schema.innodb_trx 테이블에서 모든 정보를 조회해서 살펴보면 이 트랜잭션이 얼마나 많은 레코드를 변경했고 얼마나 많은 레코드를 잠그고 있는지 확인할 수 있다.

위 결과의 trx_rows_modified 칼럼과 trx_rows_locked 칼럼의 값을 참조해보면 23000번 트랜잭션은 1개 의 레코드를 변경했고 1개의 레코드에 대해서 잠금을 가지고 있는 것을 확인할 수 있다. 이때 어떤 레 코드를 잠그고 있는지는 performance_schema data_locks 테이블을 참조하면 된다.

위의 결과를 보면 23000번 트랜잭션은 다음과 같이 2개의 잠금을 가지고 있다는 것을 알 수 있다. 
- employees 테이블에 대한 IX 잠금(Intention Exclusive Lock)을 가지고 있음 
- employees 테이블의 프라이머리 키의 RECORD에 대해서 배타적 잠금을 가지고 있음(LOCK_MODE 칼럼은 잠금이 갭 락은 아닌 단순 레코드 락임을 의미함)


```sql
mysql> KILL QUERY 14; 
```
이처럼 장시간에 걸쳐 트랜잭션이 쿼리를 실행 중인 상태에서 그 쿼리만 강제 종료시키면 커넥션이나 트랜잭션은 여전히 활성 상태로 남아있게 된다. 응용 프로그램에서 쿼리의 에러를 감지해서 트랜잭션 을 롤백하게 돼 있다면 다음과 같이 쿼리만 종료하면 된다. 
```sql
mysql> KILL 14; 
```
그런데 응용 프로그램에서 쿼리 에러에 대한 핸들링이 확실하지 않다면 쿼리를 종료시키는 것보다 커 넥션 자체를 강제 종료시키는 방법이 더 안정적일 수 있다. 

# 쿼리 성능 테스트 

작성된 쿼리가 얼마나 효율적이고 더 개선할 부분이 있는지 확인하려면 먼저 실행 계획을 살펴보고 문 제될 만한 부분이 있는지 검토한다. 그리고 실행 계획에 특별히 문제될 부분이 없다면 퀴리를 직접 실 행해 본다. 실행 계획상으로는 보이지 않는 부분이 더 있을 수도 있기 때문이다. 쿼리를 직접 실행해 보 면서 눈으로 성능을 체크할 때는 여러 가지 방해 요소가 있는데, 이러한 방해 요소를 간과하고 쿼리의 성능을 판단한다는 것은 매우 위험한 일이다. 여기서는 복잡한 벤치마킹 기술을 언급하려는 것이 아니 라 간단하게 쿼리의 성능을 판단해보기 위해서는 어떠한 부분을 고려해야 하고, 어떤 영향 요소가 있는 지 살펴보려는 것이다. 여기에 언급된 내용은 단순히 쿼리 테스트에만 필요한 지식이 아니라 실제 쿼리 가 실행될 때 거치는 과정을 이해하는 데도 도움이 될 것이다. 

## 쿼리의 성능에 영향을 미치는 요소 
직접 작성한 쿼리를 실행해 보고 성능을 판단할 때 가장 큰 변수는 MySQL 서버가 가지고 있는 여러 종류의 버퍼나 캐시일 것이다. 어떤 종류의 버퍼나 캐시가 영향을 미치는지 살펴보고, 이런 영향을 최 소화하는 방법도 알아보겠다. 
### 운영체제의 캐시 
MySQL 서버는 운영체제의 파일 시스템 관련 기능(시스템 콜)을 이용해 데이터 파일을 읽어온다. 그런 데 일반적으로 대부분의 운영체제는 한 번 읽은 데이터는 운영체제가 관리하는 별도의 캐시 영역에 보관해 뒀다가 다시 해당 데이터가 요청되면 디스크를 읽지 않고 캐시의 내용을 바로 MySQL 서버로 반 환한다. InnoDB 스토리지 엔진은 일반적으로 파일 시스템의 캐시나 버퍼를 거치지 않는 Direct I/O 를 사용하므로 운영체제의 캐시가 그다지 큰 영향을 미치지 않는다. 하지만 MyISAM 스토리지 엔진은 운영체제의 캐시에 대한 의존도가 높기 때문에 운영체제의 캐시에 따라 성능의 차이가 큰 편이다. 운영체제가 관리하는 캐시나 버퍼는 공용 공간이기 때문에 MySQL 서버와 같은 응용 프로그램이 종료 된다고 해도 여전히 남아있을 수 있다. 그래서 운영체제가 가지고 있는 캐시나 버퍼가 전혀 없는 상태 에서 쿼리의 성능을 테스트하려면 다음과 같이 운영체제의 캐시 삭제 명령을 실행하고 테스트하는 것 이 좋다. 다음 예제는 리눅스 서버의 캐시를 제거하는 명령이며, 운영체제별로 캐시를 제거하는 명령이 나 방법은 다를 수 있다. 

```bash
## 좋은 캐시나 버퍼의 내용을 디스크와 동기화한다. 
linux> sync

## 운영체제에 포함된 캐시의 내용을 초기화한다. 
linux> echo 3 > /proc/sys/vm/drop_caches 
```

### MySQL 서버의 버퍼 풀
운영체제의 버퍼나 캐시와 마찬가지로 MySQL 서버에서도 데이터 파일의 내용을 페이지(또는 블록) 단위로 캐시하는 기능을 제공한다. InnoDB 스토리지 엔진이 관리하는 캐시를 버퍼 풀이라고 한다. InnoDB의 버퍼 풀은 인덱스 페이지는 물론이고 데이터 페이지까지 캐시하며, 쓰기 작업을 위한 버퍼링 작업까지 겸해서 처리한다. MySQL 서버가 한번 시작되면 InnoDB의 버퍼 풀과 MyISAM의 키 캐시의 내용을 강제 로 퍼지(Purge, 삭제)할 수 있는 방법이 없다. MySQL 서버에 포함된 키 캐시나 버퍼 풀을 초기화하려 면 MySQL 서버를 재시작해야 한다. 특히 InnoDB의 버퍼 풀은 MySQL 서버가 종료될 때 자동으로 덤프됐다가 다시 시작될 때 자동으로 적재된다. 그래서 InnoDB의 버퍼 풀이 자동으로 덤프되고 적재되지 않게 innodb_buffer_pool_loadat_startup 시스템 변수를 OFF로 설정한 후 재시작해야 한다. MySQL 서버가 종료될 때 버퍼 풀의 내용 을 덤프하지 않고자 한다면 innodb_buffer_pool dump_at_shutdown 시스템 변수도 OFF로 변경하면 된다. MySQL 8.0 버전에서는 이 두 개 시스템 변수가 모두 기본값인 ON 으로 설정돼 있다.

```sql
mysql> SET GLOBAL innodb_buffer* *pool_dump_at__shutdown=OFF; 
mysq1> SET GLOBAL innodb_buffer_pool_load_at_startup=0FF; 
```
### 독립된 MySQL 서버 
버퍼나 캐시에 관련된 부분은 아니지만 MySQL 서버가 기동 중인 장비에 웹 서버나 다른 배치용 프로 그램이 실행되고 있다면 테스트하려는 쿼리의 성능이 영향을 받게 될 것이다. 이와 마찬가지로 MySQL 서버뿐 아니라 테스트 쿼리를 실행하는 클라이언트 프로그램이나 네트워크의 영향 요소도 고려해야 한 다. MySQL 서버가 설치된 서버에 직접 로그인해서 테스트해볼 수 있다면 이러한 요소를 쉽게 배제할 수 있을 것이다. 
### 쿼리 테스트 횟수 
실제 쿼리의 성능 테스트를 MySQL 서버의 상태가 워밍업된 상태(앞에서 언급한 캐시나 버퍼가 필요 한 데이터로 준비된 상태)에서 진행할지 아니면 콜드 상태(캐시나 버퍼가 모두 초기화된 상태)에서 진 행할지도 고려해야 한다. 일반적으로 쿼리의 성능 테스트는 콜드 상태가 아닌 워밍업된 상태를 가정하 고 테스트하는 편이다. 어느 정도 사용량이 있는 서비스라면 콜드 상태에서 워밍업 상태로 전환하는 데 그다지 오래 걸리지 않기 때문에 실제 서비스 환경의 쿼리는 대부분 콜드 상태보다는 워밍업 상태에서 실행된다고 볼 수 있다. 간단한 쿼리의 성능 비교 테스트에서는 특별히 영향을 미칠 만한 프로세스나 다른 쿼리가 실행되고 있는지 확인한 후, 테스트를 진행하면 충분할 것이다. 운영체제의 캐시나 MySQL의 버퍼 풀, 키 캐시는 그 크기가 제한적이라서 쿼리에서 필요로 하는 데이 터나 인덱스 페이지보다 크기가 작으면 플러시 작업과 캐시 작업이 반복해서 발생하므로 퀴리를 한 번 실행해서 나온 결과를 그대로 신뢰해서는 안 된다. 테스트하려는 쿼리를 번갈아 가면서 6~7번 정도 실 행한 후, 처음 한두 번의 결과는 버리고 나머지 결과의 평균값을 기준으로 비교하는 것이 좋다. 처음에 는 운영체제 캐시나 MySQL의 버퍼 풀과 키 캐시가 준비되지 않을 때가 많아서 대체로 많은 시간이 소 요되는 편이어서 편차가 클 수 있기 때문이다. 이 같은 사항을 고려해 쿼리의 성능을 비교하는 것은 결국 상대적인 비교이지 절대적인 성능이 아니다. 그래서 그 쿼리가 어떤 서버에서도 그 시간 내에 처리된다고 보장할 수는 없다. 실제 서비스용 MySQL 서버에서는 현재 테스트 중인 쿼리만 실행되는 것이 아니라 동시에 4~50개의 쿼리가 실행 중인 상태 일 것이다. 각 퀴리가 자원을 점유하기 위한 경합 등이 발생하므로 항상 테스트보다는 느린 처리 성능 을 보이는 것이 일반적이다.
