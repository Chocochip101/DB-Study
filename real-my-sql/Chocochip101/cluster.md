사용자는 MySQL의 복제 기능을 사용해 서비스의 고가용성을 실현할 수 있지만 단순히 현재 사용중인 MySQL 서버들을 소스-레플리카 구조의 복제 형태로 구성해놓는다고 해서 고가용성이 실현되는 것은 아니다. 

소스 서버에서 장애가 발생했을 때 레플리카 서버가 자동으로 기존 소스 서버를 대체하는 새로운 소스 서버로 전환되는 것이 아니기 때문이다. MySQL 서버 자체적으로 Failover를 처리하는 기능을 제공하지 않으므로 사용자는 장애가 발생했을 때 레플리카 서버가 새로운 소스 서버가 될 수 있도록 일련의 작업들을 수행해야 한다. 즉, **레플리카 서버에 설정된 읽기 모드를 해제해야 하며, 스플릿 브레인(Split-Brain) 현상을 방지하기 위해 장애가 발생한 소스 서버에서 데이터 변경을 실행하지 못하도록 해야 한다**. 그리고 애플리케이션 서버는 새로운 소스 서버를 바라보도록 커넥션 설정을 변경해야 한다. 이러한 작업들은 모두 수동으로 처리할 수밖에 없으며 완료되기까지 적지 않은 시간이 소요된다. 

어떤 서비스든 장애가 발생한 경우 장애 시간을 최소화하는 것이 제일 중요하므로 대부분의 경우 이 같은 전환 작업을 계속 수동으로 처리하기보다는 자동화하는 것을 고려하곤 한다. 따라서 MySQL 서버 장애를 감지해 자동으로 페일오버를 처리하는 프로그램을 직접 개발해서 사용하거나 혹은 서드파티 HA 솔루션을 사용하게 되는데, 대표적인 것으로는 MMM과 MHA 그리고 Orchestrator 등이 있다.


MySQL에 내장된 기능이 아닌 이렇게 별도로 개발된 솔루션을 사용하는 경우에는 해당 솔루션을 실제 사용 환경에 맞게 수정하는 작업이 필요할 수 있으며, 또한 MySQL 버전 업그레이드에 따른 지속적인 유지보수와 관리가 필요하다는 불편함이 있다. 하지만 MySQL 5.7.17 버전에서 **빌트인 형태의 HA 솔루션인 InnoDB 클러스터가 도입되면서 사용자는 좀 더 쉽고 편리하게 고가용성을 실현할 수 있게 됐다**. 지금부터 InnoDB 클러스터가 어떤 것이고, 어떻게 구현돼 있으며, 이를 활용해서 얻을 수 있는 이점은 무엇인지 자세히 살펴보겠다. 


# InnoDB 클러스터 아키텍처

InnoDB 클러스터는 단순하게 MySQL 서버 내에서 설정할 수 있는 어떤 기능이 아닌 MySQL의 고가용성 실현을 위해 만들어진 여러 구성 요소들의 집합체이다.

InnoDB 클러스터를 구성하는 요소는 다음과 같다.

- 그룹 복제(Group Replication): 소스 서버의 데이터를 레플리카 서버로 동기화하는 기본적인 복제 역할뿐만 아니라 복제에 참여하는 MySQL 서버들에 대한 자동화된 멤버십 관리(그룹에 새로운 멤버의 추가 및 제거 등) 역할을 담당한다.
- MySQL 라우터(MySQL Router): 애플리케이션 서버와 MySQL 서버 사이에서 동작하는 미들웨어 프로그램으로, 실행한 쿼리를 직접한 MySQL 서버로 전달하는 프록시 역할을 한다.
- MySQL 셸(MySQL Shell): 기존 MySQL 클라이언트보다 더 확장된 기능을 가진 새로운 클라이언트 프로그램으로, 기본적인 SQL문 실행뿐만 아니라 JS 및 파이썬 기반의 스크립트 작성 기능과 MySQL 서버에 대해 클러스터 구성 등의 어드민 작업을 할 수 있게 하는 API를 제공한다.


![](https://velog.velcdn.com/images/chocochip/post/9684ee64-724d-4466-9424-c54dc7386b0d/image.png)

InnoDB 클러스터에서 데이터가 저장되는 MySQL 서버들은 그룹 복제 형태로 복제가 구성되며, **각 서버는 읽기/쓰기가 모두 가능한 프라이머리(Primary) 혹은 읽기만 가능한 세컨더리(Secondary) 중 하나의 역할로 동작**하게 된다. 여기서 프라이머리는 기존 MySQL 복제에서의 소스 서버라 할 수 있으며, 세컨더리는 레플리카 서버라고 할 수 있다. 그룹 복제에 설정된 모드에 따라 복제 그룹 내에서 프라이머리는 하나만 존재할 수도 있고 여러 대가 존재할 수도 있다. 그룹 복제에서는 InnoDB 스토리지 엔진만 사용될 수 있다. 또한 그룹 복제를 구성할 때 고가용성을 위해 **MySQL 서버를 최소 3대 이상으로 구성해야 하는데, 이는 3대로 구성 했을 때부터 MySQL 서버 한 대에 장애가 발생하더라도 복제 그룹이 정상적으로 동작하기 때문**이다. 

## MySQL 라우터
InnoDB 클러스터를 사용하는 환경에서 클라이언트는 MySQL 서버로 직접 접근해서 쿼리를 실행하는 것이 아니라 **MySQL 라우터에 연결해서 쿼리를 실행**한다. MySQL 라우터는 InnoDB 클러스터로 구성된 MySQL 서버들에 대한 메타데이터 정보를 지니며, 이를 바탕으로 클라이언트로부터 실행된 퀴리를 클러스터 내 적절한 MySQL 서버로 전달한다. 따라서 클라이언트는 현재 InnoDB 클러스터가 어떤 서버로 구성돼 있는지 알고 있을 필요가 없으며, 커넥션 정보에는 MySQL 라우터 서버만 설정해두면 된다. 

## MySQL 셸
MySQL 셀은 사용자가 손쉽게 InnoDB 클러스터를 생성하고 관리할 수 있도록 API를 제공하며, 그 외에도 InnoDB 클러스터의 상태를 확인하거나 MySQL 서버의 설정을 변경하는 것과 같은 여러 가지 기능들을 제공한다. MySQL 셸에서 InnoDB 클러스터와 관련된 작업들을 진행할 때는 InnoDB 클러스터 내 MySQL 서버에 직접 연결해 작업해야 하며, 단순히 쿼리를 실행하는 경우에는 MySQL 라우터로 연결해서 처리할 수도 있다. 


## 자동 장애 복구 처리 과정
1. 장애가 발생한다.
2. 그룹 복제가 장애를 감지하여 복제 그룹에서 제외시킨다.
3. MySQL 라우터는 이러한 복제 토폴로지 변경을 인지하고 자 신이 가진 메타데이터를 갱신해서 클라이언트로부터 실행된 쿼리가 현재 복제 그룹에서 정상적으로 동작하는 MySQL 서버로만 전달될 수 있도록 한다.


InnoDB 클러스터는 **MySQL에서 공식적으로 제공하는 빌트인 HA 솔루션**으로, 구성 요소들 또한 MySQL에서 제공하는 것들로 전부 하나의 패키지로서 테스트되고 개발된다는 점에서 매우 큰 강점을 지닌다. 사용자가 MySQL 서버의 고가용성을 위해 별도의 HA 솔루션을 개발하거나 수정해서 사용할 필요없이 InnoDB 클러스터만 사용하면 되기 때문이다. InnoDB 클러스터에서 각 구성 요소들은 상호 유기적으로 동작해서 고가용성을 이뤄내므로 사용자는 각 구성 요소들이 어떻게 구현돼 있고 InnoDB 클러스터 내에서 어떤 역할을 하는지 명확하게 이해하고 있어야 한다.

# 그룹 복제(Group Replication) 
그룹 복제는 기존 MySQL 복제 프레임워크를 기반으로 구현되어 내부적으로 Row 포맷의 바이너리 로그와 릴레이 로그, GTID를 사용한다. 이처럼 그룹 복제는 기존 MySQL 복제와 구조적으로 유사한 부분도 있지만 복제 구성 형태와 트랜잭션 처리 방식 측면에서는 완전히 다른 복제 방식이라고 할 수 있다. 기존 복제의 경우 일반적으로 소스-레플리카 형태로 구성되어 **단방향으로만 복제가 이뤄지는 반면**, 그룹 복제에서는 복제에 참여하는 MySQL 서버들이 하나의 복제 그룹으로 묶인 클러스터 형태를 가지며 그룹 내 서버들은 서로 통신하면서 양방 향으로도 복제를 처리할 수 있다. 즉, 하나의 복제 그룹 내에서 쓰기를 처리하는 서버가 여러 대 존재할 수 있는 것이다. 앞서 언급한 것과 같이 그룹 복제에서는 각 서버들을 소스 혹은 레플리카 서버로 표현하지 않으며, "프라이머리"와 "세컨더리"라는 용어를 사용한다. 쓰기를 처리하는 서버를 프라이머리, 읽기 전용으로 동작하는 서버를 세컨더리라고 하며 그룹 복제에 참여하는 MySQL 서버들을 "그룹 멤버"라고 지칭한다.

그룹 복제는 기존 복제와 복제 처리 방식에서도 큰 차이를 보이는데, 기존 복제에서의 복제 처리 방식을 데이터 동기화 측면에서 분류하면 비동기 방식과 반동기 방식으로 나눌 수 있다. 그룹 복제는 반동기 방식으로 진행된다.

![](https://velog.velcdn.com/images/chocochip/post/81218515-bb10-4dbf-9335-f4ed1625b065/image.png)

![](https://velog.velcdn.com/images/chocochip/post/f4b06b73-2115-41f8-9d46-151d82d32dcf/image.png)

기존 복제에서는 기본적으로 소스 서버에서의 트랜잭션 커밋 처리가 레플리카 서버와는 무관하게 처리되는 비동기 방식으로 동작한다. 즉, 소스 서버에서는 트랜잭션 커밋 시 레플리카 서버로도 해당 트랜잭션이 정상적으로 전달됐는지 확인하지 않는다.

반동기 복제는 기존 복제에서 한 단계가 추가되어, 레플리카 서버의 트랜잭션이 잘 전달됐는지 응답을 기다린다.

그룹 복제에서도 트랜잭션에 대해 그룹 내에 다른 멤버들의 응답을 확인하는 단계가 존재한다. **그룹 복제에서는 한 서버에서 트랜잭션이 커밋될 준비가 되면 트랜잭션 정보를 그룹의 다른 멤버들에 전송하고 과반수 이상의 멤버로부터 응답을 전달받으면 그때 해당 트랜잭션을 인증(certify)하고 최종적으로 커밋 처리를 완료**한다. 트랜잭션 인증은 인증 대상 트랜잭션이 이미 인증 단계를 통과한 선행 트랜잭션과 통시점에 동일한 데이터를 변경했는지 충돌 여부를 검사해서 문제없이 적용 가능한지를 확인하는 과정이다.

그룹 복제에서 과반수 이상의 응답을 받지 못하면 해당 트랜잭션은 그룹에 적용되지 않는다. 즉 **그룹 내 멤버들 응답에 따라 전체 복제 그룹에서 해당 트랜잭션의 여부가 결정되는 것**이다. 이처럼 트랜잭션 커밋을 처리할 때 그룹의 다른 멤버들에 대한 응답을 확인하는 과정을 "합의(Consensus)"라고 하는데, 이는 그룹 멤버들로부터 이 트랜잭션을 복제 그룹에 적용하는 것에 대한 동의를 구하기 때문이다. 물론 데이터를 읽는 과정은 합의가 필요하지 않다.

## 그룹 복제 아키텍처

그룹 복제는 별도 플러그인으로 구현돼 있으며, 그룹 복제를 사용하기 위해서는 MySQL 서버에 그룹 복제 플러그인이 설치돼 있어야 한다.

그룹 복제에 참여하는 MySQL 서버들은 그룹 복제 플러그인을 통해 서로 간에 지속적으로 통신하며 복제 동기화를 처리한다. MySQL 서버에 그룹 복제가 설정되면 `group_replication_applier`라는 복제 채널을 생성하며, MySQL 서버는 이 채널을 통해 그룹에서 실행된 모든 트랜잭션을 전달받아 적용하게 된다. 새로운 MySQL 서버가 그룹에 합류하면, 최신 데이터를 가질 수 있도록 `group_replication_recovery`라는 복제 채널을 생성해서 분산 복구 작업을 진행한다.

### 내부 구조

![](https://velog.velcdn.com/images/chocochip/post/86ba01df-f3cb-4038-a5bc-ca73c285e365/image.png)

- Plugin API: 트랜잭션 이벤트를 전달하고 릴레이 로그 기록, 커밋 또는 중단 등의 요청을 전달
- Replication Plugin: 그룹 복제 기능들이 실질적으로 구현돼 있는 계층
- Group Communication System: 그룹 통신 엔진과 상호작용
- Group Communication Engine: 트랜잭션이 그룹 복제 멤버들에게 동일한 순서로 전달될 수 있도록 보장. 대표적인 알고리즘으로 Paxos(서버 여러 대일 경우 작동)와 Raft(데이터 변경이 한 대에서만 발생할 경우)가 존재.

### MySQL 서버의 수
그룹 복제에서 중요한 것은 MySQL 서버의 수이다. 그룹 복제에서는 복제를 처리할 때 그룹 멤버들 간에 합의 절차가 수행되므로 그룹 복제가 정상적으로 동작하려면 그룹의 과반수에 해당하는 서버가 정상적으로 동작해야 한다. 하나의 서버에 장애가 발생하더라도 **그룹 복제가 전반적으로 문제없이 처리되려면 적어도 세 대의 서버가 그룹에 존재해야 한다**. 세 대가 존재하는 경우 한 대에 문제가 생겨도 나머지 두 대의 합의가 처리될 수 있기 때문이다.

## 그룹 복제 모드
그룹 복제에서는 쓰기를 처리할 수 있는 프라이머리 서버 수에 따라 싱글 프라이머리 모드와 멀티 프라이머리 모드로 설정할 수 있다. `group_replication_single_primary_mode` 시스템 변수를 통해 그룹 복제를 어떤 모드로 동작하게 할 것인지 설정할 수 있다. 


### 싱글 프라이머리 모드

싱글 프라이머리 모드는 그룹 내에서 쓰기를 처리할 수 있는 프라이머리 서버가 한 대만 존재하는 형태다. 싱글 프라이머리 모드로 그룹 복제를 처음 구축하는 경우 그룹 복제 구축을 진행한 MySQL 서버가 프라이머리로 지정된다. 나머지 서버들은 그룹에 참여하는 시점에 `super_read_only` 시스템 변수가 ON으로 설정되어 읽기 전용 모드로 동작한다.

프라이머리 서버의 변경은 다음 두 가지 방식으로 가능하다.
- 자발적으로 혹은 예기치않게 현재 프라이머리 서버가 그룹을 탈퇴하는 경우
- group_replication_set_as_primary() UDF를 사용해 그룹의 특정 멤버를 새로운 프라이머리로 지정한 경우

UDF를 통해 사용자가 지정한 서버로 변경되는 것이 아닌 경우 아래 우선순위로 결정된다.

1. MySQL의 서버 버전
2. 각 멤버의 가중치 값
3. UUID 값의 사전적 순서

현재 싱글 프라이머리 모드로 동작 중인 그룹 복제에서 어떤 서버가 프라이머리인지는 `performance_schema`를 통해 확인할 수 있다.

### 멀티 프라이머리 모드
멀티 프라이머리 모드는 그룹 복제에서 그룹 멤버들이 전부 프라이머리로 동작하는 형태로, 클라이언트는 어떤 MySQL 서버로든 쓰기와 읽기 요청을 보낼 수 있다.

멀티 프라이머리 모드에서는 그룹의 모든 멤버에게 쓰기가 발생할 수 있으며, 이렇게 발생한 쓰기는 그룹의 다른 멤버들로 전파되어 처리되므로 무엇보다 그룹 멤버 간의 MySQL 버전 호환성이 중요하다.

## 그룹 멤버 관리
그룹 복제에서는 현재 어떤 서버들이 그룹에 참여하고 있는지 그룹 멤버들에 대한 목록과 상태 정보를 내부적으로 관리하고 있으며, 사용자는 `performance_schema`의 `replication_group_members` 테이블을 통해 그룹 멤버 목록을 확인할 수 있다. 그룹에 멤버가 새로 가입하거나 혹은 탈퇴하면 그룹 복제에서는 이를 감지해서 해당 테이블 데이터를 자동으로 갱신한다.


MEMBER_STATE 칼럼을 통해 멤버의 현재 상태도 확인할 수 있다.

- ONLINE: 그룹 복제의 한 구성원으로서 정상적으로 동작하고 있음을 나타낸다.
- RECOVERING: 그룹 복제에 참여하기 위해 기존 그룹 멤버로부터 데이터를 전달받는 복구 작업이 진행되고 있음을 나타낸다.
- OFFLINE: MySQL 서버에 그룹 복제 플러그인이 로딩돼 있으나 아직 그룹 복제에 참여하지 않은 상태를 나타낸다.
- ERROR: 그룹 복제에 속해 있으나 현재 정상적으로 동작하지 않은 상태를 나타낸다.
- UNREACHABLE: 현재 통신이 불가능하다고 판단


그룹 복제가 관리하는 멤버 목록과 상태 정보를 뷰라고 하는데, 그룹 복제에서 멤버는 새로 가입하거나 탈퇴할 수 있으므로 뷰는 특정 시점의 그룹 멤버 목록인 것이다.
```bash
View ID = [Prefix value]:[Sequence value]
```

- Prefix value: 그룹 복제 초기화될 때 생성되며, 타임스탬프 기반으로 생성
- Sequence value: 단조 증간하는 정숫값

## 그룹 복제에서 트랜잭션 처리

그룹 복제에서의 트랜잭션 처리 그룹 복제에서 트랜잭션은 다음의 단계들을 거친 후 최종적으로 그룹의 각 서버들에 적용된다.

- 합의(Consensus) 
- 인증(Certification) 

합의(Consensus)는 그룹 내 일관된 트랜잭션 적용을 위해 그룹 멤버들에게 트랜잭션 적용을 제안하고 승낙을 받는 과정으로, 그룹 멤버 간의 통신 결과를 바탕으로 처리된다. 

1. 클라이언트가 한 그룹 멤버에서 트랜잭션을 실행하고 커밋 요청을 보낸다.
2. 해당 그룹 멤버는 그룹 통신 엔진(XCom)을 통해 트랜잭션에서 변경한 데이터에 대한 WriteSet과 트랜잭션이 커밋될 당시의 `gtid_executed` 스냅숏 정보, 트랜잭션의 이벤트 로그 데이터 등이 포함된 트랜잭션 데이터를 그룹의 다른 멤버들로 전파한다. 전파 대상 멤버들은 현재 그룹 내에서 정상적인 상태로 동작 중인 멤버들이다. 
3. 그룹 복제의 그룹 통신 엔진에서는 트랜잭션 데이터를 전파하면서 Paxos 기반의 프로토콜을 바탕으로 그룹 멤버들 간의 합의를 수행한다.
4. 최종적으로 합의가 완료되어 트랜잭션이 실행된 멤버에서 그룹의 과반수 이상에 해당하는 멤버들 로부터 응답 메시지(ACK)를 전달받으면 해당 멤버는 그다음 프로세스를 진행하게 된다. 
   - 만약 과반수 이상의 멤버들로부터 응답을 받지 못한 경우 그룹 복제에서 트랜잭션은 적용되지 않으며 클라이언트에 는 에러가 반환된다. 

다수의 그룹 멤버들에서 실행된 트랜잭션들은 합의 단계를 거친 후 글로벌하게 정렬되어, 각 멤버들에서 모두 동일한 순서로 인증(Certification) 단계를 거치게 된다. 

각 멤버들은 전달받은 트랜잭션 WriteSet 데이터와 로컬에서 내부적으로 관리하고 있는 WriteSet 히스토리 데이터를 바탕으로 해당 트랜잭션이 이미 인증 단계를 거친 선행 트랜잭션과 동시점에 동일한 데이터를 변경한 것인지 를 검사해서 트랜잭션 충돌 여부를 확인한다. 이러한 트랜잭션 충돌은 그룹 멤버 전체가 쓰기를 처리할 수 있는 멀티 프라이머리 모드에서만 발생할 수 있으며, **단일 서버에서 쓰기가 수행되는 싱글 프라이머리 모드에서는 발생하지 않는다**. 인증 단계에서 트랜잭션 충돌이 감지된 트랜잭션은 커밋되지 못하고 롤백된다. 따라서 트랜잭션 충돌이 자주 발생할 수 있는 환경에서는 그룹 복제를 싱글 프라이머리 모드로 사용해 자동으로 롤백되지 않고 대기 후 처리될 수 있게 하는 것이 더 나은 방법이 될 수 있다.


각 트랜잭션이 실행된 로컬 멤버에서는 인증 단계를 거친 후 바이너리 로그에 트랜잭션을 기록하고 최 종적으로 커밋을 완료하며, 클라이언트는 이 시점에 커밋 요청에 대한 응답을 받게 된다. 원격으로 트 한쪽면 데이터를 전달받은 그룹의 다른 멤버들에서는 인증 단계를 수행한 후 함께 전달받은 트랜잭션 로그 데이터를 바탕으로 릴레이 로그 이벤트를 작성한다. 그리고 그룹 복제의 어플라이어 스레드에서는 릴레이 로그에 기록된 트랜잭션을 실행하고 바이너리 로그에도 기록해서 최종적으로 서버에 해당 트랜 객선을 적용하게 된다. 그림 17.9는 그룹 복제에서 트랜잭션이 처리되는 일련의 과정들을 보여준다.

### 트랜잭션 일관성 수준 
그룹 복제에서 각 멤버들은 모두 동일한 트랜잭션을 적용하지만 실제 적용 시점까지 완전히 일치하는 것은 아니다. 따라서 한 멤버에서 쓰기를 수행한 후 바로 다른 멤버에서 해당 데이터를 읽었을 때 최신 변경 사항이 반영되지 않았을 수 있다. 또한 프라이머리 장애로 인해 페일오버가 발생하는 경우에도 이 러한 상황이 발생할 수 있는데, 새로 선출된 프라이머리가 아직 이전 프라이머리에서 발생했던 트랜잭 션들을 적용하고 있는 상황에서 클라이언트가 새로운 프라이머리로 연결해서 트랜잭션을 실행하는 경 우 해당 트랜잭션에서는 오래된 데이터를 읽거나 쓸 수 있다. 일반적으로 그룹 복제가 정상적으로 잘 동작하고 있는 상태에서는 멤버 간 데이터 동기화는 빠르게 처리되므로 이 같은 상황은 거의 발생하지 않을 것이다. 하지만 동기화가 잘 처리되고 있다고 하더라도 일시적으로 아주 짧은 순간에 발생할 수는 있으며, 이러한 상황에 매우 민감한 서비스에서는 문제가 될 수 있다. MySQL 8.0.14 버전 이전까지는 그룹 복제에서 이 같은 상황이 발생하는 것을 방지할 수 있는 방법이 없었다. 그러나 MySQL 8.0.14 버전부터 그룹 복제에서 트랜잭션의 일관성 수준을 설정할 수 있는 기 능이 도입되면서 사용자가 필요에 따라 원하는 수준의 일관성을 선택해서 사용할 수 있게 됐다. group_ replication_consistency 시스템 변수를 통해 그룹 복제에서의 트랜잭션 일관성 수준을 설정할 수 있으 며, 적용 범위는 글로벌 또는 세션 모두 가능하다. 설정된 일관성 수준은 읽기 전용 트랜잭션과 읽기- 쓰기 트랜잭션에 다른 영향을 미치며, 경우에 따라 다른 멤버에서 실행 중인 트랜잭션에도 영향을 줄 수 있다.

#### EVENTUAL 일관성 수준 
EVENTUAL 일관성 수준은 group_replication_consistency 시스템 변수의 기본 설정값으로, 해당 변수가 추가되기 전의 그룹 복제에서의 트랜잭션 일관성 수준과 동일하다. 즉, 이름 그대로 최종적으로는 그룹 멤버들이 일관된 데이터를 가지게 됨을 의미한다. **EVENTUAL 일관성 수준에서는 읽기 전용 및 읽기-쓰기 트랜잭션이 별도의 제약 없이 바로 실행 가능**하다. 이는 트랜잭션이 직접 실행된 멤버가 아닌 다른 그룹 멤버들에서는 일시적으로 변경 직전 상태의 데이터가 읽혀질 수 있으며, 프라이머리 페일오버가 발생한 경우 새로운 프라이머리가 이전 프라이머리의 트랜잭션을 모두 적용하기 전에 새로운 프라이머 리에서 트랜잭션이 실행 가능해서 읽기 트랜잭션의 경우 오래된 데이터를 읽을 수 있고 읽기-쓰기 트랜잭션의 경우 커밋 시 이전 프라이머리의 트랜잭션과의 충돌로 인해 롤백될 수 있음을 의미한다.


![](https://velog.velcdn.com/images/chocochip/post/9c3d8e1a-82a6-4010-935e-14851d4169b6/image.png)

위 그림 Member 3에서 실행된 T2 트랜잭션은 앞서 실행된 T1 트랜잭션이 Member 3에서 완전히 적용되기 전에 실행 됐으므로 T2 트랜잭션에서 읽은 데이터는 최신 데이터가 아닐 수 있으며, **T1 트랜잭션과 충돌하는 경우 롤백**될 수 있다.

#### BEFORE_ON_PRIMARY_FAILOVER 일관성 수준
BEFORE_ON_PRIMARY_FAILOVER 일관성 수준은 **싱글 프라이머리 모드로 설정된 그룹 복제에서 프라이머리 페일오버가 발생해서 신규 프라이머리가 선출됐을 때만 트랜잭션에 영향**을 미친다. 선출된 신규 프라이머리가 BEFORE_ON_PRIMARY_FAILOVER 일관성 수준으로 설정돼 있고 아직 이전 프라이머리의 트랜잭션 을 적용하고 있는 경우 새로운 프라이머리로 유입된 읽기 전용 및 읽기-쓰기 트랜잭션은 새로운 프라 이머리에서 이전 프라이머리의 트랜잭션이 모두 적용될 때까지 처리되지 못하고 대기하게 된다. 

![](https://velog.velcdn.com/images/chocochip/post/b46a0b58-f1cc-4e04-afec-78dfdd2e805d/image.png)


Member 3은 기존 프라이머리 Member 1이 페일오버됨에 따라 새로 선출된 프라이 머리다. 페일오버 직후 Member 3으로 유입된 BEFORE_ON_PRIMARY_FAILOVER 일관성 수준의 T2 트랜잭션은 Member 3에서 기존 프라이머리 Member 1에서 실행된 T1 트랜잭션이 적용될 때까지 대기 후 처리된다. 프라이머리 페일오버 시점에 신규 프라이머리로 유입된 트랜잭션들의 대기 시간은 신규 프라이머리와 이전 프라이머리 간의 트랜잭션 갭에 따라 달라진다. 페일오버가 발생하기 직전까지 그룹 멤버 간에 복제 동기화가 정상적으로 잘 처리되고 있던 상황이라면 트랜잭션 갭은 아주 적을 것이다. 그러나 예상치 못한 문제로 인해 갭이 큰 경우 트랜잭션들의 대기 시간이 길어져 클라이언트에서 응답 지연을 겪을 수 있으므로 클라이언트 단에서는 이 같은 지연을 대비하는 코드가 구현돼 있는 것이 좋다. 또한 트랜잭션은 영원히 대기할 수 없으며, 대기 시간이 MySQL의 wait_timeout 시스템 변수에 설정된 값을 초과하 면 ER_GR_HOLD_WAIT_TIMEOUT 에러가 클라이언트로 반환된다. wait_timeout 시스템 변수의 기본값은 8시간(28,800초)으로 매우 긴 편이므로 애플리케이션에서 적절히 쿼리의 타임아웃을 설정하는 것이 좋다. 
BEFORE_ON_PRIMARY_FAILOVER 일관성 수준에서는 다음과 같은 부분들이 보장된다. 

- 신규 프라이머리로 유입된 읽기 전용 및 읽기-쓰기 트랜잭션들은 오래된 데이터가 아닌 최신 데이터를 바탕으로 동 작하게 된다. 
- 신규 프라이머리로 유입된 읽기-쓰기 트랜잭션은 적용 대기 중인 이전 프라이머리의 트랜잭션과의 충돌로 롤백될 수도 있는데, BEFORE_ON_PRIMARY_FAILOVER 일관성 수준을 사용하면 이 같은 롤백은 발생하지 않게 된다.

BEFORE_ON_PRIMARY_FAILOVER 일관성 수준에서 신규 프라이머리가 이전 프라이머리의 트랜잭션들을 적 용하고 있을 때 새로 유입된 모든 읽기-쓰기 트랜잭션들은 처리가 지연되지만 읽기 전용 트랜잭션에서 는 모든 종류의 읽기 쿼리들이 전부 처리가 지연되는 것은 아니며 MySQL 서버 모니터링 등을 위한 일 부 쿼리들은 바로 실행이 가능하다. 다음과 같은 쿼리들이 여기에 해당된다. 
- SHOW, SET, DO, EMPTY, USE문
- performance_schema 및 sys 데이터베이스에 대한 SELECT 문 사용 
- information_schema 데이터베이스의 PROCESSLIST 테이블에 대한 SELECT 문 사용 
- 테이블 또는 사용자 정의 함수를 사용하지 않는 SELECT 문 
- STOP GROUP_REPLICATION, SHUTDOWN, RESET PERSIST 문

BEFORE_ON_PRIMARY_FAILOVER 일관성 수준은 프라이머리 페일오버가 발생하지 않는 상황에서는 프라이 머리로 유입된 트랜잭션들에 아무런 영향을 미치지 않는다. 즉, 일반적인 상황에서는 트랜잭션들이 EVENTUAL 일관성 수준으로 설정된 트랜잭션처럼 처리된다고 할 수 있다. 

#### BEFORE 일관성 수준 
BEFORE 일관성 수준에서 읽기 전용 및 읽기-쓰기 트랜잭션은 모든 선행 트랜잭션이 완료될 때까지 대 기 후 처리된다. 선행 트랜잭션은 해당 트랜잭션이 실행된 그룹 멤버에서의 선행 트랜잭션만을 의미한 다. 따라서 그림 17.12에 나타나 있는 것처럼 BEFORE 일관성 수준으로 설정된 T2 트랜잭션은 Member 3 서버에서 T1 트랜잭션이 적용되고 난 후에 바로 실행이 가능하다. BEFORE 일관성 수준으로 설정된 읽기 전용 및 읽기-쓰기 트랜잭션은 항상 최신 데이터를 읽으며, 트랜 잭션의 처리 시간은 선행 트랜잭션의 처리 시간에 영향을 받는다. 선행 트랜잭션이 최종적으로 적용되 기까지의 시간이 길면 길수록 그만큼 처리가 지연된다고 볼 수 있다. 그러나 선행 트랜잭션의 처리 시 간이 짧은 경우 트랜잭션들은 본래 자신의 처리 시간만큼만 소요하게 된다.

![](https://velog.velcdn.com/images/chocochip/post/38cfcc92-d539-45b8-92bd-051b27257ff2/image.png)


BEFORE 일관성 수준으로 설정된 트랜잭션은 MySQL의 wait_timeout 시스템 변수에 설정된 시간까지 대기할 수 있으며, 만약 대기 시간이 이를 초과하는 경우 ER_GR_HOLD_WAIT_TIMEOUT 에러가 클라이언트 로 반환된다. BEFORE 일관성 수준은 트랜잭션에서 반드시 최신 데이터를 읽어야 하며, DB에서 읽기 요 청은 적고 쓰기 요청이 많은 경우에 사용하는 것이 좋다. 또한 BEFORE 일관성 수준에서는 BEFORE_ON_ PRIMARY_FAILOVER 수준이 제공하는 일관성 보장을 포함한다. 

#### AFTER 일관성 수준 
AFTER 일관성 수준은 트랜잭션이 적용되면 해당 시점에 그룹 멤버들이 모두 동기화된 데이터를 갖게 한 다. 따라서 AFTER 일관성 수준에서 읽기-쓰기 트랜잭션은 다른 모든 멤버들에서도 해당 트랜잭션이 커 밋될 준비가 됐을 때까지 대기한 후 최종적으로 처리되며, 읽기 전용 트랜잭션은 데이터 변경을 발생시 키지 않으므로 별도의 제약 없이 바로 처리된다. AFTER 일관성 수준으로 설정된 읽기 -쓰기 트랜잭션은 그림 17.13에 나타나 있는 것처럼 그룹의 다른 멤버들로부터 응답을 받으면 최종적으로 커밋된다. 
![](https://velog.velcdn.com/images/chocochip/post/16cc5fcf-ab29-4f5e-b719-afe4d80b01c3/image.png)



AFTER 일관성 수준은 다른 멤버에서 동시점에 실행되는 트랜잭션에 영향을 미친다. 그림 17.13의 T2 트랜잭션처럼 만약 AFTER 일관성 수준으로 설정된 트랜잭션이 실행되는 동안 다른 멤버에서 새로운 트 랜잭션이 실행되면 해당 트랜잭션은 AFTER 일관성 수준의 트랜잭션이 완전히 커밋될 때까지 대기하게 된다. 따라서 AFTER 일관성 수준은 그룹에서 정상적으로 동작 중인 모든 멤버에 영향을 미친다고 할 수 있다. AFTER 일관성 수준에서는 읽기 -쓰기 트랜잭션이 그룹의 모든 멤버들에서 커밋 준비가 된 후에야 트랜 잭션이 실행된 로컬 멤버에서 최종적으로 커밋되므로 이후 실행되는 후속 트랜잭션들은 그룹의 어떤멤버에서든 일관된 최신 데이터를 얻을 수 있다. 읽기 -쓰기 트랜잭션은 다른 멤버들에서 트랜잭션 커 맛이 준비될 때까지 대기해야 하므로 항상 본래의 처리 시간보다 더 많은 시간을 소요하게 된다. 따라 서 AFTER 일관성 수준은 DB에서 쓰기 요청보다 읽기 요청이 많고, 분산된 최신 읽기를 수행하고자 할 때 사용하는 것이 좋다. AFTER 일관성 수준은 마찬가지로 BEFORE_ON_PRIMARY_FAILOVER 수준이 제공하는 일관성 보장을 포함하며, AFTER 일관성 수준으로 설정된 트랜잭션은 MySQL의 wait_timeout 시스템 변 수에 설정된 시간까지 대기할 수 있다. 만약 대기 시간이 이를 초과하는 경우 ER_GR_HOLD_WAIT_TIMEOUT 에러가 클라이언트로 반환된다. 

#### BEFORE_AND_AFTER 일관성 수준 
BEFORE_AND_AFTER 일관성 수준은 BEFORE 수준과 AFTER 수준이 결합된 형태라고 할 수 있다. BEFORE_AND_AFTER 일관성 수준에서 읽기 -쓰기 트랜잭션은 모든 선행 트랜잭션이 적용될 때까지 기다린 후 실행되 트랜잭션이 다른 모든 멤버들에서도 커밋이 준비되어 응답을 보내면 그때 최종적으로 커밋된다. 읽 기 전용 트랜잭션은 모든 선행 트랜잭션이 적용될 때까지 대기한 후 실행된다. 그림 17.14는 BEFORE_ AND_AFTER 일관성 수준으로 설정된 트랜잭션의 처리 과정을 보여준다. 

![](https://velog.velcdn.com/images/chocochip/post/7ac5e14a-13b3-4a63-b5c2-67ec780f1ba8/image.png)


그림 17.14에서 BEFORE_AND_AFTER 일관성 수준으로 설정되어 Member 1에서 실행된 트랜잭션 T2는 Member 3에서 실행된 트랜잭션 T1이 Member 1에서 적용될 때까지 대기 후 실행된다. T2 트랜잭 션은 다른 멤버들에서도 트랜잭션 커밋이 준비됐을 때 최종적으로 커밋 처리된다. T2 트랜잭션이 그룹 멤버들에 완전히 적용되기 전에 Member 3으로 유입된 트랜잭션 T3은 Member 3에서 트랜잭션 T2 가 적용될 때까지 대기 후 실행된다.

`BEFORE_AND_AFTER` 일관성 수준으로 설정된 트랜잭션에서는 최신 데이터를 읽을 수 있으며, 읽기 쓰기 트랜잭션의 경우 커밋되면 이후 모든 후속 트랜잭션들은 그룹의 어떤 멤버에서든지 해당 트랜잭선의 변경 사항을 포함하는 최신 데이터를 읽게 된다. BEFORE_AND_AFTER 일관성 수준은 AFTER 수준과 동일하 게 다른 멤버들에서 실행되는 트랜잭션들에 영향을 미친다. BEFORE_AND_AFTER 일관성 수준도 BEFORE_ON_ PRIMARY_FAILOVER 수준이 제공하는 일관성 보장을 포함하며, . BEFORE_AND_AFTER 일관성 수준으로 설정된 트랜잭션은 wait_timeout 시스템 변수에 설정된 시간까지 대기할 수 있다. 만약 대기 시간이 이를 초과 하는 경우 ER_GR_HOLD_WAIT_TIMEOUT 에러가 클라이언트로 반환된다. 

### 흐름 제어(Flow Control) 
그룹 복제에서 일부 멤버가 다른 멤버들보다 하드웨어 스펙이 더 낮거나 혹은 네트워크 대역폭이 작은 경우, 또는 부하를 더 많이 받고 있는 경우 해당 멤버는 다른 멤버들보다 트랜잭션 적용이 지연될 수 있다. 이렇게 지연된 멤버에서 트랜잭션이 실행되면 해당 트랜잭션은 최신 데이터가 아닌 오래된 데이터를 읽을 수 있으며, 아직 적용되지 않은 트랜잭션과 충돌할 위험이 있다. 

그룹 복제에서는 그룹 멤버 간의 **트랜잭션 적용 불균형으로 인해 발생하는 문제를 방지하기 위해 그룹 멤버들의 쓰기 처리량을 조절하는 메커니즘이 구현**돼 있으며, 이를 "**흐름 제어(Flow Control)**"라고 한다. 그룹 복제에서는 흐름 제어를 통해 멤버 간 트랜잭션 갭을 적게 유지해서 멤버들 의 데이터가 최대한 동기화된 상태로 유지될 수 있게 하며, 그룹에 평소와 다른 워크로드가 유입되는 등의 변화에도 빠르게 적응해서 각 멤버들의 쓰기 처리량이 균등할 수 있게 한다. 또한 필요 이상으로 처리량을 줄이지 않음으로써 서버의 자원이 불필요하게 유휴 상태에 놓여 있지 않게 한다. 사용자는 group_replication_flow_control_mode 시스템 변수를 통해 멤버에서 흐름 제어 기능의 사용 여 부를 설정할 수 있다. group_replication_flow_control_mode 시스템 변수는 흐름 제어를 어떤 모드로 사 용할지 설정하는 변수로, 현재로서는 QUOTA 모드밖에 존재하지 않으며 QUOTA 또는 DISABLED 값으로 설정 할 수 있다. QUOTA 모드는 해당 변수의 기본값, 즉 흐름 제어의 기본 모드로 그룹에서 쓰기를 처리하는 멤버가 정해진 할당량만큼만 쓰기를 처리하도록 제어하는 방식이다. group_replicatiion_flow_control_ mode 시스템 변수가 DISABLED로 설정되는 경우 흐름 제어는 동작하지 않는다. 흐름 제어가 비활성화돼 있는 멤버의 경우 현재 트랜잭션을 적용하지 않고 있거나 혹은 아직 적용하지 못한 트랜잭션을 아주 많이 가지고 있더라도 다른 멤버들의 흐름 제어에 영향을 주지 않는다. 즉, 이 멤버로 인해 다른 멤버들의 쓰기 처리량이 조정되지 않는다. QUOTA 모드로 설정된 흐름 제어의 동작 방식은 다음과 같다.

1. 모든 그룹 멤버들의 쓰기 처리량 및 처리 대기 중인 트랜잭션에 대한 통계를 수집해서 멤버의 처리량을 조절할 필요가 있는지 확인한다. 
2. 처리량 조절이 필요한 경우 수집된 통계 데이터를 바탕으로 멤버에게 할당할 쓰기 처리량을 계산한 후 멤버가 계산된 최대 쓰기 처리량을 넘어 쓰기를 처리하지 않도록 멤버의 쓰기 처리를 제한한다. 

흐름 제어는 그룹 전반에 걸쳐 동기화된 형태로 수행되는 것이 아니라 각 멤버에서 개별적으로 수행된다. 흐름 제어에서는 멤버에서 다음과 같은 통계 정보들을 수집하며, 이렇게 수집된 데이터들은 그룹의 다른 멤버들에게도 공유된다. 

- 인증(Certification) 큐 크기, 적용(Application) 큐 크기, 인증된 총 트랜잭션 수, 적용된 원격 트랜잭션 수, 로컬 트랜잭션 수 

통계 정보 데이터는 `group_replication_flow_control_period` 시스템 변수에 지정된 시간(초 단위)마다 수집 및 공유되는데, 이는 **흐름 제어가 동작하는 주기를 의미**한다. 기본적으로 흐름 제어는 매초마다 동작하며, 멤버 로컬에서 수집한 통계 정보와 다른 멤버들로부터 전달받은 통계 정보를 바탕으로 멤버 에서 쓰기 처리량 조절이 필요한 상황인지를 판단하고 멤버에게 할당할 쓰기 처리량을 계산한다. 

group_replication_flow_control period 시스템 변수의 값은 모든 멤버에서 동일할 필요는 없지만 관리 상의 편의를 위해서라도 같은 값으로 설정하는 것이 좋다. 또한group_replication_flow_control_period 시스템 변수의 값이 다른 멤버에서 설정된 값보다 10배 더 큰 값으로 설정된 멤버가 존재하는 경우 해당 멤버의 통계 정보는 다른 멤버들의 흐름 제어 주기 중 일부 주기에서 무시될 수 있다. 각 멤버에서 다른 멤버에 대한 통계 정보는 적어도 10 주기에 한 번씩 업데이트되지 않으면 삭제되기 때문이다.


## 그룹 복제의 자동 장애 감지 및 대응
그룹 복제에서 그룹의 일부 멤버에 장애가 발생해 응답 불능 상태에 빠졌다 하더라도 그룹이 정상적으로 동작할 수 있게 하는 장애 감지 메커니즘이 구현돼 있다. 장애 감지 메커니즘에서는 **문제 상태에 있는 멤버를 식별**하고 **해당 멤버를 그룹 복제에서 제외**시킴으로써 그룹이 정상적으로 동작 중인 멤버로만 구성될 수 있게 하고 클라이언트 요청이 문제 없이 처리되도록 한다.

그룹 복제에서는 멤버 간에 주기적으로 통신 메시지를 주고받으며 서로의 상태를 확인하는데, 멤버로부터 5초 내로 메시지를 받지 못하면 해당 멤버에 문제가 생긴 것으로 의심하기 시작한다. 그룹 복제에서는 장애가 의심되는 멤버에 대해 과반수의 멤버가 동의하면 해당 멤버를 그룹에서 추방한다. 5초의 추가 대기 시간 이후 추방된다. 추방되기 전 대기 시간 동안 멤버는 UNREACHABLE로 표시된다.

### 추방 전 대기 시간
추방되기 전 대기 시간을 나타내는 `group_replication_member_expel_timeout`을 통해 지정한다. 시스템 변수를 기본값 그대로 사용하는 경우 MySQL 버전에 따라 5초 또는 10초 후 의심받은 멤버가 그룹에서 추방된다. 이 시간은 네트워크가 느린 환경에서 충분하지 않을 수 있으며, 이로 인해 불필요하게 그룹 멤버가 추방당하거나 혹은 프라이머리 페일오버가 발생할 수도 있다. 따라서 기본값보다 좀 더 큰 적절한 값으로 설정하는 것이 좋다.

### 그룹 재가입

멤버가 추방되고 나서 다시 다른 그룹 멤버들과 통신을 재개할 수 있는 경우 해당 멤버는 그룹의 현재 뷰 ID와 자신이 가진 뷰 ID를 통해 그룹에서 추방되었음을 알 수 있다. 추방된 멤버는 자동으로 그룹에 재가입을 시도할 수 있는데, 이는 `group_replication_autorejoin_tries` 시스템 변수에 따라 달라진다.


그룹에서 추방된 멤버는 다른 그룹 멤버들과 다시 통신이 되지 않으면 자신이 추방됐음을 알지 못한다. 기본적으로 네트워크 단절로 인해 그룹 멤버들이 분리되는 경우 소수에 속하는 멤버들은 스르로 그룹을 탈퇴하지 않는다. `group_replication_unreachable_majority_timeout` 시스템 변수를 사용해 소수에 속한 멤버들이 과반수의 그룹 멤버들과 통신이 단절됐을 때 일정 시간 동안 대기한 후 스스로 그룹을 탈퇴하도록 설정할 수 있다. 소수에 속한 멤버들에서도 트랜잭션은 실행될 수 있으며, 실행된 트랜잭션은 멤버가 그룹의 과반수의 동의를 얻을 수 없으므로 처리가 보류된 상태로 남아 있게 된다. `group_replication_unreachable_majority_timeout` 시스템 변수에 지정된 시간이 초과되면 멤버는 보류 상태의 모든 트랜잭션을 롤백하고 그룹에서 탈퇴하며, 상태는 ERROR로 표기된다.

멤버가 그룹의 다른 멤버들과의 통신 단절 등의 문제로 인해 타의 혹은 자의로 그룹에서 탈퇴한 상태에서 재가입에 실패하거나 혹은 재가입을 시도하지 않게 설정된 경우 멤머는 최종적으로 `group_replication_exit_state_action` 시스템 변스에 설정된 작업을 실행하게 된다.

- READ_ONLY: super_read_only 시스템 변수를 ON으로 설정해서 MySQL 서버를 슈퍼 읽기 전용 모드로 전환시킨다.
- OFFLINE_MODE: offline_mode 시스템 변수를 ON으로 설정해서 MySQL 서버를 오프라인 모드로 전환시키고 super_read_only 시스템 변수도 ON으로 설정한다.
- ABORT_SERVER: MySQL 서버를 종료시킨다.
## 그룹 복제의 분산 복구
## 그룹 복제의 요구 사항

## 그룹 복제의 제약 사항

# MySQL 셸
MySQL 셸은 MySQL을 위한 고급 클라이언트 툴로, 단순히 SQL문 실행만 가능했던 기존 클라이언트 툴인 mysql보다 더 확장된 기능을 제공한다.

1. SQL 뿐만 아니라 Js, Python 언어 모드 지원
2. 편리하게 작업할 수 있도록 X 프로토콜 API 제공
  - X DevAPI: 관계형 데이터와 문서 기반 데이터를 모두 처리 가능
  - AdminAPI: InnoDB 클러스터 및 레플리카 셋 구축 가능
# MySQL 라우터
MySQL 라우터는 InnoDB 클러스에서 애플리케이션 서버로부터 유입된 쿼리 요청을 클러스터 내 적절한 MySQL 서버로 전달하고 MySQL 서버에서 반환된 쿼리 결과를 다시 애플리케이션 서버로 프록시 역할을 수행한다.

주요 기능은 다음과 같다.

1. InnoDB 클러스터의 MySQL 구성 변경 자동 감지
2. 쿼리 부하 분산
3. 자동 페일오버

MySQL 라우터를 통해 접근하면 커넥션 설정에는 라우터 서버 정보가 사용된다. MySQL 라우터에서는 클러스터 내 MySQL 서버들에 대한 정보를 메모리에 캐시하고 있으며, 주기적으로 이 정보를 갱신한다. 클러스터의 MySQL 서버 구성이 변경되면 MySQL 라우터는 갱신된 정보로 이를 자동으로 감지하므로 애플리케이션 서버의 커넥션 설정 정보를 변경할 필요가 없다. 따라서 사용자는 클러스터 내 MySQL 서버 추가 및 제거 등과 같은 구성 변경 작업을 애플리케이션 단의 설정 변경이 필요없다.

MySQL 라우터는 여러 MySQL 서버에 나눠서 처리되도록 **부하 분산**을 수행할 수도 있다. 이러한 부하 분산은 MySQL 라우터에서 클러스터로 설정된 라우팅 커넥션별로 수행되는데, 사용자는 각 커넥션에서 사용하고자 하는 부하 분산 방식을 지정할 수 있다. 또한 MySQL 라우터에서는 MySQL 서버에 장애가 발생한 경우 자동으로 다른 MySQL 서버로 쿼리 실행을 재시도하는데, 이때 지정된 부하 분산 방식에 따라 재시도할 MySQL 서버가 결정된다. 이처럼 MySQL 서버에 장애가 발생했을 때 MySQL 라우터가 이를 감지하고 자동으로 재시도하므로 애플리케이션 서버단에서는 별도의 장애 조치 없이도 정상적으로 쿼리를 실행할 수 있다. 
